!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.jzt=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
/**
 * JZT Basic
 * Copyright Â© 2014 Orangeline Interactive, Inc.
 * @author Mark McIntyre
 */

/*jslint node:true */

'use strict';

var ConstructorError = 'Constructor must be called with new.',
    Direction;

/**
 * Point represents a point on a cartesian plane.
 *
 * @param x An x coordinate.
 * @param y A y coordinate.
 */
function Point(x, y) {

    if (!(this instanceof Point)) {
        throw ConstructorError;
    }

    this.x = x;
    this.y = y;
}

/**
 * Creates a new Point with identical values to this one.
 *
 * @return A Point.
 */
Point.prototype.clone = function () {
    return new Point(this.x, this.y);
};

/**
 * Adds a provided point to this point, and returns the result.
 *
 * @param other Another point to add to this one.
 * @return A new point with the added value.
 */
Point.prototype.add = function (other) {
    return new Point(this.x + other.x, this.y + other.y);
};

/**
 * Subtracts a provided point from this point and returns the result.
 *
 * @param other Another point to subtract from this one.
 * @return A new point with the subtracted value.
 */
Point.prototype.subtract = function (other) {
    return new Point(this.x - other.x, this.y - other.y);
};

/**
 * Returns whether or not this point is directly adjacent to a provided point.
 *
 * @param other Another point to test for adjacency
 * @return true if a provided point is adjacent, false otherwise
 */
Point.prototype.adjacent = function (other) {

    var xDeviance = Math.abs(this.x - other.x),
        yDeviance = Math.abs(this.y - other.y);

    return !(xDeviance > 1 || yDeviance > 1);

};

/**
 * Retrieves whether or not a provided point is aligned with this one, within a given
 * spread threshold.
 *
 * @param other A point to test for alignment.
 * @param spread A spread threshold to allow for in the alignement calculation.
 * @return true if a provided point is aligned with this one, false otherwise.
 */
Point.prototype.aligned = function (other, spread, direction) {
    spread = spread === undefined ? 1 : spread;

    if (!direction) {
        return (Math.abs(this.x - other.x) < spread) || (Math.abs(this.y - other.y) < spread);
    }
    if (direction === Direction.North) {
        return (other.y < this.y) && Math.abs((this.x - other.x)) < spread;
    }
    if (direction === Direction.South) {
        return (other.y > this.y) && Math.abs((this.x - other.x)) < spread;
    }
    if (direction === Direction.East) {
        return (other.x > this.x) && Math.abs((this.y - other.y)) < spread;
    }
    if (direction === Direction.West) {
        return (other.x < this.x) && Math.abs((this.y - other.y)) < spread;
    }

    return undefined;

};

/**
 * Calculates a direction from this point to another point, along an optional axis. If
 * no axis is provided, then the closest of either the X or Y axis will be used. If
 * the distance on both axes are the same, then one will be picked at random.
 *
 * @param other Another point to calculate the direction toward.
 * @param axis 'x' or 'y' depending on the axis to be tested.
 * @return A Point representing a direction
 */
Point.prototype.directionTo = function (other, axis) {

    var xDistance = this.x - other.x,
        yDistance = this.y - other.y;

    // There is no direction to the same point
    if (xDistance === 0 && yDistance === 0) {
        return undefined;
    }

    if (axis === undefined) {
        if (xDistance === 0) {
            axis = 'y';
        } else if (yDistance === 0) {
            axis = 'x';
        } else {
            axis = (Math.floor(Math.random() * 2)) ? 'x' : 'y';
        }
    }

    if (axis === 'x') {
        if (xDistance === 0) {
            return undefined;
        }
        return xDistance < 0 ? Direction.East : Direction.West;
    }

    if (yDistance === 0) {
        return undefined;
    }

    return yDistance < 0 ? Direction.South : Direction.North;

};

/**
 * Compares a provided Point instance to this one.
 *
 * @return {number} - A negative value if the other instance is smaller, 0 if both are the same,
 *    and a positive value if other is greater.
 */
Point.prototype.compareTo = function (other) {
    return this.x === other.x ? this.y - other.y : this.x - other.x;
};

/**
 * Returns whether or not this Point is equal in value to another point.
 *
 * @param other A point to test for equality.
 * @return true if another point is equal in value to this point, false otherwise.
 */
Point.prototype.equals = function (other) {
    return this.x === other.x && this.y === other.y;
};

/**
 * Returns a string representation of this point.
 *
 * @return A string representation of this point.
 */
Point.prototype.toString = function () {
    return '(' + this.x + ', ' + this.y + ')';
};

/**
 * Direction is an enumerated type representing each of the four possible directions
 * on a tile-based grid.
 */
Direction = {
    North: new Point(0, -1),
    East: new Point(1, 0),
    South: new Point(0, 1),
    West: new Point(-1, 0)
};

/**
 * Performs a provided callback function for each possible direction on a tile-based
 * grid. The callback function will be given a single parameter containing the direction
 * being iterated.
 *
 * @param callback A callback function to be executed.
 */
Direction.each = function (callback) {
    callback(Direction.North);
    callback(Direction.East);
    callback(Direction.South);
    callback(Direction.West);
};

/**
 * Retrieves a Point representing a direction from a provided name.
 *
 * @param name A name of a direction
 * @return A Point representing a direction.
 */
Direction.fromName = function (name) {
    switch (name) {
    case 'N':
    case 'North':
        return Direction.North;
    case 'E':
    case 'East':
        return Direction.East;
    case 'S':
    case 'South':
        return Direction.South;
    case 'W':
    case 'West':
        return Direction.West;
    default:
        return undefined;
    }
};

/**
 * Retrieves a name for a provided Point representing a direction from our
 * enumerated direction types.
 *
 * @param {object} direction - A provided direction
 * @return {string} - A direction name.
 */
Direction.getName = function (direction) {

    switch (direction) {
    case Direction.North:
        return 'North';
    case Direction.East:
        return 'East';
    case Direction.South:
        return 'South';
    case Direction.West:
        return 'West';
    }

    return undefined;

};

/**
 * Retrieves a 'short' name for a provided Point representing a direction from
 * our enumerated direction types.
 *
 * @param {object} direction - A provided direction.
 * @param {string} - A direction name
 */
Direction.getShortName = function (direction) {

    switch (direction) {
    case Direction.North:
        return 'N';
    case Direction.East:
        return 'E';
    case Direction.South:
        return 'S';
    case Direction.West:
        return 'W';
    }

    return undefined;

};

/**
 * Given a direction from our Direction enumerated type, returns another
 * direction representing a clockwise rotation on 90 degrees.
 *
 * @param direction A direction.
 * @return A clockwise direction.
 */
Direction.clockwise = function (direction) {

    switch (direction) {
    case Direction.North:
        return Direction.East;
    case Direction.East:
        return Direction.South;
    case Direction.South:
        return Direction.West;
    case Direction.West:
        return Direction.North;
    }

    return undefined;

};

/**
 * Given a direction from our Direction enumerated type, returns another direction
 * representing a random choice perpendicular to the provided one.
 *
 * @param direction A direction.
 * @return A new direction perpendicular to the provided one, at random.
 */
Direction.randomPerpendicular = function (direction) {

    switch (direction) {
    case Direction.North:
    case Direction.South:
        return Direction.randomEastWest();
    default:
        return Direction.randomNorthSouth();
    }

};

/**
 * Returns a Point representing either North or South, at random.
 *
 * @return A Point direction.
 */
Direction.randomNorthSouth = function () {
    return Direction.random([Direction.North, Direction.South]);
};

/**
 * Returns a Point representing either East or West, at random.
 *
 * @return A Point direction.
 */
Direction.randomEastWest = function () {
    return Direction.random([Direction.East, Direction.West]);
};

/**
 * Returns a Point representing either North or East, at random.
 *
 * @return A Point direction.
 */
Direction.randomNorthEast = function () {
    return Direction.random([Direction.North, Direction.East]);
};

/**
 * Returns a random direction from our Direction enumerated type from a provided array of
 * possible directions. If no such array is provided, then all directions will be considered
 * as candidates.
 *
 * @param directions An array of possible directions to choose at random
 * @return A random Point representing a Direction.
 */
Direction.random = function (directions) {

    // If an array of directions to pick from wasn't specified...
    if (!directions) {
        directions = [Direction.North, Direction.East, Direction.South, Direction.West];
    }

    // Return a random direction from our array
    return directions[Math.floor(Math.random() * directions.length)];

};

/**
 * Returns a Direction rotated 90 degrees counter-clockwise to a provided Direction.
 *
 * @param direction A direction
 * @return A direction rotated 90 degrees counter-clockwise.
 */
Direction.counterClockwise = function (direction) {

    switch (direction) {
    case Direction.North:
        return Direction.West;
    case Direction.West:
        return Direction.South;
    case Direction.South:
        return Direction.East;
    case Direction.East:
        return Direction.North;
    }

    return undefined;

};

/**
 * Given a direction, returns a direction facing the opposite direction.
 *
 * @param direction
 * @return A Point representing an opposite direction.
 */
Direction.opposite = function (direction) {

    switch (direction) {
    case Direction.North:
        return Direction.South;
    case Direction.East:
        return Direction.West;
    case Direction.South:
        return Direction.North;
    case Direction.West:
        return Direction.East;
    }

    return undefined;

};

/**
 * DelayedEventScheduler is an event scheduler that includes an initial delay
 * before repeating events. This is used, for example, to "repeat" events as long as a key
 * is held down, but includes a slight delay before the repeating happens.
 *
 * @param {number} initialDelay - A number of milliseconds to use as an initial delay
 * @param {number} subsequentDelay - A number of milliseconds to repeat events after the initial delay
 */
function DelayedEventScheduler(initialDelay, subsequentDelay) {

    if (!(this instanceof DelayedEventScheduler)) {
        throw ConstructorError;
    }

    this.initialDelay = initialDelay;
    this.subsequentDelay = subsequentDelay;
    this.event = undefined;
    this.nextAllowableEvent = 0;

}

/**
 * Schedules an event, expected to have started at a provided event time.
 *
 * @param {number} eventTime - A timestamp indicating the event time
 * @param {object} event - An arbitrary object representing an event to retrieve
 *     later at scheduled intervals.
 */
DelayedEventScheduler.prototype.scheduleEvent = function (eventTime, event) {

    var now = Date.now();

    if (now > this.nextAllowableEvent) {

        if (eventTime + this.initialDelay < now) {
            this.nextAllowableEvent = now + this.subsequentDelay;
        } else {
            this.nextAllowableEvent = now + this.initialDelay;
        }

        this.event = event;
    }

};

/**
 * Cancels this event scheduler's scheduled event.
 */
DelayedEventScheduler.prototype.cancelEvent = function () {
    this.nextAllowableEvent = 0;
};

/**
 * Takes a scheduled event from this event scheduler.
 *
 * @return {object} - A scheduled event
 */
DelayedEventScheduler.prototype.takeEvent = function () {
    var result = this.event;
    this.event = undefined;
    return result;
};

/**
 * NotificationListener
 */
function NotificationListener() {

    if (!(this instanceof NotificationListener)) {
        throw ConstructorError;
    }

    this.notifications = [];
}

/**
 * Adds a provided notification to this notification listner.
 *
 * @param {string} type - A notification type
 * @param {string} message - A notification message
 */
NotificationListener.prototype.addNotification = function (type, message) {
    this.notifications.push({type: type, message: message, timestamp: Date.now()});
};

/**
 * An object to store utility functions.
 */
var utilities = {};

/**
 * Adds a property to a provided destination object as a given name and value,
 * only if the value is doesn't match a provided default.
 *
 * @param destination A destination object
 * @param name A name of a property
 * @param value A value to be stored.
 * @param defaultValue A default value.
 */
utilities.storeOption = function (destination, name, value, defaultValue) {
    if (value !== defaultValue) {
        destination[name] = value;
    }
};

/**
 * Generates line data between two points.
 *
 * @param point1 A first point
 * @param point2 A second point
 * @return Line data with a points array, contains function, and forEach function.
 */
utilities.generateLineData = function (point1, point2) {

    var result = {},
        dx = Math.abs(point2.x - point1.x),
        dy = Math.abs(point2.y - point1.y),
        sx = (point1.x < point2.x) ? 1 : -1,
        sy = (point1.y < point2.y) ? 1 : -1,
        err = dx - dy,
        e2,
        x,
        y;

    result.points = [];

    /*
     * Returns whether or not this line data contains a provided point.
     */
    result.contains = function (point) {
        var index;
        for (index = 0; index < this.points.length; index += 1) {
            if (this.points[index].equals(point)) {
                return true;
            }
        }
        return false;
    };

    /*
     * Performs a callback function for each point in this line data.
     */
    result.forEach = function (callback) {
        var index;
        if (callback && typeof callback === 'function') {
            for (index = 0; index < this.points.length; index += 1) {
                callback(this.points[index]);
            }
        }
    };

    x = point1.x;
    y = point1.y;
    while (true) {
        result.points.push(new Point(x, y));
        if ((x === point2.x) && (y === point2.y)) {
            return result;
        }
        e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x += sx;
        }
        if (e2 < dx) {
            err += dx;
            y += sy;
        }
    }

    return result;

};

/**
 * Generates a circle given a center point and a radius to surround it.
 * Note that since tiles are twice as high as they are wide, the circle
 * is adjusted to have double the width as the height.
 *
 * @param {object} point - A center point
 * @param {number} radius - A radius
 * @return {object} - An ellipse object representing the tiles covered by an ellipse
 */
utilities.generateCircleData = function (point, radius) {
    return utilities.generateEllipseData(point, radius * 2, radius);
};

/**
 * Generates an ellipse given a center point, an X radius, and a Y radius.
 *
 * @param {object} point - A center point
 * @param {number} rx - An X radius
 * @param {number} ry - A Y radius
 * @return {object} - An ellipse object representing the tiles covered by an ellipse
 */
utilities.generateEllipseData = function (point, rx, ry) {

    var result = {},
        rx2 = rx * rx,
        ry2 = ry * ry,
        twoRx2 = 2 * rx2,
        twoRy2 = 2 * ry2,
        p,
        x = 0,
        y = ry,
        px = 0,
        py = twoRx2 * y,
        minMax;

    /**
     * Retrieves whether or not a provided point is covered by this
     * ellipse.
     *
     * @param {object} point - A point to test
     * @return {boolean} - True if the provided point is inside this ellipse, false otherwise
     */
    result.contains = function (point) {
        if (this[point.y]) {
            minMax = this[point.y];
            return point.x >= minMax[0] && point.x <= minMax[1];
        }
        return false;
    };

    // If there is no radius...
    if (rx === 0 && ry === 0) {

        // We should always contain the center point
        result[point.y] = [point.x, point.x];

        // Return immediately
        return result;

    }

    // Upper Region
    p = Math.round(ry2 - (rx2 * ry) + (0.25 * rx2));
    while (px < py) {
        x += 1;
        px += twoRy2;
        if (p < 0) {
            p += ry2 + px;
        } else {
            y -= 1;
            py -= twoRx2;
            p += ry2 + px - py;
        }
        minMax = [point.x - x, point.x + x];
        result[point.y + y] = minMax;
        result[point.y - y] = minMax;
    }

    // Lower Region
    p = Math.round(ry2 * (x + 0.5) * (x + 0.5) + rx2 * (y - 1) * (y - 1) - rx2 * ry2);
    while (y > 0) {
        y -= 1;
        py -= twoRx2;
        if (p > 0) {
            p += rx2 - py;
        } else {
            x += 1;
            px += twoRy2;
            p += rx2 - py + px;
        }
        minMax = [point.x - x, point.x + x];
        result[point.y + y] = minMax;
        result[point.y - y] = minMax;
    }

    return result;

};

/**
 * Retrieves an array of points that fall within a defined circle with
 * a provided center point and radius.
 *
 * @param {object} point - A center point
 * @param {number} radius - A radius
 * @return {object[]} - An array of points
 */
utilities.pointsInCircle = function (point, radius) {
    return utilities.pointsInEllipse(point, radius * 2, radius);
};

/**
 * Retrieves an array of points that fall within a defined ellipse with
 * a provided center point and provided x and y radius..
 *
 * @param {object} point - A center point
 * @param {number} rx - An X radius
 * @param {number} ry - A Y radius
 * @return {object[]} - An array of points
 */
utilities.pointsInEllipse = function (point, rx, ry) {

    var result = [],
        index,
        ellipseSegment,
        minMax,
        min,
        max,
        ellipseData = utilities.generateEllipseData(point, rx, ry);

    for (ellipseSegment in ellipseData) {
        if (ellipseData.hasOwnProperty(ellipseSegment)) {

            minMax = ellipseData[ellipseSegment];
            min = minMax[0];
            max = minMax[1];

            for (index = min; index <= max; index += 1) {
                result.push(new Point(index, ellipseSegment));
            }

        }
    }

    return result;

};

exports.Point = Point;
exports.Direction = Direction;
exports.DelayedEventScheduler = DelayedEventScheduler;
exports.NotificationListener = NotificationListener;
exports.utilities = utilities;
exports.ConstructorError = ConstructorError;

},{}],2:[function(_dereq_,module,exports){
/**
 * JZT Board
 * Copyright Â© 2014 Orangeline Interactive, Inc.
 * @author Mark McIntyre
 */

/*jslint node:true */

'use strict';

var ConstructorError = _dereq_('./basic').ConstructorError,
    Point = _dereq_('./basic').Point,
    Colors = _dereq_('./graphics').Colors,
    utilities = _dereq_('./basic').utilities,
    JztScript = _dereq_('./jzt-script').JztScript,
    things = _dereq_('./things').things,
    ThingFactory = _dereq_('./things').ThingFactory,
    Direction = _dereq_('./basic').Direction,
    i18n = _dereq_('./i18n');

/**
 * Board represents a single game board.
 *
 * @param boardData Serialized board data to load and use for this Board.
 * @param game A Game instance to serve as owner of this board
 */
function Board(boardData, game) {

    if (!(this instanceof Board)) {
        throw ConstructorError;
    }

    this.validateData(boardData);

    this.name = boardData.name;
    this.game = game;
    this.tiles = [];
    this.scripts = [];
    this.dark = boardData.dark;
    this.reenter = boardData.reenter;
    this.smartPath = [];
    this.customRenderSet = [];
    this.torches = [];
    this.focusPoint = new Point(0, 0);
    this.maxPlayerBullets = boardData.maxPlayerBullets !== undefined ? boardData.maxPlayerBullets : Infinity;
    this.playerBullets = 0;
    this.i18n = undefined;

    this.north = boardData.north;
    this.east = boardData.east;
    this.south = boardData.south;
    this.west = boardData.west;
    this.northOffset = boardData.northOffset || 0;
    this.eastOffset = boardData.eastOffset || 0;
    this.southOffset = boardData.southOffset || 0;
    this.westOffset = boardData.westOffset || 0;

    this.defaultPlayerX = boardData.playerX;
    this.defaultPlayerY = boardData.playerY;

    if (boardData.hasOwnProperty('entryPointX') && boardData.hasOwnProperty('entryPointY')) {
        this.entryPoint = new Point(boardData.entryPointX, boardData.entryPointY);
    }

    this.displayMessage = undefined;
    this.displayMessageTick = 0;

    this.DISPLAY_MESSAGE_TTL = game.FPS * 3; // 3 seconds
    this.DARK_SPRITE = game.resources.graphics.getSprite(176);
    this.DARK_SPRITE_COLOR = Colors.Grey;

    this.height = boardData.height;
    this.width = boardData.width;

    this.initializeI18n(boardData.i18n);
    this.initializeScripts(boardData.scripts);
    this.initializeTiles(boardData.tiles);
    this.initializeWindow();

}

/**
 * Validates provided board data to make sure it contains some expected
 * properties for deserialization.
 *
 * @param data Data to be validated
 */
Board.prototype.validateData = function (data) {

    // Let's hope for the best...
    var valid = true;

    if (!data.height || !data.width) { valid = false; }
    if (typeof data.height !== 'number') { valid = false; }
    if (typeof data.width !== 'number') { valid = false; }
    if (data.height > 256 || data.height < 10) { valid = false; }
    if (data.width > 256 || data.width < 10) { valid = false; }
    if (!data.tiles || !(Array.isArray(data.tiles))) { valid = false; }
    if (!data.scripts || !(Array.isArray(data.scripts))) { valid = false; }

    if (!valid) {
        throw 'Invalid board data.';
    }

};

/**
 * Serializes this Board instance to an object.
 *
 * @return An object representation of this board data.
 */
Board.prototype.serialize = function () {

    var result = {},
        index,
        script,
        message;

    result.name = this.name;

    utilities.storeOption(result, 'dark', this.dark);
    utilities.storeOption(result, 'displayMessage', this.displayMessage);
    utilities.storeOption(result, 'north', this.north);
    utilities.storeOption(result, 'east', this.east);
    utilities.storeOption(result, 'south', this.south);
    utilities.storeOption(result, 'west', this.west);
    utilities.storeOption(result, 'northOffset', this.northOffset);
    utilities.storeOption(result, 'eastOffset', this.eastOffset);
    utilities.storeOption(result, 'southOffset', this.southOffset);
    utilities.storeOption(result, 'westOffset', this.westOffset);
    utilities.storeOption(result, 'reenter', this.reenter);

    if (this.maxPlayerBullets !== Infinity) {
        result.maxPlayerBullets = this.maxPlayerBullets;
    }

    if (this.player) {
        result.playerX = this.player.point.x;
        result.playerY = this.player.point.y;
    } else {
        result.playerX = this.defaultPlayerX;
        result.playerY = this.defaultPlayerY;
    }

    if (this.entryPoint) {
        result.entryPointX = this.entryPoint.x;
        result.entryPointY = this.entryPoint.y;
    }

    result.width = this.width;
    result.height = this.height;
    result.tiles = [];
    result.scripts = [];

    // Store tiles
    this.each(function (tile) {
        if (tile) {
            result.tiles.push(tile.serialize());
        } else {
            result.tiles.push(0);
        }
    });

    // Store scripts
    for (index = 0; index < this.scripts.length; index += 1) {
        script = this.scripts[index];
        if (this.game.isEditor) {
            result.scripts.push({'name': script.name, 'rawScript': script.rawScript || script.script});
        } else {
            result.scripts.push(script.serialize());
        }
    }

    // Store i18n data
    if (this.i18n) {

        // Create an i18n container for our results
        result.i18n = {};

        // For each of our i18n values...
        for (index in this.i18n) {
            if (this.i18n.hasOwnProperty(index)) {

                // We are expecting a two-letter language code
                if (typeof this.i18n[index] === 'string' || index.length === 2) {

                    // Create an object for our language strings
                    result.i18n[index] = {};

                    for (message in this.i18n[index]) {
                        if (this.i18n[index].hasOwnProperty(message)) {
                            // If our value is a string, store it in our result
                            if (typeof this.i18n[index][message] === 'string') {
                                result.i18n[index][message] = this.i18n[index][message];
                            }
                        }
                    }

                }

            }
        }

    }

    return result;

};

/**
 * Initializes scripts used by this Board based on provided script
 * data.
 *
 * @param scriptData Script data to be deserialized into Script instances.
 */
Board.prototype.initializeScripts = function (scriptData) {

    var index, script;

    // If we're in editor mode, there's no need to compile
    if (this.game.isEditor) {
        this.scripts = scriptData;
        return;
    }

    for (index = 0; index < scriptData.length; index += 1) {

        try {
            script = new JztScript(scriptData[index].name, scriptData[index].rawScript, true);
            this.scripts.push(script);
        } catch (exception) {
            this.game.notifyListeners('script-error', {scriptName: scriptData[index].name, error: exception});
        }


    }

};

Board.prototype.initializeI18n = function (i18nData) {

    var language,
        entry;

    if (i18nData) {

        this.i18n = {};

        // For each of our i18n values...
        for (language in i18nData) {
            if (i18nData.hasOwnProperty(language)) {

                if (typeof language === 'string' && language.length === 2) {

                    // Create a section for our messages in this language
                    this.i18n[language] = {};

                    for (entry in i18nData[language]) {
                        if (i18nData[language].hasOwnProperty(entry)) {

                            // If our value is a string, store it in our result
                            if (typeof i18nData[language][entry] === 'string') {
                                this.i18n[language][entry] = i18nData[language][entry];
                            }

                        }
                    }

                }

            }
        }

    }

};

Board.prototype.getScriptables = function (name) {

    var result = [];

    this.each(function (tile) {
        if (tile && tile.type === 'Scriptable') {

            if (!name || (tile.name && tile.name.toUpperCase() === name)) {
                result.push(tile);
            }

        }
    });

    return result;

};

/**
 * Takes a provided player an initializes it for use on this board.
 *
 * @param A player instance to use on this board.
 */
Board.prototype.initializePlayer = function (player) {

    var scriptables,
        index,
        tile;

    // Check if our player is outside our range
    if (this.isOutside(player.point)) {

        // If so, use our default location
        player.point.x = this.defaultPlayerX;
        player.point.y = this.defaultPlayerY;

    }

    // Check if there's something at the player's position already.
    // Whatever it is, the player needs to go on top of it.
    tile = this.getTile(player.point);
    player.under = tile;

    this.player = player;
    this.setTile(player.point, player);
    this.player.board = this;
    this.initializeTorch(this.player);
    this.focusPoint = this.player.point;

    // If we don't have an entry point for this board, set it now
    if (!this.entryPoint) {
        this.entryPoint = player.point.clone();
    }

    // If we're not editing, send Scriptables the 'enter' message
    if (!this.game.isEditor) {
        scriptables = this.getScriptables();
        for (index = 0; index < scriptables.length; index += 1) {
            scriptables[index].sendMessage('ENTER');
        }
    }

};

/*
 * Intializes tile data given a collection of serialized tiles.
 *
 * @param tileDataCollection an array of serialized tile data to be loaded
 *      into this Board.
 */
Board.prototype.initializeTiles = function (tileDataCollection) {

    var x = 0,
        y = 0,
        index,
        tile,
        thing;

    for (index in tileDataCollection) {

        if (tileDataCollection.hasOwnProperty(index)) {

            tile = tileDataCollection[index];
            thing = ThingFactory.deserialize(tile, this);

            if (thing !== undefined) {
                this.setTile(new Point(x, y), thing);
                this.initializeTorch(thing);
            }

            x += 1;
            if (x >= this.width) {
                x = 0;
                y += 1;
            }

        }

    }

};

/**
 * Initializes a Torch for a provided thing
 *
 * @param A thing for which to initialize a torch
 */
Board.prototype.initializeTorch = function (thing) {

    var torch;

    // If the board is dark and we've got a torch, add it to our collection
    if (!(this.game.isEditor) && this.dark && typeof (thing.getTorch) === 'function') {
        torch = thing.getTorch();
        if (torch) {
            this.torches.push(torch);
        }
    }
};

Board.prototype.initializeWindow = function () {

    var canvasWidth = this.game.context.canvas.width,
        canvasHeight = this.game.context.canvas.height;

    this.windowSize = new Point(0, 0);
    this.windowOrigin = new Point(0, 0);

    this.windowSize.x = Math.floor(canvasWidth / this.game.resources.graphics.TILE_SIZE.x);
    this.windowSize.y = Math.floor(canvasHeight / this.game.resources.graphics.TILE_SIZE.y);

    this.windowLimit = new Point(this.width - this.windowSize.x, this.height - this.windowSize.y);

    this.updateWindowPosition();

    if (this.windowSize.x > this.width) {
        this.windowOrigin.x = -Math.round((this.windowSize.x - this.width) / 2);
    }

    if (this.windowSize.y > this.height) {
        this.windowOrigin.y = -Math.round((this.windowSize.y - this.height) / 2);
    }


};

Board.prototype.updateWindowPosition = function () {

    if (this.focusPoint) {

        if (this.width > this.windowSize.x) {
            this.windowOrigin.x = this.focusPoint.x - Math.round(this.windowSize.x / 2);
            this.windowOrigin.x = this.windowOrigin.x < 0 ? 0 : this.windowOrigin.x > this.windowLimit.x ? this.windowLimit.x : this.windowOrigin.x;
        }

        if (this.height > this.windowSize.y) {
            this.windowOrigin.y = this.focusPoint.y - Math.round(this.windowSize.y / 2);
            this.windowOrigin.y = this.windowOrigin.y < 0 ? 0 : this.windowOrigin.y > this.windowLimit.y ? this.windowLimit.y : this.windowOrigin.y;
        }

    }

};

/**
 * Retrieves a Script instance by its name for this Board.
 *
 * @param scriptName A name of a Script instance
 * @return A Script instance.
 */
Board.prototype.getScript = function (scriptName) {

    var index, script;

    if (scriptName && this.scripts) {

        for (index = 0; index < this.scripts.length; index += 1) {
            script = this.scripts[index];
            if (scriptName === script.name) {
                return script;
            }
        }

    }

    return undefined;

};

/**
 * Executes a provided callback function for each tile on this Board,
 * providing the function with a Thing instance and the point at which
 * it occurs. If no thing instance is at a location, undefined is returned.
 *
 * @param callback A callback function to be executed for each tile
 */
Board.prototype.each = function (callback) {

    var values = this.tiles.slice(0),
        point = new Point(0, 0);

    for (point.y = 0; point.y < this.height; point.y += 1) {
        for (point.x = 0; point.x < this.width; point.x += 1) {
            callback(values[point.x + point.y * this.width], point);
        }
    }

};

/**
 * Executes a provided callback function for each tile on this Board,
 * delivered in reverse order. The callback function will be provided with
 * a Thing instance and the point at which it occurs. If no Thing instance
 * is available at a location, undefined is returned.
 *
 * @param callback A callback function to be executed for each tile, in reverse.
 */
Board.prototype.eachBackwards = function (callback) {

    var values = this.tiles.slice(0),
        point = new Point(0, 0);

    for (point.y = this.height - 1; point.y >= 0; point.y -= 1) {
        for (point.x = this.width - 1; point.x >= 0; point.x -= 1) {
            callback(values[point.x + point.y * this.width], point);
        }
    }

};

/**
 * Executes a provided callback function for each tile on this Board that falls within
 * this board's displayable window. The callback function will be provided with a Thing
 * instance and the point at which it occurs. If no Thing instance is available at a location
 * undefined is returned.
 *
 * @param callback A callback function to be executed for each tile.
 */
Board.prototype.eachDisplayable = function (callback) {

    var values = this.tiles.slice(0),
        point = new Point(0, 0),
        startY = this.windowOrigin.y,
        endY = startY + this.windowSize.y,
        startX = this.windowOrigin.x,
        endX = startX + this.windowSize.x;

    startX = startX < 0 ? 0 : startX;
    startY = startY < 0 ? 0 : startY;
    endX = endX > this.width ? this.width : endX;
    endY = endY > this.height ? this.height : endY;

    for (point.y = startY; point.y < endY; point.y += 1) {
        for (point.x = startX; point.x < endX; point.x += 1) {
            callback(values[point.x + point.y * this.width], point);
        }
    }

};

/**
 * Retrieves whether or not this Board has a provided number (or any) of a
 * specific tile type.
 *
 * @param {object} template - A Thing template object
 * @param {number} [count] - A minimum number of tiles on the board to test for, or undefined to test for any number
 */
Board.prototype.hasTile = function (template, count) {

    var tally = 0;

    this.each(function (tile) {

        if (tile && tile.equals(template)) {
            tally += 1;
        }

    });

    return count === undefined ? tally > 0 : count <= 0 ? tally <= 0 : tally >= count;

};

/**
 * Changes all instances of tiles matching a provided template with a new instance based
 * on another provided template.
 *
 * @param fromTemplate A template to match existing things
 * @param toTemplate A template with which to replace matched things
 */
Board.prototype.changeTiles = function (fromTemplate, toTemplate) {

    var me = this,
        newThing;

    this.each(function (tile) {

        if (tile && tile.equals(fromTemplate)) {

            newThing = ThingFactory.deserialize(toTemplate, me);

            if (newThing && toTemplate.color === undefined) {
                newThing.foreground = tile.foreground;
            }

            me.replaceTile(tile.point, newThing);
        }

    });

};

/**
 * Removes a tile from this Board at a provided Point. This function will also
 * update its internal representation to remove references to no-longer-used
 * tiles.
 *
 * @param point A point on this Board to delete.
 */
Board.prototype.deleteTile = function (point) {

    var thing = this.getTile(point);

    // Delete the tile
    if (thing) {
        this.setTile(point, thing.under);
    }

};

/**
 * Moves a tile on this Board from a specified Point to another Point.
 * If the move was successful, true is returned, otherwise false. We can
 * optionally specify whether the move should be weak, meaning moves should
 * be treated as unsuccessful even when a pushable Thing is in the way.
 *
 * @param oldPoint A point on this Board containing a tile to be moved
 * @param newPoint A point on the Board to which a tile is to be moved.
 * @param weak Whether or not we should weakly move the tile.
 * @param ghost Whether or not we should actually move the tile, or behave as if a ghost moved (without actually moving)
 * @return true if a move was successful, false otherwise.
 */
Board.prototype.moveTile = function (oldPoint, newPoint, weak, ghost) {

    var thing = this.getTile(oldPoint),
        obstacle = this.getTile(newPoint),
        underOldThing,
        teleported;

    // If the coast is clear...
    if (this.isFree(newPoint)) {

        if (!ghost) {

            this.setTile(newPoint, thing);
            this.setTile(oldPoint, thing === undefined ? undefined : thing.under);

            if (thing !== undefined) {
                thing.under = undefined;
            }
        }

        return true;
    }

    // If we are blocked, but the path is surrenderable...
    if (!this.isOutside(newPoint) && obstacle.isSurrenderable(thing)) {

        if (!ghost) {
            // If our thing isn't undefined
            if (thing !== undefined) {
                underOldThing = thing.under;
                thing.under = obstacle;
            }

            this.setTile(newPoint, thing);
            this.setTile(oldPoint, underOldThing);
        }

        return true;

    }

    // If we couldn't move and we're not weak, try to push and try again
    if (!weak) {

        // If an obstacle was encountered
        if (obstacle) {

            // Try to push the obstacle out of the way
            teleported = obstacle.push(oldPoint.directionTo(newPoint), thing);

            // If we were teleported, return true
            if (teleported) {

                return true;

            }

            // A space was freed up or surrenderable, so we can move
            if (this.isFree(newPoint) || this.getTile(newPoint).isSurrenderable(thing)) {
                return this.moveTile(oldPoint, newPoint, weak, ghost);
            }

        }
    }

    return false;
};

/**
 * Assigns a tile to a specific Point on this Board. This function does
 * not check for saftey of this operation.
 *
 * @param point A point to be set to a specific tile
 * @param tile A tile to be set.
 */
Board.prototype.setTile = function (point, tile) {

    if (!this.isOutside(point)) {

        if (tile) {

            tile.point = point.clone();

            // If we're adding a player when we've already got one on the board elsewhere...
            if (tile.type === 'Player' && (!point.equals(this.player.point))) {

                // Remove the old player
                this.deleteTile(this.player.point);

                // Add our new player
                tile = this.player;
                tile.point = point.clone();
                this.initializePlayer(this.player);

            }

        }

        this.tiles[point.x + point.y * this.width] = tile;

    }
};

/**
 * Adds a Thing to a specific Point on this Board. This function
 * will safely delete any existing Thing if present at the specified
 * location and will update any UpdateableThing list, unless we opt
 * to respect surrenderability, in which case the thing will only be deleted
 * if it refuses to surrender.
 *
 * @param point A point at which to add a Thing
 * @param thing A Thing to add at a given point
 * @param respectSurrenderability Whether to respect the surrenderability of an item
 */
Board.prototype.addThing = function (point, thing, respectSurrenderabilty) {

    var oldThing = this.getTile(point);

    if (oldThing) {
        if (respectSurrenderabilty && oldThing.isSurrenderable(thing)) {
            thing.under = oldThing;
        } else {
            this.deleteTile(point);
        }
    }

    this.setTile(point, thing);

};

/**
 * Returns whether or not a specific point is free or surrenderable to a provided Thing.
 *
 * @param point A point to test for
 * @param thing A thing used to test for surrenderability if a point is not free.
 * @return true if the provided spot is either free, or surrenderable to a provided thing.
 */
Board.prototype.isFreeOrSurrenderable = function (point, thing) {

    var obstacle = this.getTile(point);
    return !this.isOutside(point) && ((!obstacle) || (obstacle.isSurrenderable(thing)));

};

/**
 * Retrieves a tile from this Board at a provided Point.
 *
 * @param point A point from which to retrieve a tile.
 * @return a Thing located at a provided Point, or undefined if no such
 *          this is available at a given Point.
 */
Board.prototype.getTile = function (point) {

    if (point.x >= this.width || point.x < 0 || point.y >= this.height || point.y < 0) {
        return undefined;
    }

    return this.tiles[point.x + point.y * this.width];

};

/**
 * Replaces an existing tile at a given Point with a provided Thing.
 * This function checks for saftey.
 *
 * @param point A point on this Board to be replaced
 * @param A Thing to be added to a given point.
 */
Board.prototype.replaceTile = function (point, newTile) {
    this.deleteTile(point);
    this.addThing(point, newTile, true);
};

/**
 * Returns true if a provided Point is located outside of this Board's
 * boundaries.
 *
 * @param point A point to check
 * @return true if a provided Point is outisde this Board's boundaries,
 *         false otherwise.
 */
Board.prototype.isOutside = function (point) {

    if (point.y < 0 || point.y >= this.height) {
        return true;
    }

    if (point.x < 0 || point.x >= this.width) {
        return true;
    }

    return false;

};

/**
 * Returns true if a provided Point is located outside of this Board's visible
 * window boundary.
 *
 * @param point A point to check.
 * @return true if a provided Point is outside this Board's boundaries, false otherwise.
 */
Board.prototype.isOutsideWindow = function (point) {
    if (point.x < this.windowOrigin.x || point.x >= (this.windowOrigin.x + this.windowSize.x)) {
        return true;
    }
    if (point.y < this.windowOrigin.y || point.y >= (this.windowOrigin.y + this.windowSize.y)) {
        return true;
    }

    return false;
};

/**
 * Returns whether or not a provided Point is unoccupied.
 *
 * @param point a Point to test.
 * @return true if a provided Point is free, false otherwise.
 */
Board.prototype.isFree = function (point) {

    return !this.isOutside(point) && (!this.getTile(point));

};

/**
 * Requests to move this Board's player to a Board located
 * in a given direction relative to this Board.
 *
 * @param direction An adjacent board direction to which to
 *        relocate a player.
 */
Board.prototype.movePlayerOffBoard = function (direction) {

    var boardName,
        offset;

    // Find the board we are switching to
    switch (direction) {
    case Direction.North:
        boardName = this.north;
        offset = this.northOffset;
        break;
    case Direction.East:
        boardName = this.east;
        offset = this.eastOffset;
        break;
    case Direction.South:
        boardName = this.south;
        offset = this.southOffset;
        break;
    case Direction.West:
        boardName = this.west;
        offset = this.westOffset;
        break;
    default:
        return;
    }

    // Move our player to that board edge
    this.game.movePlayerToBoardEdge(Direction.opposite(direction), boardName, offset);

};

/**
 * Retrieves a Passage with a provided ID from this board.
 *
 * @param passageId an ID of a passage to retrieve
 * @return A Passage instance.
 */
Board.prototype.getPassage = function (passageId) {

    var row, column, tile;

    for (row = 0; row < this.height; row += 1) {
        for (column = 0; column < this.width; column += 1) {
            tile = this.getTile(new Point(column, row));
            if (tile && tile.type === 'Passage' && tile.passageId === passageId) {
                return tile;
            }
        }
    }

};

/**
 * Adds a provided message to this Board's queue of messages to globally
 * send to all UpdateableThings tracked by this Board.
 *
 * @param message A message to be delivered to all UpdateableThings.
 */
Board.prototype.addMessage = function (message) {
    this.messageQueue.push(message);
};

/**
 * Retrieves whether or not a provided point falls within any of this
 * Board's torches.
 *
 * @param point A Point to test if it's inside a torch circle
 * @param thing A thing at the point to test if it's glowing (or lit by torches)
 * @return true if a provided point is within any torch circle, false otherwise
 */
Board.prototype.isLit = function (point, thing) {

    var index,
        torch;

    if (thing && thing.glow) {
        return true;
    }

    for (index = 0; index < this.torches.length; index += 1) {
        torch = this.torches[index];
        if (torch.contains(point)) {
            return true;
        }
    }

    return false;

};

/**
 * Returns whether or not another player bullet is permissable on the board
 * after the most recent update.
 *
 * @param displayMessage Whether or not to display a message if no shooting is allowed, ever.
 * @return true if another player bullet is allowed, false otherwise
 */
Board.prototype.canPlayerShoot = function (displayMessage) {

    if (displayMessage && this.maxPlayerBullets <= 0) {
        this.setDisplayMessage(i18n.getMessage('status.noshoot'));
    }

    return this.playerBullets < this.maxPlayerBullets;

};

/**
 * Updates this Board instance by one tick in an execution cycle. This will also
 * update all UpdateableThings tracked by this Board.
 */
Board.prototype.update = function () {

    var me = this;

    // Update the smart path
    this.updateSmartPath(this.player.point);

    // Initialize our custom renderable list
    this.customRenderSet = [];

    // Initialize our bullet count
    this.playerBullets = 0;

    // If the board is dark, initialize our torches
    if (this.dark) {
        this.torches = [];
    }

    /*
     * This function works as follows: Each tile is looped through in sequential
     * order, and once again in reverse order. A tile may opt to be sent its
     * update message in either one loop or the other via its updateOnReverse
     * function. Tiles may wish to update in reverse because they are about to
     * move in the same direction as the updates (for example, a Bullet travelling
     * South). This results in smoother motion for such movements.
     */

    // For each tile on our board...
    this.each(function (tile) {

        if (tile) {

            // If we got a player bullet, update our count
            if (tile.type === 'Bullet' && tile.fromPlayer) {
                me.playerBullets += 1;
            }

            // If we got an updateable tile...
            if ((typeof tile.update === 'function') && (typeof tile.updateOnReverse === 'function') && tile.type !== 'Player') {

                // If we aren't updating backwards...
                if (!tile.updateOnReverse()) {
                    tile.update();
                }

            }

            // If the tile the thing is on is updateable while under...
            if (tile.under && tile.under.updateWhileUnder) {
                tile.under.updateWhileUnder();
            }

            // If we've got a tile with a custom renderer...
            if (tile.render) {
                me.customRenderSet.push(tile);
            }

            // Update our torch, if applicable
            if (tile.type !== 'Player') {
                me.initializeTorch(tile);
            }

        }

    });

    // For each tile on our board in reverse...
    this.eachBackwards(function (tile) {

        // If a tile wants to be udpated backwards, do it now
        if (tile && (typeof tile.update === 'function') && (typeof tile.updateOnReverse === 'function') && tile.updateOnReverse() && (tile.type !== 'Player')) {
            tile.update();
        }

    });

};

/**
 * Returns whether or not this Board is the same as another board, either by
 * name or reference.
 *
 * @param otherBoard another Board or name of another board to test for equality.
 * @return true if this Board is the same by name, false otherwise
 */
Board.prototype.equals = function (otherBoard) {

    var otherName = (otherBoard instanceof Board) ? otherBoard.name : otherBoard;
    return this.name === otherName;

};

/**
 * Assigns a message to be temporarily displayed at the bottom of this Board.
 *
 * @param message a message to be displayed.
 */
Board.prototype.setDisplayMessage = function (message, duration) {

    if (message !== undefined) {
        this.displayMessage = ' ' + message + ' ';
        if (this.displayMessage.length > this.windowSize.x) {
            this.displayMessage = this.displayMessage.substring(0, this.windowSize.x);
        }
        this.displayMessageTick = duration ? this.game.FPS * duration : this.DISPLAY_MESSAGE_TTL;
    } else {
        this.displayMessage = undefined;
        this.displayMessageTick = 0;
    }
};

/**
 * Renders a visual representation of this Board to a provided graphics
 * context.
 *
 * @param c A graphics context.
 */
Board.prototype.render = function (c) {

    var me = this,
        canvasWidth = this.game.context.canvas.width,
        canvasHeight = this.game.context.canvas.height,
        index,
        startX,
        startY,
        endX,
        endY;

    // Update our window
    this.updateWindowPosition();

    // Draw our border, if applicable
    if (this.windowOrigin.x < 0 || this.windowOrigin.y < 0) {
        c.fillStyle = Colors.Grey.rgbValue;
        c.fillRect(0, 0, canvasWidth, canvasHeight);
    }

    // Draw our board background
    c.fillStyle = !me.game.isEditor && me.dark ? this.game.DARK_PATTERN : Colors.Black.rgbValue;
    startX = Math.max(-this.windowOrigin.x * this.game.resources.graphics.TILE_SIZE.x, 0);
    startY = Math.max(-this.windowOrigin.y * this.game.resources.graphics.TILE_SIZE.y, 0);
    endX = Math.min(this.width * this.game.resources.graphics.TILE_SIZE.x, this.windowSize.x * this.game.resources.graphics.TILE_SIZE.x);
    endY = Math.min(this.height * this.game.resources.graphics.TILE_SIZE.y, this.windowSize.y * this.game.resources.graphics.TILE_SIZE.y);
    c.fillRect(startX, startY, endX, endY);

    // For each displayable tile...
    this.eachDisplayable(function (thing, point) {

        var sprite,
            background;

        // If this board is dark, and we're not visible, skip this iteration
        if (!me.game.isEditor && me.dark && !me.isLit(point, thing)) {
            return;
        }

        // If there's a thing to render...
        if (thing && !thing.hidden) {

            // Grab our sprite
            sprite = me.game.resources.graphics.getSprite(thing.getSpriteIndex());

            // Our background colour may come from the 'under' tile if no background is defined
            background = thing.background;

            if (!background && thing.under && thing.under.background) {

                background = thing.under.background.isLight() ? thing.under.background.darken() : thing.under.background;

            } else if (!background && me.dark) {

                // The room is dark, so our background should be
                // black instead of transparent
                background = Colors.Black;

            }

            // Draw our sprite
            sprite.draw(c, point.subtract(me.windowOrigin), thing.foreground, background);

        } else if (!thing && me.dark) {

            // There's nothing to render, but we're within the torch
            // radius, so draw an empty space over the 'darkness'
            me.game.resources.graphics.fillTile(c, point.subtract(me.windowOrigin), Colors.Black);

        }


        // Debug rendering...
        //
        /*
        var p = me.getSmartValue(point);
        if(p !== Infinity) {
            c.fillStyle = 'gray';
            var drawpoint = point.subtract(me.windowOrigin);
            c.fillText(me.getSmartValue(point).toString(), drawpoint.x * 32 + 8, drawpoint.y * 64 + 32);
        }
        */


    });

    // For each item in our custom render set
    for (index = 0; index < this.customRenderSet.length; index += 1) {
        this.customRenderSet[index].render(c);
    }

    // If there is a display message, render it
    if (this.displayMessage !== undefined) {
        this.renderMessage(c);
    }

};

/**
 * Sets a point on the "smart path" to be weighted differently, creating either an aversion
 * point or an attraction point.
 */
Board.prototype.adjustSmartPathWeight = function (point, strengthDelta) {

    var pathIndex = point.x + point.y * this.width;
    if (!this.isOutside(point) && this.smartPath[pathIndex] !== undefined) {
        this.smartPath[pathIndex] += strengthDelta;
    }

};

/**
 * Precomputes a "smart path" toward a provided target point. This will add path-finding information
 * that can be queried to find a most efficient path from any point on the grid toward this target.
 *
 * @param targetPoint A target point to which the smart path should be computed.
 */
Board.prototype.updateSmartPath = function (targetPoint) {

    var me = this;

    function updatePath(currentX, currentY, currentDistance) {

        var index,
            tile,
            pathValue,
            validTile;

        // If our values are within the grid range...
        if (currentDistance < 50 && currentX >= 0 && currentX < me.width && currentY >= 0 && currentY < me.height) {

            // Calculate our index
            index = currentX + currentY * me.width;

            // Get our tile and existing path value
            tile = me.tiles[index];
            validTile = (tile === undefined || (tile && tile.type === 'Bullet'));
            pathValue = me.smartPath[index];

            // If there is neither a tile, nor an existing value then we're good to go
            if (currentDistance <= 0 || (validTile && (pathValue === undefined || pathValue > currentDistance))) {

                // Assign our path distance at this point
                me.smartPath[currentX + currentY * me.width] = currentDistance;
                currentDistance += 1;

                // Do the same for each of the four surrounding directions
                updatePath(currentX + 1, currentY, currentDistance);
                updatePath(currentX - 1, currentY, currentDistance);
                updatePath(currentX, currentY + 1, currentDistance);
                updatePath(currentX, currentY - 1, currentDistance);

            }

        }

    }

    // Clear the old path
    this.smartPath = [];
    updatePath(targetPoint.x, targetPoint.y, 0);
    this.updatePathWeights();

};

Board.prototype.updatePathWeights = function () {

    this.each(function (tile) {
        if (tile && tile.influenceSmartPath) {
            tile.influenceSmartPath();
        }
    });

};

/**
 * Retrieves a precomputed weighted value indicating the number of steps toward a pre-specified target
 * in our smart path for a specified Point.
 *
 * @param point A Point for which to retrieve a smart value.
 * @return A weighted value indicating the number of steps toward a target.
 */
Board.prototype.getSmartValue = function (point) {

    var result;

    if (point.x >= this.width || point.x < 0 || point.y >= this.height || point.y < 0) {
        return Infinity;
    }

    result = this.smartPath[point.x + point.y * this.width];
    return result === undefined ? Infinity : result;

};

/**
 * Retrieves a direction toward the currently computed smart path target from a specified
 * Point.
 *
 * @param point A point from which to determine a direction toward our current smart target.
 * @return A Direction Point.
 */
Board.prototype.getSmartDirection = function (point) {

    var directions = [],
        me = this,
        currentMin = Infinity,
        value;

    // For each direction...
    Direction.each(function (direction) {

        // Get our smart path value
        value = me.getSmartValue(point.add(direction));

        // If it's the best one we've encountered...
        if (value < currentMin) {

            // Forget our previous directions
            directions = [];

            // Add this direction as our new favourite
            directions.push(direction);

            // Update our current minimum value
            currentMin = value;

        } else if (value === currentMin) {

            // Our value is the same, so add this direction too
            directions.push(direction);

        }

    });

    // If no good directions were found, return undefined
    if (currentMin === Infinity) {
        return undefined;
    }

    // If we only found one direction, return it immediately
    if (directions.length <= 1) {
        return directions[0];
    }

    // Otherwise pick one of our equal values randomly
    return Direction.random(directions);

};

Board.prototype.getMessage = function (key) {

    var result,
        language = i18n.getLanguage();

    result = this.getMessageForLanguage(language, key);

    // If no message was found and we haven't tried the default language...
    if (result === undefined && language !== i18n.DefaultLanguage) {
        result = this.getMessageForLanguage(i18n.DefaultLanguage, key);
    }

    return result !== undefined ? result : '??? ' + key + ' ???';

};

Board.prototype.getMessageForLanguage = function (language, key) {

    if (this.i18n && this.i18n.hasOwnProperty(language) && this.i18n[language].hasOwnProperty(key)) {
        return this.i18n[language][key];
    }

};

/**
 * Indicates to this board that the player has been hurt. This will display
 * a message on the screen and re-enter if applicable.
 */
Board.prototype.playerHurt = function () {

    this.setDisplayMessage(i18n.getMessage('status.hurt'));

    if (this.reenter) {
        this.moveTile(this.player.point, this.entryPoint);
    }

};

/**
 * Renders a visual message to a provided graphics context representing this Board's current
 * display message.
 *
 * @param c A graphics context.
 */
Board.prototype.renderMessage = function (c) {

    var messagePoint = new Point();

    messagePoint.x = Math.floor((this.windowSize.x - this.displayMessage.length) / 2);
    messagePoint.y = this.windowSize.y - 1;

    this.game.resources.graphics.drawString(c, messagePoint, this.displayMessage, Colors.Cycle, Colors.Black);

    this.displayMessageTick -= 1;

    if (this.displayMessageTick <= 0) {
        this.displayMessage = undefined;
    }

};

exports.Board = Board;

},{"./basic":1,"./graphics":5,"./i18n":6,"./jzt-script":10,"./things":13}],3:[function(_dereq_,module,exports){
/**
 * JZT Editor
 * Copyright Â© 2014 Orangeline Interactive, Inc.
 * @author Mark McIntyre
 */

/*jslint node: true */
/*global LZString */


'use strict';

var darkColors = ['0', '1', '2', '3', '4', '5', '6', '7'],
    allColorsNoBlack = ['9', 'A', 'B', 'C', 'D', 'E', 'F', '7', '1', '2', '3', '4', '5', '6', '8'],
    playerSprite,
    Point = _dereq_('./basic').Point,
    Graphics = _dereq_('./graphics').Graphics,
    i18n = _dereq_('./i18n').i18n,
    Colors = _dereq_('./graphics').Colors,
    things = _dereq_('./things').things,
    Direction = _dereq_('./basic').Direction,
    Board = _dereq_('./board').Board,
    serializeColor = _dereq_('./graphics').serialize,
    deserializeBackground = _dereq_('./graphics').deserializeBackground,
    deserializeForeground = _dereq_('./graphics').deserializeForeground,
    getColor = _dereq_('./graphics').getColor,
    ThingFactory = _dereq_('./things').ThingFactory;

/**
 * Editor represents a JZT game editor, capable of creating and testing JZT game worlds,
 * and providing definitions and UI elements to drive the editor.
 *
 * @param editorElement {object} - A DOM element representing the editor
 * @param configuration {object} - Configuration values.
 */
function Editor(editorElement, configuration) {

    var mockGame,
        me = this;

    this.formatVersion = '1.0.0';

    this.editorElement = editorElement;
    this.templateCustomizer = document.getElementById('template-customizer');

    this.addBoardCallback = configuration.addBoard;
    this.removeBoardCallback = configuration.removeBoard;
    this.changeBoardCallback = configuration.changeBoard;
    this.changeTemplateCallback = configuration.changeTemplate;
    this.changeModeCallback = configuration.changeMode;
    this.changeBoardOptionsCallback = configuration.changeBoardOptions;
    this.changeGameOptionsCallback = configuration.changeGameOptions;

    this.mode = Editor.Mode.DRAW;

    this.boards = [];
    this.cursor = new Point(0, 0);
    this.playerPosition = new Point(0, 0);

    /* We don't need a "real" game instance, since we're not actually
     * executing a playable instance, so we mock our game instead.
     */
    mockGame = {
        resources: {},
        isEditor: true,
        version: this.formatVersion,
        notifyListeners: function () {
            return;
        },
        context: {
            canvas: {
                width: 1,
                height: 1
            }
        }
    };

    this.game = mockGame;

    // Assign a Graphics instance to drive the rendering engine
    mockGame.resources.graphics = new Graphics(function () {
        me.newGame();
        playerSprite = me.graphics.getSprite(2);
    });

    // Let's keep a local copy for convenience, too.
    this.graphics = mockGame.resources.graphics;

    // The player isn't really an item on the board when editing, but rather just a concept of a position.
    this.playerPosition = new Point(0, 0);

    // Finally, we need to listen for keyboard presses
    window.addEventListener('keydown', this.onKeyDown.bind(this), false);

}

/**
 * Editor.Mode is an enumerated type representing a "mode" for drawing actions.
 */
Editor.Mode = {
    DRAW: 0,
    SELECT: 1,
    FILL: 2
};

/**
 * The Editor knows about several Things used by JZT, and defines their configurable properties.
 * This enumerated type structure defines these so that UI elements can be generated and used
 * to configure them.
 */
Editor.Thing = {

    Bear: {
        sensitivity: {type: 'number', min: 1, max: 10, defaultValue: 1, label: 'Sensitivity'}
    },

    Blinker: {
        direction: {type: 'direction', defaultValue: 'N', label: 'Direction'},
        period: {type: 'number', min: 1, max: 50, defaultValue: 3, label: 'Period'},
        delay: {type: 'number', min: 0, max: 50, defaultValue: 0, label: 'Delay'},
        color: {type: 'color', defaultValue: '*E', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    Bomb: {
        radius: {type: 'number', defaultValue: 4, min: 2, max: 20, label: 'Radius', advanced: true},
        color: {type: 'color', defaultValue: '*E', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    Boulder: {
        color: {type: 'color', defaultValue: '*E', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    BreakableWall: {
        color: {type: 'color', defaultValue: '0B', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    Centipede: {
        head: {type: 'boolean', defaultValue: false, label: 'Head'},
        deviance: {type: 'number', min: 0, max: 10, defaultValue: 0, label: 'Deviance'},
        intelligence: {type: 'number', min: 0, max: 10, defaultValue: 0, label: 'Intelligence'},
        color: {type: 'color', defaultValue: '*9', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    Conveyor: {
        color: {type: 'color', defaultValue: '*E', options: allColorsNoBlack, foreground: true, label: 'Color'},
        clockwise: {type: 'boolean', defaultValue: true, label: 'Clockwise'}
    },



    Door: {
        color: {type: 'color', defaultValue: '1F', options: ['1', '2', '3', '4', '5', '6', '7'], foreground: false, label: 'Color'}
    },

    Duplicator: {
        copyDirection: {type: 'direction', defaultValue: 'E', label: 'Clone Direction'},
        speed: {type: 'number', min: 1, max: 10, defaultValue: 5, label: 'Speed'}
    },

    FakeWall: {
        color: {type: 'color', defaultValue: '0E', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    Gem: {
        color: {type: 'color', defaultValue: '0D', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    InvisibleWall: {
        color: {type: 'color', defaultValue: '0A', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    Key: {
        color: {type: 'color', defaultValue: '*9', options: ['9', 'A', 'B', 'C', 'D', 'E', 'F'], foreground: true, label: 'Color'}
    },

    LineWall: {
        color: {type: 'color', defaultValue: '09', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    Lion: {
        intelligence: {type: 'number', min: 1, max: 10, defaultValue: 3, label: 'Intelligence'}
    },

    Passage: {
        color: {type: 'color', defaultValue: '1F', options: ['1', '2', '3', '4', '5', '6', '7'], foreground: false, label: 'Color'},
        passageId: {type: 'text', defaultValue: 'Door 1', label: 'ID'},
        targetBoard: {type: 'board', label: 'Target Board'}
    },

    Pusher: {
        speed: {type: 'number', defaultValue: 3, min: '1', max: '10', label: 'Speed', advanced: true},
        orientation: {type: 'direction', defaultValue: 'S', label: 'Direction'},
        color: {type: 'color', defaultValue: '*E', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    River: {
        direction: {type: 'direction', defaultValue: 'N', label: 'Direction'}
    },

    Ruffian: {
        intelligence: {type: 'number', defaultValue: 5, min: '1', max: '10', label: 'Intelligence'},
        restingTime: {type: 'number', defaultValue: 5, min: '1', max: '20', label: 'Resting time'}
    },

    Scriptable: {
        spriteIndex: {type: 'sprite', defaultValue: 1, label: 'Character'},
        color: {type: 'color', defaultValue: '*E', options: allColorsNoBlack, foreground: true, label: 'Color'},
        name: {type: 'text', defaultValue: 'Unknown', label: 'Name'},
        script: {type: 'script', label: 'Script'},
        speed: {type: 'number', min: 1, max: 10, defaultValue: 3, label: 'Speed'}
    },

    Signpost: {
        text: {type: 'text', label: 'Signpost Text'}
    },

    SliderEw: {
        color: {type: 'color', defaultValue: '*F', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    SliderNs: {
        color: {type: 'color', defaultValue: '*F', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    Snake: {
        speed: {type: 'number', defaultValue: 3, min: 1, max: 10, label: 'Speed'}
    },

    SolidWall: {
        color: {type: 'color', defaultValue: '0E', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    Spider: {
        intelligence: {type: 'number', defaultValue: 5, min: 1, max: 5, label: 'Intelligence'},
        color: {type: 'color', defaultValue: '*C', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    SpinningGun: {
        intelligence: {type: 'number', defaultValue: 5, min: 1, max: 5, label: 'Intelligence'},
        firingRate: {type: 'number', defaultValue: 5, min: 1, max: 10, label: 'Firing rate'},
        color: {type: 'color', defaultValue: '*E', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    Teleporter: {
        orientation: {type: 'direction', defaultValue: 'E', label: 'Direction'},
        color: {type: 'color', defaultValue: '*E', options: allColorsNoBlack, foreground: true, label: 'Color'}
    },

    Text: {
        color: {type: 'color', defaultValue: '0F', options: darkColors, foreground: false, label: 'Color'},
        text: {type: 'text', defaultValue: '', label: 'Text'}
    },

    Tiger: {
        intelligence: {type: 'number', min: 1, max: 10, defaultValue: 3, label: 'Intelligence'},
        firingRate: {type: 'number', min: 1, max: 20, defaultValue: 5, label: 'Firing rate'}
    },

    Wall: {
        color: {type: 'color', defaultValue: '0E', options: allColorsNoBlack, foreground: true, label: 'Color'}
    }

};

/**
 * Initializes this Editor's primary Board DOM element.
 *
 * @param board {object} - A DOM element to be initialized.
 */
Editor.prototype.initializeBoardElement = function (board) {

    // Remove the old canvas
    if (this.canvasElement) {
        this.editorElement.removeChild(this.canvasElement);
    }

    // Create a new canvas
    this.canvasElement = document.createElement('canvas');
    this.canvasElement.width = 800;
    this.canvasElement.height = 640;

    // Add our canvas
    this.editorElement.appendChild(this.canvasElement);

    // Add our event listeners
    this.canvasElement.addEventListener('mousemove', this.onCanvasMouseMoved.bind(this), false);
    this.canvasElement.addEventListener('mousedown', this.onCanvasMouseDown.bind(this), false);
    this.canvasElement.addEventListener('mouseup', this.onCanvasMouseUp.bind(this), false);
    this.canvasElement.addEventListener('mousewheel', this.onCanvasScroll.bind(this), false);

    // Assign our context
    this.context = this.canvasElement.getContext('2d');
    this.game.context = this.context;
    this.context.imageSmoothingEnabled = false;
    this.context.webkitImageSmoothingEnabled = false;
    this.context.mozImageSmoothingEnabled = false;

    // Assign our focus
    this.focusPoint = new Point(board.defaultPlayerX, board.defaultPlayerY);
    this.cursor = this.focusPoint;

};

/**
 * Sets this Editor's cursor position to a provided point, ensuring that the
 * position is within the restricted range, and that "drawing mode" being enabled
 * will contine to plot tiles.
 */
Editor.prototype.setCursorPosition = function (point) {

    this.cursor = point;

    if (this.cursor.x < 0) {
        this.cursor.x = 0;
    }
    if (this.cursor.y < 0) {
        this.cursor.y = 0;
    }
    if (this.cursor.x >= this.currentBoard.width) {
        this.cursor.x = this.currentBoard.width - 1;
    }
    if (this.cursor.y >= this.currentBoard.height) {
        this.cursor.y = this.currentBoard.height - 1;
    }

    // If drawing mode is enabled, plot a tile immediately.
    if (this.drawing) {
        this.plot();
    }

    this.render(this.context);

};

/**
 * Toggles the existence of a Thing at the current cursor position.
 */
Editor.prototype.togglePlot = function () {

    var thing = this.currentBoard.getTile(this.cursor);

    if (thing) {
        this.currentBoard.addThing(this.cursor, undefined);
        this.render(this.context);
    } else {
        this.plot();
    }

};

/**
 * Plots a Thing, based on this Editor's active template, at this Editor's
 * current cursor position.
 */
Editor.prototype.plot = function () {

    var thing,
        index,
        c;

    // No need to plot the same tile twice
    if (!this.previousPlot || !this.previousPlot.equals(this.cursor)) {

        this.previousPlot = this.cursor;

        // If there is a template available...
        if (this.activeTemplate) {

            // Which template have we got?

            if (this.activeTemplate.type === 'Player') {

                // It's a player

                this.currentBoard.defaultPlayerX = this.cursor.x;
                this.currentBoard.defaultPlayerY = this.cursor.y;
                this.playerPosition.x = this.currentBoard.defaultPlayerX;
                this.playerPosition.y = this.currentBoard.defaultPlayerY;

            } else if (this.activeTemplate.type === 'Text') {

                // It's Text

                if (this.activeTemplate.text) {

                    // Output a text character for each character in the string
                    for (index = 0; index < this.activeTemplate.text.length; index += 1) {

                        c = this.activeTemplate.text.charAt(index);
                        c = this.graphics.convertSpecialCharacter(c);

                        thing = this.currentBoard.getTile(this.cursor);

                        /* If there's already a Text thing in our position, set it's character
                         * depending on the active language, and change its color if necessary.
                         * Otherwise, we can go ahead and add a brand new Text Thing.
                         */
                        if (thing && thing.type === 'Text') {
                            thing.i18n[i18n.getLanguage()] = c;
                            thing.foreground = deserializeForeground(this.activeTemplate.color);
                            thing.background = deserializeBackground(this.activeTemplate.color);
                        } else {
                            thing = {type: 'Text', i18n: {}, color: this.activeTemplate.color};
                            thing.i18n[i18n.getLanguage()] = c;
                            this.currentBoard.addThing(this.cursor, things.ThingFactory.deserialize(thing, this.currentBoard));
                        }
                        this.cursor = this.cursor.add(Direction.East);
                    }


                    this.cursor = this.previousPlot;

                }

            } else {

                // It's something else

                this.currentBoard.addThing(this.cursor, ThingFactory.deserialize(this.activeTemplate, this.currentBoard));

            }


        } else {

            // No active template, means we should plot an empty space
            this.currentBoard.addThing(this.cursor, undefined);

        }

    }

    this.render(this.context);

};

/**
 * Creates a new game world.
 */
Editor.prototype.newGame = function () {
    this.deserialize({
        name: 'Untitled World',
        version: this.game.version,
        author: 'Anonymous',
        titleBoard: 'Untitled Board',
        startingBoard: 'Untitled Board',
        boards: [this.createBoard('Untitled Board', 50, 20)]
    });
};

/**
 * Moves this Editor's cursor in a given direction.
 */
Editor.prototype.moveCursor = function (direction) {

    var startX,
        endX;

    this.setCursorPosition(this.cursor.add(direction));

    if (this.currentBoard.isOutsideWindow(this.cursor)) {

        startX = this.currentBoard.windowOrigin.x;
        endX = startX + this.currentBoard.windowSize.x;

        if (this.cursor.x < startX || this.cursor.x >= endX) {
            this.focusPoint.x = this.cursor.x;
        } else {
            this.focusPoint.y = this.cursor.y;
        }

        this.render(this.context);

    }

};

/**
 * Sets this Editor's currently active board to a provided set of options.
 *
 * @param options {object} - A set of options to apply to the current board.
 */
Editor.prototype.setBoardOptions = function (options) {
    this.currentBoard.dark = options.dark;
    this.currentBoard.north = options.north !== '' ? options.north : undefined;
    this.currentBoard.south = options.south !== '' ? options.south : undefined;
    this.currentBoard.east = options.east !== '' ? options.east : undefined;
    this.currentBoard.west = options.west !== '' ? options.west : undefined;
    this.currentBoard.northOffset = options.northOffset !== '' ? options.northOffset : undefined;
    this.currentBoard.southOffset = options.southOffset !== '' ? options.southOffset : undefined;
    this.currentBoard.eastOffset = options.eastOffset !== '' ? options.eastOffset : undefined;
    this.currentBoard.westOffset = options.westOffset !== '' ? options.westOffset : undefined;
    this.currentBoard.reenter = options.reenter;
    this.currentBoard.maxPlayerBullets = options.maxPlayerBullets < 0 ? undefined : options.maxPlayerBullets;
    this.changeBoardOptionsCallback(options);
};

/**
 * Sets this Editor's current game world's options to a provided set.
 *
 * @param options {object} - A set of options to apply to this Editor's current game world.
 */
Editor.prototype.setGameOptions = function (options) {
    this.game.name = options.name;
    this.game.id = options.id;
    this.game.author = options.author;
    this.game.titleBoard = options.titleBoard;
    this.game.startingBoard = options.startingBoard;
    this.game.victoryBoard = options.victoryBoard;
    this.changeGameOptionsCallback(options);
};

/**
 * Generates a unique board name given a candidate name. This ensures that no
 * two boards have the same name when run through this generator.
 *
 * @param candidate {string} - A name to turn unique, if it's not already
 * @return {string} - A unique board name based on a given candidate
 */
Editor.prototype.getUniqueBoardName = function (candidate) {

    var index = 2,
        currentTry = candidate;

    while (this.getBoard(currentTry)) {
        currentTry = candidate + index;
        index += 1;
    }

    return currentTry;

};

/**
 * Generates a unique script name given a candidate name. This ensures that no two scripts
 * on this Editor's current board have the same name when run through this generator.
 *
 * @param candidate {string} - A name to turn unique, if it's not already
 * @return {string} - A unique script name based on a given candidate, for this Editor's current board.
 */
Editor.prototype.getUniqueScriptName = function (candidate) {

    var index = 2,
        currentTry = candidate;

    while (this.currentBoard.getScript(currentTry)) {
        currentTry = candidate + index;
        index += 1;
    }

    return currentTry;

};

/**
 * Retrieves a board from this Editor's current game world.
 *
 * @param boardName {string} - A name of a board to retrieve
 * @return {object} - A game board with a provided name.
 */
Editor.prototype.getBoard = function (boardName) {
    var index;

    for (index = 0; index < this.boards.length; index += 1) {
        if (this.boards[index].name === boardName) {
            return this.boards[index];
        }
    }

    return undefined;
};

/**
 * Switches this Editor's current board to a board with a provided name.
 *
 * @param boardName {string} - A name of a board to switch to
 */
Editor.prototype.switchBoard = function (boardName) {

    var board = this.getBoard(boardName),
        boardOptions;

    this.currentBoard = board;

    this.playerPosition.x = board.defaultPlayerX;
    this.playerPosition.y = board.defaultPlayerY;

    this.initializeBoardElement(board);

    this.currentBoard.initializeWindow();
    this.render(this.context);

    this.changeBoardCallback(boardName);
    boardOptions = {
        north: board.north,
        east: board.east,
        south: board.south,
        west: board.west,
        northOffset: board.northOffset,
        eastOffset: board.eastOffset,
        southOffset: board.southOffset,
        westOffset: board.westOffset,
        dark: board.dark,
        reenter: board.reenter
    };
    this.changeBoardOptionsCallback(boardOptions);

};

Editor.prototype.deserialize = function (data) {

    var index,
        board,
        options = {};

    if (!data.version || data.version !== this.formatVersion) {
        throw 'Incompatible version';
    }

    for (index = 0; index < this.boards.length; index += 1) {
        this.removeBoardCallback(this.boards[index].name);
    }



    this.boards = [];

    for (index = 0; index < data.boards.length; index += 1) {
        board = new Board(data.boards[index], this.game);
        this.boards.push(board);
        this.addBoardCallback(board.name);
    }


    options.name = data.name;
    options.id = data.id;
    options.author = data.author;
    options.titleBoard = data.titleBoard;
    options.startingBoard = data.startingBoard;
    options.victoryBoard = data.victoryBoard;

    this.setGameOptions(options);

    this.switchBoard(data.startingBoard);

};

Editor.prototype.serialize = function (playTest) {
    var result = {},
        index;
    result.name = this.game.name;
    result.version = this.game.version;
    result.id = this.game.id;
    result.titleBoard = this.game.titleBoard;
    result.startingBoard = playTest ? this.currentBoard.name : this.game.startingBoard;
    result.victoryBoard = this.game.victoryBoard;
    result.savedGame = true;
    result.author = this.game.author;
    result.boards = [];
    for (index = 0; index < this.boards.length; index += 1) {
        result.boards.push(this.boards[index].serialize());
    }
    return result;
};

Editor.prototype.setMode = function (mode) {
    this.mode = mode;
    this.changeModeCallback(mode);
};

Editor.prototype.removeBoard = function (boardName) {
    var index,
        found = -1;
    for (index = 0; index < this.boards.length; index += 1) {
        if (this.boards[index].name === boardName) {
            found = index;
            break;
        }
    }
    if (found >= 0) {
        this.boards.splice(found, 1);
        this.removeBoardCallback(boardName);

        if (this.boards.length > 0) {
            this.switchBoard(this.boards[0].name);
        }
    }

};

Editor.prototype.createBoard = function (boardName, width, height) {

    var template = {
            name: boardName,
            playerX: Math.floor(width / 2),
            playerY: Math.floor(height / 2),
            height: height,
            width: width,
            tiles: [],
            scripts: []
        },
        row,
        column;

    for (row = 0; row < height; row += 1) {
        for (column = 0; column < width; column += 1) {

            switch (row) {
            case 0:
            case height - 1:
                template.tiles[column + row * width] = {type: 'Wall'};
                break;
            default:
                if (column === 0 || column === width - 1) {
                    template.tiles[column + row * width] = {type: 'Wall'};
                } else {
                    template.tiles[column + row * width] = {};
                }
            }
        }
    }

    return template;

};

Editor.prototype.addBoard = function (boardName, width, height) {

    var newBoard,
        template = this.createBoard(boardName, width, height);

    newBoard = new Board(template, this.game);
    this.playerPosition.x = newBoard.defaultPlayerX;
    this.playerPosition.y = newBoard.defaultPlayerY;

    this.boards.push(newBoard);

    if (this.addBoardCallback) {
        this.addBoardCallback(newBoard.name);
    }

    this.switchBoard(newBoard.name);

};

Editor.prototype.getTemplateThing = function (template) {

    var thing;

    if (template && template.type) {

        for (thing in Editor.Thing) {
            if (Editor.Thing.hasOwnProperty(thing)) {

                if (thing === template.type) {
                    return Editor.Thing[thing];
                }

            }
        }

    }

};

Editor.prototype.createField = function (fieldName, field, template) {

    var label,
        element,
        me = this,
        index,
        sprite,
        elementTemplate,
        innerElement,
        color,
        nonStandard = false;

    function getFriendlyName(name) {
        switch (name) {
        case 'BrightBlue':
            return 'Bright Blue';
        case 'BrightGreen':
            return 'Bright Green';
        case 'BrightCyan':
            return 'Bright Cyan';
        case 'BrightRed':
            return 'Bright Red';
        case 'BrightMagenta':
            return 'Bright Magenta';
        case 'BrightWhite':
            return 'Bright White';
        case undefined:
            return 'Transparent';
        default:
            return name;
        }
    }

    function initializeSpritePosition(domElement) {

        var row, column, spriteIndex;

        spriteIndex = domElement.getAttribute('data-sprite-index');

        column = spriteIndex % 16;
        row = Math.floor(spriteIndex / 16);

        domElement.style.backgroundPosition = (column * -16) + 'px ' + (row * -32) + 'px';


    }

    function onSpriteClick(event) {
        var spriteIndex = event.target.getAttribute('data-sprite-index'),
            spriteFieldName = event.target.getAttribute('data-field-name'),
            mainElement = document.querySelector('.' + spriteFieldName + '-spritepicker'),
            spriteDisplay = mainElement.querySelector('button .sprite');

        template[spriteFieldName] = spriteIndex;
        spriteDisplay.setAttribute('data-sprite-index', spriteIndex);
        initializeSpritePosition(spriteDisplay);
        me.changeTemplateCallback(template);

    }

    label = document.createElement('label');
    label.innerHTML = field.label;

    if (field.type === 'number') {

        // Our field type is a number, so create a number input
        element = document.createElement('input');
        element.type = 'number';
        element.min = field.min;
        element.max = field.max;

    } else if (field.type === 'direction') {

        // Our field type is a direction, so create a direction selector
        element = document.createElement('select');
        element.options[element.options.length] = new Option('North', 'N');
        element.options[element.options.length] = new Option('East', 'E');
        element.options[element.options.length] = new Option('South', 'S');
        element.options[element.options.length] = new Option('West', 'W');

    } else if (field.type === 'boolean') {

        // Our field type is a boolean, so create a sliding toggle

        // Establish our template (based on Foundation framework's toggle markup)
        elementTemplate = '<input id="{{fieldId}}" type="checkbox"><label for="{{fieldId}}"></label>';
        elementTemplate = elementTemplate.replace(/\{\{fieldId\}\}/g, fieldName + '-checkbox');

        element = document.createElement('div');
        element.innerHTML = elementTemplate;
        element.classList.add('switch');
        nonStandard = true;
        innerElement = element.querySelector('#' + fieldName + '-checkbox');

        // Add an event listner to our checkbox...
        innerElement.addEventListener('click', function () {
            template[fieldName] = innerElement.checked;
            me.changeTemplateCallback(me.activeTemplate);
        }, false);

        // Set our default value for the element...
        if (template.hasOwnProperty(fieldName)) {
            innerElement.checked = template[fieldName];
        } else if (field.defaultValue) {
            innerElement.checked = field.defaultValue;
        }

    } else if (field.type === 'sprite') {

        // Our field type is a sprite

        // This is a non-standard form element, naturally
        nonStandard = true;

        elementTemplate = '<button class="large secondary button dropdown expand spritepicker" data-dropdown="{{fieldId}}" data-options="align: right"><div class="sprite"></div></button><div id="{{fieldId}}" data-dropdown-content class="f-dropdown medium content"><div class="sprites" /></div><input type="hidden">';
        elementTemplate = elementTemplate.replace(/\{\{fieldId\}\}/g, fieldName + '-spritepicker');

        element = document.createElement('div');
        element.className = fieldName + '-spritepicker';
        element.innerHTML = elementTemplate;

        innerElement = element.querySelector('.sprite');
        innerElement.style.margin = '0 0 0 1em';

        if (template.hasOwnProperty(fieldName)) {
            innerElement.setAttribute('data-sprite-index', template[fieldName]);
            initializeSpritePosition(innerElement);
        } else if (field.defaultValue) {
            innerElement.setAttribute('data-sprite-index', field.defaultValue);
            initializeSpritePosition(innerElement);
        }

        innerElement = element.querySelector('.sprites');

        for (index = 0; index < 256; index += 1) {

            sprite = document.createElement('div');
            sprite.className = 'sprite';
            sprite.setAttribute('data-sprite-index', index);
            sprite.setAttribute('data-field-name', fieldName);
            sprite.addEventListener('click', onSpriteClick, false);
            initializeSpritePosition(sprite);
            innerElement.appendChild(sprite);

        }

    } else if (field.type === 'color') {

        // Our field type is a color...
        element = document.createElement('select');
        for (index = 0; index < field.options.length; index += 1) {
            element.options[element.options.length] = new Option(getFriendlyName(getColor(field.options[index]).name), field.options[index]);
        }
        nonStandard = true;
        element.addEventListener('change', function () {
            var oldValue = template[fieldName],
                background,
                foreground;

            oldValue = oldValue || field.defaultValue ? field.defaultValue : '**';
            background = deserializeBackground(oldValue);
            foreground = deserializeForeground(oldValue);

            if (field.foreground) {
                template[fieldName] = serializeColor(background, getColor(element.value));
            } else {
                template[fieldName] = serializeColor(getColor(element.value), foreground);
            }

            me.changeTemplateCallback(me.activeTemplate);

        }, false);
        if (template.hasOwnProperty(fieldName)) {
            if (field.foreground) {
                color = deserializeForeground(template[fieldName]);
                element.value = color ? color.code : Colors.Yellow;
            } else {
                color = deserializeBackground(template[fieldName]);
                element.value = color ? color.code : Colors.Blue;
            }
        } else if (field.defaultValue) {
            if (field.foreground) {
                color = deserializeForeground(field.defaultValue);
                element.value = color ? color.code : Colors.Yellow;
            } else {
                color = deserializeBackground(field.defaultValue);
                element.value = color ? color.code : Colors.Blue;
            }
        }

    } else {

        // Our field type is anything else...
        element = document.createElement('input');
        element.type = 'text';

    }

    // If our element is available and it's standard behaviour...
    if (!nonStandard && element) {

        element.addEventListener('change', function () {
            template[fieldName] = element.value;
            me.changeTemplateCallback(me.activeTemplate);
        }, false);

        if (template.hasOwnProperty(fieldName)) {
            element.value = template[fieldName];
        } else if (field.defaultValue) {
            element.value = field.defaultValue;
        }

    }

    label.appendChild(element);

    if (field.advanced) {
        label.classList.add('advanced');
    }

    return label;


};

Editor.prototype.setActiveTemplate = function (template) {

    var thing,
        field;

    this.activeTemplate = template;
    this.templateCustomizer.innerHTML = '';

    thing = this.getTemplateThing(template);
    if (thing) {

        for (field in thing) {
            if (thing.hasOwnProperty(field)) {
                this.templateCustomizer.appendChild(this.createField(field, thing[field], template));
            }
        }

    }


    this.changeTemplateCallback(this.activeTemplate);
};

Editor.prototype.setTemplateForeground = function (foreground) {
    var background;
    if (!this.activeTemplate) {
        return;
    }
    if (this.activeTemplate.color) {
        background = deserializeBackground(this.activeTemplate.color);
        this.activeTemplate.color = serializeColor(background, foreground);
    } else {
        this.activeTemplate.color = serializeColor(Colors.Black, foreground);
    }
    this.changeTemplateCallback(this.activeTemplate);
};

Editor.prototype.setTemplateBackground = function (background) {
    var foreground;
    if (!this.activeTemplate) {
        return;
    }
    if (this.activeTemplate.color) {
        foreground = deserializeForeground(this.activeTemplate.color);
        this.activeTemplate.color = serializeColor(background, foreground);
    } else {
        this.activeTemplate.color = serializeColor(background, Colors.Yellow);
    }
    this.changeTemplateCallback(this.activeTemplate);
};

Editor.prototype.eventToBoardPoint = function (event) {

    var scaleX = this.canvasElement.width / this.canvasElement.offsetWidth,
        scaleY = this.canvasElement.height / this.canvasElement.offsetHeight,
        x = Math.floor((event.offsetX * scaleX) / this.game.resources.graphics.TILE_SIZE.x),
        y = Math.floor((event.offsetY * scaleY) / this.game.resources.graphics.TILE_SIZE.y);
    return new Point(x, y).add(this.currentBoard.windowOrigin);
};

Editor.prototype.onKeyDown = function (event) {

    var oldMode,
        activeElement = document.activeElement ? document.activeElement.tagName.toLowerCase() : '';

    if (activeElement !== 'input' && activeElement !== 'textarea' && activeElement !== 'select' && activeElement !== 'button') {

        if (event.keyCode === 37) {
            this.moveCursor(Direction.West);
            event.preventDefault();
        } else if (event.keyCode === 38) {
            this.moveCursor(Direction.North);
            event.preventDefault();
        } else if (event.keyCode === 39) {
            this.moveCursor(Direction.East);
            event.preventDefault();
        } else if (event.keyCode === 40) {
            this.moveCursor(Direction.South);
            event.preventDefault();
        } else if (event.keyCode === 83) {
            this.setMode(Editor.Mode.SELECT);
            event.preventDefault();
        } else if (event.keyCode === 68) {
            this.setMode(Editor.Mode.DRAW);
            event.preventDefault();
        } else if (event.keyCode === 70) {
            this.setMode(Editor.Mode.FILL);
            event.preventDefault();
        } else if (event.keyCode === 32) {

            if (this.mode === Editor.Mode.DRAW) {
                this.togglePlot();
            } else {
                this.invokeTool();
            }
            event.preventDefault();

        } else if (event.keyCode === 13) {
            oldMode = this.mode;
            this.mode = Editor.Mode.SELECT;
            this.invokeTool();
            this.mode = oldMode;
            event.preventDefault();
        } else if (event.keyCode === 88) {
            oldMode = this.mode;
            this.mode = Editor.Mode.FILL;
            this.invokeTool();
            this.mode = oldMode;
            event.preventDefault();
        } else if (event.keyCode === 9) {

            this.drawing = !this.drawing;
            this.plot();
            event.preventDefault();
        }

    }

};

Editor.prototype.invokeTool = function () {

    var thing;

    if (this.mode === Editor.Mode.SELECT) {

        thing = this.currentBoard.getTile(this.cursor);
        if (thing) {
            this.setActiveTemplate(thing.serialize());
        } else {
            this.setActiveTemplate(undefined);
        }

    } else if (this.mode === Editor.Mode.FILL) {

        this.fill(this.cursor);

    }

    this.render(this.context);

};

Editor.prototype.onCanvasMouseDown = function (event) {

    if (this.mode === Editor.Mode.DRAW) {
        this.drawing = true;
        this.previousPlot = new Point(-1, -1);
    }

    this.setCursorPosition(this.eventToBoardPoint(event));

};

Editor.prototype.onCanvasMouseMoved = function (event) {

    this.setCursorPosition(this.eventToBoardPoint(event));
    document.activeElement.blur();

};

Editor.prototype.onCanvasMouseUp = function (event) {

    this.drawing = false;

    this.setCursorPosition(this.eventToBoardPoint(event));
    this.invokeTool();

};

Editor.prototype.onCanvasScroll = function (event) {

    var deltaX = Math.round(event.deltaX / 10),
        deltaY = Math.round(event.deltaY / 10);
    deltaX = deltaX > 2 ? 2 : deltaX < -2 ? -2 : deltaX;
    deltaY = deltaY > 2 ? 2 : deltaY < -2 ? -2 : deltaY;

    this.focusPoint = this.focusPoint.add(new Point(deltaX, deltaY));
    event.preventDefault();
    this.render(this.context);

};

Editor.prototype.fill = function (point) {

    var thing,
        targetDetails,
        me = this;

    function getDetails(thing) {

        var type,
            color;

        if (thing && thing.constructor && thing.constructor.type) {
            type = thing.constructor.type;
        }

        if (thing) {
            color = serializeColor(thing.foreground, thing.background);
        }

        return String(type) + String(color);

    }

    function fillNeighbour(point, targetDetails) {

        var details = getDetails(me.currentBoard.getTile(point));
        if (details === targetDetails) {
            me.fill(point);
        }

    }

    if (this.currentBoard.isOutside(point)) {
        return;
    }

    thing = this.currentBoard.getTile(point);
    targetDetails = getDetails(thing);

    // Don't fill if we're already the correct type
    if (getDetails(things.ThingFactory.deserialize(this.activeTemplate, this.currentBoard)) === targetDetails) {
        return;
    }

    // If we have an active template, add our thing
    if (this.activeTemplate) {
        this.currentBoard.addThing(point, things.ThingFactory.deserialize(this.activeTemplate, this.currentBoard));
    } else {
        this.currentBoard.addThing(point, undefined);
    }

    fillNeighbour(point.add(Direction.North), targetDetails);
    fillNeighbour(point.add(Direction.East), targetDetails);
    fillNeighbour(point.add(Direction.South), targetDetails);
    fillNeighbour(point.add(Direction.West), targetDetails);

};

Editor.prototype.render = function (context) {

    // If we aren't fully loaded, don't render anything yet
    if (!this.currentBoard || !playerSprite) {
        return;
    }

    this.currentBoard.focusPoint = this.focusPoint;
    this.currentBoard.render(context);
    playerSprite.draw(context, this.playerPosition.subtract(this.currentBoard.windowOrigin), Colors.BrightWhite, Colors.Blue);
    this.drawCursor(context);
};

Editor.prototype.drawCursor = function (context) {

    var xSize = this.graphics.TILE_SIZE.x,
        ySize = this.graphics.TILE_SIZE.y,
        xPos = this.cursor.subtract(this.currentBoard.windowOrigin).x * this.graphics.TILE_SIZE.x,
        yPos = this.cursor.subtract(this.currentBoard.windowOrigin).y * this.graphics.TILE_SIZE.y;

    context.fillStyle = 'rgba(222, 222, 255, 0.25)';
    context.strokeStyle = '#DDDDFF';
    context.lineWidth = this.drawing ? 4 : 2;

    context.fillRect(xPos, yPos,  xSize, ySize);

    // If we're in drawing mode
    if (this.mode === Editor.Mode.DRAW) {
        context.strokeRect(xPos, yPos, xSize, ySize);
    } else if (this.mode === Editor.Mode.SELECT) {
        context.beginPath();
        context.moveTo(xPos + (xSize / 2), yPos);
        context.lineTo(xPos + (xSize / 2), yPos + ySize);
        context.moveTo(xPos, yPos + (ySize / 2));
        context.lineTo(xPos + xSize, yPos + (ySize / 2));
        context.stroke();
    }

    context.font = '9pt Arial';
    context.fillStyle = 'black';
    context.fillText('(' + (this.cursor.x + 1) + ', ' + (this.cursor.y + 1) + ')', 5, 15);
    context.fillStyle = 'white';
    context.fillText('(' + (this.cursor.x + 1) + ', ' + (this.cursor.y + 1) + ')', 4, 14);

};

exports.Editor = Editor;

},{"./basic":1,"./board":2,"./graphics":5,"./i18n":6,"./things":13}],4:[function(_dereq_,module,exports){
/**
 * JZTScript
 * Copyright Â© 2014 Orangeline Interactive, Inc.
 * @author Mark McIntyre
 */

/*jslint node:true */

'use strict';

/**
 * GameState is an enumerated type representing a state in our game's finite state
 * machine.
 */
var GameState = {
    Error: -2,
    Splash: -1,
    Loading: 0,
    Playing: 1,
    Paused: 2,
    GameOver: 3,
    Reading: 4,
    Title: 5,
    Victory: 6,
    FileManagement: 7
};

exports.GameState = GameState;

},{}],5:[function(_dereq_,module,exports){
/**
 * JZT Graphics and Color
 * Copyright Â© 2014 Orangeline Interactive, Inc.
 * @author Mark McIntyre
 */

/*jslint node:true */

'use strict';

var ConstructorError = _dereq_('./basic').ConstructorError,
    Point = _dereq_('./basic').Point,
    colors,
    cycle,
    BLINK_RATE = 10,
    SPRITE_DATA = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAAEAAQMAAABBN+zkAAAABlBMVEUAAAD///+l2Z/dAAAGBElEQVRYw8WXv4skRRTHC4WOmr01e7jLbWJwYaEwV0ixC+K/YGJU3El5QSEbtQMWfWdy/4OJmYn/g9DMycOguHAZmHHZaDeRY0DYm2Cp9vuqZ2Z/eHqnrlrT86M/87rej3r9XrVSq9HjdW1cgrZdg7v24DF+fY1/iARs+Q8eklLfzcK2tQLe9QePSSSysa3q7bP3vX44KyCe9XTmvxkDWKV+eJbzGf7/6Idk9cMzpb45g0RbABWJr/toiOSS1B5+XuYw26LWPku0OCMxbFsNasd0cko3TO9e5csbg8148hY+4hXQVeQfMwKwVniyZf3MwZI1WNxt/czAvAK2s1ruk58FuYS0umeyypn8V2WO2nXBxCKxU0DOXY6xzLETcjtIRCNa1I7JllrS+V42xY6dOhNZ0ZK3xVLMIZdctT+qfzzo+qkXoK/87aHE6HqDrA+sgr60w74XJpPgdF3OEFCrcsdG6dqLTCUqQqwbgBLEuoCK5gB9q7IoFKDTWqLoyk9dKnOAuCLBnCQz8ZO6YdKnjRLDAJ5c80X/gXP/fBiKsc5GFnGIfzDMu51jZnHVseJxVdmuq5ixukoDUF2FFcD61uoIq5ouLurYiqU1AegqV0xciasV4RJX1RVrAbqtBXQrIJkJrwIx1wxQFy2kTJvj3Rh1HCsNO27d8T8a2xd2mbNle/d0wRxVNN4H7z289u7FKdwPfuIfPJgUkM8B2Hf+0aMOILicWR1z7Px43GWqx+7oGCAXiWMWwM9FAsAhyJRCCfWcZdIC/AMBHYta5wV4AZHFsMWHbMenWQz7F1z/XXIodREvYgv97LNVNuB+Ys8DYP2k5gF8ivPgn+pO7hkAh9Xk6Gt9IiAyaiPzkbGkDwU4DnUBpLUZgK8ERHJ6t4AjeM4hB5rorQKOBZgX+NCVgEU8jTZuB7bZvlWKSn3T/K0bRfP1Q78WkDpRuwjMCVUnZkAOmgMytFonqYDP5B5fgfEYlrommC1Pv8yxcnXgwIvUUBUoe8Qw+i5llzxVYzoSkAC6V4OwBpy4AD+AJsYmIiq2OrXsN/lRSwm8OtJNMJYKdwt5s0WHzbWo4dae3wQQnjfzeJEkqbMAo3xqWAMETodYtADgHcCRkQqDYgHgzAD0BtQDcBvAo2RzKFUJRTgiFrsNBW4zDJNVWedHtfregHrTCVc/lm9aPOXibeUMvHKKkNbKJjJJBwVLvdXinMIZGXhFyhNCNVl1mdUUaI0pjjF8jNEYEwIA1xhSGOCLFIOE+hwjiksewCR1CcN3XVeaMNwvwA4AEjaxgHozR93EBqPCPNZagOqaHX+v99Ir7heEQjsURfi83EJY9hGKMdqGouDTDmTgISVCVbCf+SRLlYZrUVKcXSJKKcHIlGC6W9CPpFyDgscDcG1qVRylS0DHkGg3wOM3wHQDrBNt/hLQqYD8xXNoaZo2RrogvvRkFZepUtfT4/DqDfNno7kaILQzNbeSKF3Z4mmUvAYh0AJEKYLl5lzAZLKx4nTflIgUdSam+XmJbUo0mqLDcvK5jbqkA8IZBRxjrq7SmqYjlQQ8FxWV8xYSBWA27qr5c4s5roCn30oONDY2pRTB4f0b60rVDRf3qzfLj3c++RkWjpQajXBg1o+///I6+LsSy5Fano/y+Wh5KUHVqKrWEsvleYbEec7L5VpihGNU0nal5RL8NxJlryNElddtgr3R/YOX/f3+Zb+R0HpVeff6Xo77B/i7SJQnIgnZqERV/V9ADpK3PJ8t7vS3A3Ds7eHrmgRdkej7/mBv76DvlwjL4o7YNZK3BPP/Ba8f47xuPuhWu9LPWQlqDUrI2zoKwB7US+sjVWED36QuuNbPUfTrtgWYT7ugp57Qgvdns8hqCgkSkIOfzSAx5bUEwK8r4KaRLMAwBwBPnZQfjxo2aMmHjlrzwqpul9fPn7f+QFcAquOd6boib8nzg+yqhpqt6501kOyXGrlT9hkALpaiLLsIKdN1+ElAi60bynQByyiXiEQrmn4Z+qLsQ6ao7PB31Sh1TdOyvRmALAHAqqOKRI8n6sHC3T915S+A3wBO89vlg2hdWgAAAABJRU5ErkJggg==';

/**
 * Sprite represents a subsection of a larger graphic that can be drawn independetly
 * at a location.
 *
 * @param point A point defining the top-left sprite origin
 * @param owner A Graphics instance to which this Sprite belongs
 */
function Sprite(point, owner) {

    if (!(this instanceof Sprite)) {
        throw ConstructorError;
    }

    this.point = point;
    this.owner = owner;
}

/**
 * Draws this Sprite instance on a provided context at a provided Point using a given
 * foreground and background color.
 *
 * @param context A 2D graphics context
 * @param point A Point
 * @param foreground A foreground color.
 * @param background A background color.
 */
Sprite.prototype.draw = function (context, point, foreground, background) {

    var blink,
        destinationX,
        destinationY;

    /*
     * Back in the DOS days, a bright background would actually signal
     * that the foreground color should blink. We're doing the same.
     */
    if (background && background.isLight()) {
        blink = true;
        background = background.darken();
    }

    destinationX = point.x * this.owner.TILE_SIZE.x;
    destinationY = point.y * this.owner.TILE_SIZE.y;

    // Draw the background
    if (background) {
        context.fillStyle = background.rgbValue;
        context.fillRect(destinationX, destinationY, this.owner.TILE_SIZE.x, this.owner.TILE_SIZE.y);
    }

    // If we aren't blinking, or if the blink state is off, draw our sprite
    if (!blink || !this.owner.blinkState) {

        context.drawImage(this.owner.colorSpriteSources[foreground.index], this.point.x, this.point.y, this.owner.SPRITE_SIZE.x, this.owner.SPRITE_SIZE.y,
            destinationX, destinationY, this.owner.TILE_SIZE.x, this.owner.TILE_SIZE.y);

    }

};


/**
 * Graphics provides functions for drawing standard DOS CodePage 437 characters in the usual 16 colour
 * pallette to a graphics context. An optional callback can be provided that will signal when all graphics
 * have been loaded and initialized.
 *
 * @param onLoadCallback An optional callback function to be triggered when this Graphics is loaded and ready to use.
 */
function Graphics(onLoadCallback) {

    if (!(this instanceof Graphics)) {
        throw ConstructorError;
    }

    var me = this;

    this.TILE_SIZE = new Point(16, 32);
    this.SPRITE_SIZE = new Point(8, 16);

    this.DARK_IMAGE = undefined;
    this.NOISE_IMAGE = undefined;

    this.blinkCycle = 0;
    this.blinkState = true;

    this.sprites = [];
    this.spriteSource = new Image();
    this.spriteSource.src = SPRITE_DATA;
    this.colorSpriteSources = [];
    this.onLoadCallback = onLoadCallback;

    // A function to finish initialization once our sprite source has been fully loaded
    this.spriteSource.onload = function () {

        var buffer,
            context,
            pixelCount,
            color,
            imageData,
            rgba,
            pixel,
            tilesPerRow,
            tilesPerColumn,
            row,
            column,
            spritePoint,
            sprite;

        // Create offscreen canvases
        for (color in colors) {
            if (colors.hasOwnProperty(color)) {

                // Create a buffer to store our sprite graphics
                buffer = document.createElement('canvas');
                buffer.width = this.width;
                buffer.height = this.height;

                // We will create a version of our sprite for each foreground color
                me.colorSpriteSources[color] = buffer;

                // Grab our 2D context
                context = buffer.getContext('2d');

                // Each pixel has an ARGB value
                pixelCount = this.width * this.height * 4;

                // Get our color
                color = colors[color];

                // Draw the black and white image first
                context.drawImage(this, 0, 0);

                // Grab the raw image data
                imageData = context.getImageData(0, 0, this.width, this.height);
                rgba = imageData.data;

                // For each of our pixels...
                for (pixel = 0; pixel < pixelCount; pixel += 4) {

                    /* For a black and white image, we only need to test one of the
                     * values to determine if we need to write a color or a transparent
                     * value.
                     */

                    // If we found an 'on' pixel
                    if (rgba[pixel] >= 255) {

                        // Assign our new pixel color
                        rgba[pixel] = color.r;
                        rgba[pixel + 1] = color.g;
                        rgba[pixel + 2] = color.b;

                        // Make it completely opaque
                        rgba[pixel + 3] = 255;

                    } else {

                        // Make our pixel completely transparent
                        rgba[pixel + 3] = 0;

                    }

                }

                // Write our image data at the same location as it was read from
                context.putImageData(imageData, 0, 0);

            }

        }

        // Create our sprites
        tilesPerRow = this.width / me.SPRITE_SIZE.x;
        tilesPerColumn = this.height / me.SPRITE_SIZE.y;

        for (row = 0; row < tilesPerColumn; row += 1) {
            for (column = 0; column < tilesPerRow; column += 1) {

                spritePoint = new Point(column * me.SPRITE_SIZE.x, row * me.SPRITE_SIZE.y);
                sprite = new Sprite(spritePoint, me);
                me.sprites.push(sprite);

            }
        }

        // Create our noise image
        buffer = document.createElement('canvas');
        buffer.width = 256;
        buffer.height = 256;
        pixelCount = 256 * 256 * 4;
        context = buffer.getContext('2d');
        imageData = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
        rgba = imageData.data;
        for (pixel = 0; pixel < pixelCount; pixel += 4) {
            rgba[pixel] = 0;
            rgba[pixel + 1] = 0;
            rgba[pixel + 2] = 0;
            rgba[pixel + 3] = Math.round(20 * Math.random());
        }
        context.putImageData(imageData, 0, 0);
        me.NOISE_IMAGE = buffer;

        // Create our darkness image
        buffer = document.createElement('canvas');
        buffer.width = me.TILE_SIZE.x;
        buffer.height = me.TILE_SIZE.y;
        context = buffer.getContext('2d');
        context.imageSmoothingEnabled = false;
        context.webkitImageSmoothingEnabled = false;
        context.mozImageSmoothingEnabled = false;
        sprite = me.getSprite(176);
        sprite.draw(context, new Point(0, 0), exports.Colors.Grey, exports.Colors.Black);
        me.DARK_IMAGE = buffer;

        // Now that everything is initialized, trigger our load callback
        me.onLoadCallback();

    };

}

/**
 * Updates this Graphics's instance's blinking and color cycle state.
 */
Graphics.prototype.update = function () {

    // Increment our blink cycle counter
    this.blinkCycle += 1;

    // If we've passed the blink rate threshold...
    if (this.blinkCycle > BLINK_RATE) {

        // Adjust our blink state
        this.blinkState = !this.blinkState;

        // Our color cycle uses the same rate
        exports.Colors.Cycle.update();

        // Reset the blink cycle
        this.blinkCycle = 0;
    }

};

Graphics.prototype.fillTile = function (c, point, color) {

    var destinationX = point.x * this.TILE_SIZE.x,
        destinationY = point.y * this.TILE_SIZE.y;

    // Draw the tile
    if (color) {
        c.fillStyle = color.rgbValue;
        c.fillRect(destinationX, destinationY, this.TILE_SIZE.x, this.TILE_SIZE.y);
    }

};

/**
 * Gets a Sprite instance for a provided CodePage-437 character index.
 *
 * @param index A CodePage-437 character index
 * @return A sprite representing a provided CodePage-437 index.
 */
Graphics.prototype.getSprite = function (index) {
    return this.sprites[index];
};

/**
 * Converts a provided text string into an array of Sprite instances representing
 * CodePage-437 characters. Any text character that does not have an equivalent
 * CodePage-437 representation will be represented by a '?' character.
 *
 * @param text A text string to convert to Sprite instances
 * @return An array of Sprite instances
 */
Graphics.prototype.textToSprites = function (text) {

    var result = [],
        index,
        spriteIndex;

    // For each character in our string...
    for (index = 0; index < text.length; index += 1) {

        // Convert the character into its CodePage-437 index
        spriteIndex = this.convertSpecialCharacter(text.charAt(index));

        // Push the resulting Sprite onto our result
        result.push(this.getSprite(spriteIndex));

    }

    return result;

};

/**
 * Draws a provided text string to a provided graphics context at a provided Point using a
 * provided background and foreground color.
 *
 * @param context A 2D graphics context onto which to draw our string
 * @param point A Point instance representing X,Y coordinates (in sprite blocks) where to draw
 * @param text A text string to draw, represented as Sprites
 * @param foreground A foreground Color.
 * @param background A background Color.
 */
Graphics.prototype.drawString = function (context, point, text, foreground, background) {
    this.drawSprites(context, point, this.textToSprites(text), foreground, background);
};

/**
 * Draws a provided array of Sprite instances to a given Point on a provided 2D graphics context
 * using a provided foreground and background color.
 *
 * @param context A 2D graphics context onto which to draw our sprites
 * @param point A Point instance representing X,Y coordinates (in sprite blocks) where to draw
 * @param sprites An array of Sprite instances
 * @param foreground A foreground Color.
 * @param background A background Color.
 */
Graphics.prototype.drawSprites = function (context, point, sprites, foreground, background) {
    var sprite,
        index;

    point = point.clone();
    foreground = foreground || colors.Yellow;
    background = background || undefined;
    for (index = 0; index < sprites.length; index += 1) {
        sprite = sprites[index];
        sprite.draw(context, point, foreground, background);
        point.x += 1;
    }
};

Graphics.characterTable = {
    '\u236A': 1,   // âº Happy Face
    '\u263B': 2,   // â» Black happy face
    '\u2665': 3,   // â¥ Heart Suit
    '\u2666': 4,   // â¦ Diamond Suit
    '\u2663': 5,   // â£ Club Suit
    '\u2660': 6,   // â  Spade Suit
    '\u2022': 7,   // â¢ Bullet
    '\u25D8': 8,   // â Inverse Bullet
    '\u25CB': 9,   // â White Circle
    '\u25D9': 10,  // â Inverse White Circle
    '\u2642': 11,  // â Male Sign
    '\u2640': 12,  // â Female Sign
    '\u266A': 13,  // âª Eighth Note
    '\u266B': 14,  // â« Beamed Eighth Notes
    '\u263C': 15,  // â¼ White Sun With Rays
    '\u25BA': 16,  // âº Black Right-Pointing Pointer
    '\u25C4': 17,  // â Black Left-Pointing Pointer
    '\u2195': 18,  // â Up Down Arrow
    '\u203C': 19,  // â¼ Double Exclamation Mark
    '\u00B6': 20,  // Â¶ Pilcrow Sign
    '\u00A7': 21,  // Â§ Section Sign
    '\u25AC': 22,  // â¬ Black Rectangle
    '\u218A': 23,  // â¨ Up Down Arrow With Base
    '\u2191': 24,  // â Upwards Arrow
    '\u2193': 25,  // â Downwards Arrow
    '\u2192': 26,  // â Rightwards Arrow
    '\u2190': 27,  // â Leftwards Arrow
    '\u221F': 28,  // â Right Angle
    '\u2194': 29,  // â Left Right Arrow
    '\u25B2': 30,  // â² Black Up-Pointing Triangle
    '\u25BC': 31,  // â¼ Black Down-Pointing Triangle
    '\u2303': 127, // â House
    '\u00C7': 128, // Ã Capital C Cedilla
    '\u00FC': 129, // Ã¼ Small u Diaeresis
    '\u00E9': 130, // e Small e Acute
    '\u00E2': 131, // Ã¢ Small a Circumflex
    '\u00E4': 132, // Ã¤ Small a Diaeresis
    '\u00E0': 133, // Ã  Small a Grave
    '\u00E5': 134, // Ã¥ Small a Ring
    '\u00E7': 135, // Ã§ Small c Cedilla
    '\u00EA': 136, // Ãª Small e Circumflex
    '\u00EB': 137, // Ã« Small e Diaeresis
    '\u00E8': 138, // Ã¨ Small e Grave
    '\u00EF': 139, // Ã¯ Small u Diaeresis
    '\u00EE': 140, // Ã® Small i Circumflex
    '\u00EC': 141, // Ã¬ Small i Grave
    '\u00C4': 142, // Ã Capital A Diaeresis
    '\u00C5': 143, // Ã Capital A Ring
    '\u00C9': 144, // Ã Capital E Acute
    '\u00E6': 145, // Ã¦ Small AE
    '\u00C6': 146, // Ã Capital AE
    '\u00F4': 147, // Ã´ Small o Circumflex
    '\u00F6': 148, // Ã¶ Small o Diaeresis
    '\u00F2': 149, // Ã² Small o Grave
    '\u00FB': 150, // Ã» Small u Circumflex
    '\u00F9': 151, // Ã¹ Small u Grave
    '\u00FF': 152, // Ã¿ Small y Diaeresis
    '\u00D6': 153, // Ã Capital O Diaeresis
    '\u00DC': 154, // Ã Capital U Diaeresis
    '\u00A2': 155, // Â¢ Cent Sign
    '\u00A3': 156, // Â£ Pound Sign
    '\u00A5': 157, // Â¥ Yen Sign
    '\u20A7': 158, // â§ Peseta Sign
    '\u0192': 159, // Æ Small f with Hook
    '\u00E1': 160, // Ã¡ Small a Acute
    '\u00ED': 161, // Ã­ Small i Acute
    '\u00F3': 162, // Ã³ Small o Acute
    '\u00FA': 163, // Ãº Small u Acute
    '\u00F1': 164, // Ã± Small n Tilde
    '\u00D1': 165, // Ã Capital N Tilde
    '\u00AA': 166, // Âª Feminine Ordinal Indicator
    '\u00BA': 167, // Âº Masculine Ordinal Indicator
    '\u00BF': 168, // Â¿ Inverted Question Mark
    '\u2310': 169, // â Reversed Not Sign
    '\u00AC': 170, // Â¬ Not Sign
    '\u00BD': 171, // Â½ Vulgar Fraction One Half
    '\u00BC': 172, // Â¼ Vulgar Fraction One Quarter
    '\u00A1': 173, // Â¡ Inverted Exclamation Mark
    '\u00AB': 174, // Â« Left Pointing Double Angle Quotation Mark
    '\u00BB': 175, // Â» Right Pointing Double Angle Quotation Mark
    '\u2591': 176, // â Light Shade
    '\u2592': 177, // â Medium Shade
    '\u2593': 178, // â Dark Shade
    '\u2502': 179, // â Box Drawing Light Vertical
    '\u2524': 180, // â¤ Box Drawing Light Vertical Left
    '\u2561': 181, // â¡ Box Drawing Vertical Single Left Double
    '\u2562': 182, // â¢ Box Drawing Vertical Double Left Single
    '\u2556': 183, // â Box Drawing Down Double Left Single
    '\u2555': 184, // â Box Drawing Down Single Left Double
    '\u2563': 185, // â£ Box Drawing Vertical Double Left Double
    '\u2551': 186, // â Box Drawing Vertical Double
    '\u2557': 187, // â Box Drawing Down Double Left Double
    '\u255D': 188, // â Box Drawing Up Double Left Double
    '\u255C': 189, // â Box Drawing Up Double Left Single
    '\u255B': 190, // â Box Drawing Up Single Left Double
    '\u2510': 191, // â Box Drawing Down Single Left Single
    '\u2514': 192, // â Box Drawing Up Single Right Single
    '\u2534': 193, // â´ Box Drawing Horizontal Single Up Single
    '\u252C': 194, // â¬ Box Drawing Horizontal Single Down Single
    '\u251C': 195, // â Box Drawing Vertical Single Right Single
    '\u2500': 196, // â Box Drawing Light Horizontal
    '\u253C': 197, // â¼ Box Drawing Light Horizontal Vertical
    '\u255E': 198, // â Box Drawing Vertical Single Right Double
    '\u255F': 199, // â Box Drawing Vertical Double Right Single
    '\u255A': 200, // â Box Drawing Up Double Right Double
    '\u2554': 201, // â Box Drawing Down Double Right Double
    '\u2569': 202, // â© Box Drawing Double Horizontal Up Double
    '\u2566': 203, // â¦ Box Drawing Double Horizontal Down Double
    '\u2560': 204, // â  Box Drawing Double Vertical Double Right
    '\u2550': 205, // â Box Drawing Double Horizontal
    '\u256C': 206, // â¬ Box Drawing Double Horizontal Double Vertical
    '\u2567': 207, // â§ Box Drawing Double Horizontal Single Up
    '\u2568': 208, // â¨ Box Drawing Single Horizontal Double Up
    '\u2564': 209, // â¤ Box Drawing Double Horizontal Single Down
    '\u2565': 210, // â¥ Box Drawing Single Horizontal Double Down
    '\u2559': 211, // â Box Drawing Double Up Single Right
    '\u2558': 212, // â Box Drawing Single Up Double Right
    '\u2552': 213, // â Box Drawing Single Down Double Right
    '\u2553': 214, // â Box Drawing Double Down Single Right
    '\u256B': 215, // â« Box Drawing Double Vertical Single Horizontal
    '\u256A': 216, // âª Box Drawing Single Vertical Double Horizontal
    '\u2518': 217, // â Box Drawing Single Up Single Left
    '\u250C': 218, // â Box Drawing Single Down Single Right
    '\u2588': 219, // â Full Block
    '\u2584': 220, // â Lower Half Block
    '\u258C': 221, // â Left Half Block
    '\u2590': 222, // â Right Half Block
    '\u2580': 223, // â Upper Half Block
    '\u03B1': 224, // Î± Greek Small Alpha
    '\u00DF': 225, // Ã Greek Capital Beta
    '\u0393': 226, // Î Greek Capital Gamma
    '\u03C0': 227, // Ï Greek Small Pi
    '\u03A3': 228, // Î£ Greek Capital Sigma
    '\u03C3': 229, // Ï Greek Small Sigma
    '\u00B5': 230, // Âµ Micro Sign
    '\u03C4': 231, // Ï Greek Small Tau
    '\u03A6': 232, // Î¦ Greek Capital Phi
    '\u0398': 233, // Î Greek Capital Theta
    '\u03A9': 234, // Î© Greek Capital Omega
    '\u03B4': 235, // Î´ Greek Small Delta
    '\u221E': 236, // â Infinity
    '\u03C6': 237, // Greek Small Phi
    '\u03B5': 238, // Greek Small Epsilon
    '\u2229': 239, // â© Intersection
    '\u2261': 240, // â¡ Identical To
    '\u00B1': 241, // Â± Plus Minus Sign
    '\u2265': 242, // â¥ Greater Than Or Equal To
    '\u2264': 243, // â¤ Less Than Or Equal To
    '\u2320': 244, // â  Top Half Integral
    '\u2321': 245, // â¡ Bottom Half Integral
    '\u00F7': 246, // Ã· Division
    '\u2248': 247, // â Almost Equal To
    '\u00B0': 248, // Â° Degrees
    '\u2219': 249, // â Bullet Operator
    '\u00B7': 250, // Â· Middle Dot
    '\u221A': 251, // â Square Root
    '\u207F': 252, // â¿ Superscript Latin Small n
    '\u00B2': 253, // Â² Squared
    '\u25A0': 254  // â  Black Square
};

/**
 * Converts a provided special character into its ANSI equivalent.
 *
 * @param character A Unicode character
 * @return An ANSI character code.
 */
Graphics.prototype.convertSpecialCharacter = function (character) {

    // Get our char code
    var characterCode = character.charCodeAt(0);

    // Determine if character mapping isn't necessary
    if (characterCode >= 32 && characterCode <= 126) {
        return characterCode;
    }

    // Mapping is necessary, but do we have a mapping for this character?
    if (Graphics.characterTable.hasOwnProperty(character)) {
        return Graphics.characterTable[character];
    }

    // If we haven't mapped, return a question mark.
    return 63;

};

/**
 * SpriteGrid represents a block of renderable sprites defined with their colours.
 *
 * @param width A width for this sprite grid
 * @param height A height for this sprite grid
 * @param graphics a Graphics instance to own this SpriteGrid
 */
function SpriteGrid(width, height, graphics) {

    if (!(this instanceof SpriteGrid)) {
        throw ConstructorError;
    }

    this.width = width;
    this.height = height;
    this.graphics = graphics;
    this.tiles = [];
}

/**
 * Assigns a tile to this SpriteGrid at a provided position.
 *
 * @param point a Point to which to assign a sprite
 * @param spriteIndex a sprite index
 * @param foreground a foreground Color
 * @param background a background Color
 */
SpriteGrid.prototype.setTile = function (point, spriteIndex, foreground, background) {

    this.tiles[point.x + point.y * this.width] = {
        sprite: spriteIndex ? this.graphics.getSprite(spriteIndex) : undefined,
        foreground: foreground || colors.White,
        background: background
    };

};

/**
 * Assigns a new color to this SpriteGrid's tile at a provided position.
 *
 * @param point a Poit to which to assign a new color
 * @param foreground A foreground color
 * @param background A background color
 */
SpriteGrid.prototype.setColor = function (point, foreground, background) {
    var tile = this.tiles[point.x + point.y * this.width];
    if (tile) {
        tile.foreground = foreground || tile.foreground;
        tile.background = background || tile.background;
    }
};

/**
 * Clears this SpriteGrid's tiles.
 */
SpriteGrid.prototype.clear = function () {
    this.tiles = [];
};

/**
 * Adds text as sprites to this SpriteGrid.
 *
 * @param point a Point to which to add text
 * @param text A text string to add to this SpriteGrid
 * @param foreground A foreground Color
 * @param background A background Color
 */
SpriteGrid.prototype.addText = function (point, text, foreground, background) {

    var textPoint = point.clone(),
        index;

    text = this.graphics.textToSprites(text);

    for (index = 0; index < text.length; index += 1) {
        textPoint.x = point.x + index;
        this.tiles[textPoint.x + textPoint.y * this.width] = {
            sprite: text[index],
            foreground: foreground,
            background: background
        };
    }

};

SpriteGrid.prototype.addArt = function (startingPoint, artString) {

    var index,
        point = startingPoint.clone(),
        symbol,
        color;

    // For each character in our string
    for (index = 0; index < artString.length; index += 1) {

        // Grab our next symbol
        symbol = artString.charAt(index);

        // If it's a newline, break to the next line
        if (symbol === '\n') {

            point.x = startingPoint.x;
            point.y += 1;

        } else {

            symbol = this.graphics.convertSpecialCharacter(symbol);

            if (index + 1 <= artString.length) {
                index += 1;
                color = exports.getColor(artString.charAt(index));
            }

            this.setTile(point, symbol, color);

            point.x += 1;

        }

    }

};

/**
 * Retrieves a tile from this SpriteGrid at a specific position
 *
 * @param a Point for which to retrieve sprite data
 * @return An Object containing a sprite, foreground, and background color.
 */
SpriteGrid.prototype.getTile = function (point) {
    return this.tiles[point.x + point.y * this.width];
};

/**
 * Draws this SpriteGrid to a specified position on a provided graphics context.
 *
 * @param context A 2D graphics context
 * @param point a Point at which to draw our SpriteGrid
 */
SpriteGrid.prototype.draw = function (context, point) {

    var tile,
        spritePoint = new Point(0, 0);
    for (spritePoint.x = 0; spritePoint.x < this.width; spritePoint.x += 1) {
        for (spritePoint.y = 0; spritePoint.y < this.height; spritePoint.y += 1) {
            tile = this.getTile(spritePoint);
            if (tile) {

                // Determine if we have a sprite to draw, or just a background color
                if (tile.sprite) {
                    tile.sprite.draw(context, spritePoint.add(point), tile.foreground, tile.background);
                } else {
                    this.graphics.fillTile(context, spritePoint.add(point), tile.background);
                }

            }
        }
    }

};

/**
 * Color represents a named RBG color.
 *
 * @param code A Hex character representing a DOS color code
 * @param name A name of this color
 * @param index An index for this color
 * @param r A red value
 * @param g A green value
 * @param b A blue value
 */
function Color(code, name, index, r, g, b) {

    if (!(this instanceof Color)) {
        throw ConstructorError;
    }

    /**
     * Converts a byte into a Hexidecimal character digit.
     *
     * @param number A number from 0 to 255 to convert
     * @return A hexidecimal representation
     */
    function byteToHex(number) {
        var value = number.toString(16);
        if (value.length <= 1) {
            value = '0' + value;
        }
        return value;
    }

    this.code = code;
    this.name = name;

    if (index !== undefined) {
        this.index = index;
    }

    if (r !== undefined && g !== undefined && b !== undefined) {
        this.r = r;
        this.g = g;
        this.b = b;

        this.rgbValue = '#' + byteToHex(r) + byteToHex(g) + byteToHex(b);
    }

}

Color.prototype.darken = function () {
    var result = colors[this.index - 8];
    return result || this;
};

Color.prototype.lighten = function () {
    var result = colors[this.index + 8];
    return result || this;
};

Color.prototype.isLight = function () {
    return this.index >= 8;
};

Color.prototype.isDark = function () {
    return this.index < 8;
};

function CyclingColor(code, name, cycleSequence) {

    if (!(this instanceof CyclingColor)) {
        throw ConstructorError;
    }

    Color.call(this, code, name);
    this.cycleSequence = cycleSequence;
    this.code = code;
    this.name = name;
    this.cycleIndex = 0;
    this.update();
}
CyclingColor.prototype = new Color();
CyclingColor.prototype.constructor = CyclingColor;

CyclingColor.prototype.update = function () {
    var sequenceColor;
    this.cycleIndex = this.cycleIndex + 1 < this.cycleSequence.length ? this.cycleIndex + 1 : 0;
    sequenceColor = this.cycleSequence[this.cycleIndex];
    this.index = sequenceColor.index;
    this.r = sequenceColor.r;
    this.g = sequenceColor.g;
    this.b = sequenceColor.b;
    this.rgbValue = sequenceColor.rgbValue;
};

/**
 * colors is an enumerated type representing defined DOS colors.
 */
colors = [
    new Color('0', 'Black',         0,  0,   0,   0),
    new Color('1', 'Blue',          1,  0,   0,   170),
    new Color('2', 'Green',         2,  0,   170, 0),
    new Color('3', 'Cyan',          3,  0,   170, 170),
    new Color('4', 'Red',           4,  170, 0,   0),
    new Color('5', 'Magenta',       5,  170, 0,   170),
    new Color('6', 'Brown',         6,  170, 85,  0),
    new Color('7', 'White',         7,  170, 170, 170),
    new Color('8', 'Grey',          8,  85,  85,  85),
    new Color('9', 'BrightBlue',    9,  85,  85,  255),
    new Color('A', 'BrightGreen',   10, 85,  255, 85),
    new Color('B', 'BrightCyan',    11, 85,  255, 255),
    new Color('C', 'BrightRed',     12, 255, 85,  85),
    new Color('D', 'BrightMagenta', 13, 255, 85,  255),
    new Color('E', 'Yellow',        14, 255, 255, 85),
    new Color('F', 'BrightWhite',   15, 255, 255, 255)
];

cycle = new CyclingColor('*', 'Cycle', [colors[9], colors[10], colors[11], colors[12], colors[13], colors[14], colors[15]]);

function getColor(hexDigit) {
    return colors[parseInt(hexDigit, 16)];
}

function deserializeForeground(colorCode) {

    var foregroundCode;

    if (colorCode.length === 2) {
        foregroundCode = colorCode.charAt(1);
    } else if (colorCode.length === 1) {
        foregroundCode = colorCode.charAt(0);
    }

    if (foregroundCode) {
        return foregroundCode === '*' ? cycle : getColor(foregroundCode);
    }

    throw 'Invalid color code: ' + colorCode;

}

function deserializeBackground(colorCode) {

    var backgroundCode;

    if (colorCode.length === 2) {
        backgroundCode = colorCode.charAt(0);
        return backgroundCode === '*' ? undefined : getColor(backgroundCode);
    }

    return undefined;

}

function serialize(background, foreground) {
    return (background === undefined ? '*' : background.code) +
        (foreground === undefined ? 'E' : foreground instanceof CyclingColor ? '*' : foreground.code);
}

/**
 * Assigns convenience accessors for each of the colors in a provided array
 * to a specified object.
 *
 * @param colors An array of Color instances.
 * @param my An object to which to assign convenience accessors.
 */
exports.Colors = {};
(function (colors, exports) {

    var colorIndex;

    for (colorIndex = 0; colorIndex < colors.length; colorIndex += 1) {

        // Regular version
        exports[colors[colorIndex].name] = colors[colorIndex];

        // All caps version
        exports[colors[colorIndex].name.toUpperCase()] = colors[colorIndex];

    }

}(colors, exports.Colors));

// Exports
exports.getColor = getColor;
exports.deserializeForeground = deserializeForeground;
exports.deserializeBackground = deserializeBackground;
exports.serialize = serialize;
exports.Colors.Cycle = cycle;
exports.Color = Color;
exports.CyclingColor = CyclingColor;
exports.Graphics = Graphics;
exports.Sprite = Sprite;
exports.SpriteGrid = SpriteGrid;

},{"./basic":1}],6:[function(_dereq_,module,exports){
/**
 * JZT I18N
 * Copyright Â© 2014 Orangeline Interactive, Inc.
 * @author Mark McIntyre
 */

/*jslint node:true */

'use strict';

var DEFAULT_LANGUAGE = 'en';
var MESSAGES = {

    // ENGLISH-LANGUAGE MESSAGES
    en: {

        keys: {
            'collect': 'You now have the {0} key.',
            'toomany': 'You already have a {0} key.',
            '9': 'blue',
            'A': 'green',
            'B': 'cyan',
            'C': 'red',
            'D': 'purple',
            'E': 'yellow',
            'F': 'white'
        },
        doors: {
            'locked': 'The {0} door is locked.',
            'open': 'The {0} door is now open.',
            '1': 'blue',
            '2': 'green',
            '3': 'cyan',
            '4': 'red',
            '5': 'purple',
            '6': 'yellow',
            '7': 'white'
        },
        obstacles: {
            'water': 'Your way is blocked by water.',
            'signpost': 'Signpost',
            'signpostmessage': 'The signpost is curiously left blank.'
        },
        status: {
            'gameover': 'Game over!',
            'noammo': 'You don\'t have any ammo.',
            'hurt': 'Ouch!',
            'notorches': 'You don\'t have any torches.',
            'title': 'Press [P] to play.',
            'forest': 'A path is cleared through the forest.',
            'gem': 'Gems give you health.',
            'torch': 'Torches light up dark rooms.',
            'ammo': 'Ammunition: 5 shots per container.',
            'dark': 'Room is dark -- You need to light a torch.',
            'breakable': 'This wall has several cracks.',
            'noshoot': 'You can\'t shoot here.',
            'heart': 'Maximum health increased by 10!',
            'invisible': 'You are blocked by an invisible wall.',
            'notdark': 'You don\'t need a torch here.',
            'loading': 'Loading...',
            'loaderror': 'Oops! Loading failed.',
            'fatalerror': 'I has error, Jim.',
            'incompatible': 'Um, this file isn\'t compatible.',
            'nosave': 'Yikes! You\'re out of save space.'
        },
        pause: {
            'paused': 'Paused',
            'health': '    Health:',
            'ammo': '      Ammo:',
            'gems': '      Gems:',
            'torches': '   Torches:',
            'score': '     Score:',
            'keys': '      Keys:'
        },
        file: {
            'new': 'Empty Slot',
            'saved': 'Saved Game',
            'save': 'Save Game',
            'load': 'Restore Game',
            'restart': 'Restart Game'
        }
    },

    // FRENCH-LANGUAGE MESSAGES
    fr: {

        keys: {
            'collect': 'Vous avez maintenant la clÃ© {0}.',
            'toomany': 'Vous avez dÃ©ja une clÃ© {0}.',
            '9': 'bleue',
            'A': 'verte',
            'B': 'cyan',
            'C': 'rouge',
            'D': 'violet',
            'E': 'jaune',
            'F': 'blanche'
        },
        doors: {
            'locked': 'La porte {0} est verrouillÃ©e.',
            'open': 'La porte {0} est maintenant overte.',
            '1': 'bleue',
            '2': 'verte',
            '3': 'cyan',
            '4': 'rouge',
            '5': 'violet',
            '6': 'jaune',
            '7': 'blanche'
        },
        obstacles: {
            'water': 'Votre chemin est bloquÃ©e par de l\'eau',
            'signpost': 'Poteau Indicateur',
            'signpostmessage': 'Le poteau indicateur est curieusement vierge.'
        },
        status: {
            'gameover': 'Game over !',
            'noammo': 'Vous n\'avez plus de munitions.',
            'hurt': 'AÃ¯e !',
            'notorches': 'Vous n\'avez plus de torches.',
            'title': 'Appuyez sur [P] pour jouer.',
            'forest': 'Vous frayez un chemin dans la fÃ´ret.',
            'gem': 'Les bijoux augmentent vos PV.',
            'torch': 'Les torches Ã©clairent des piÃ¨ces sombres.',
            'ammo': 'Munitions: 5 bulles par unitÃ©.',
            'dark': 'PiÃ¨ce sombre -- Vous avez besoin d\'une torche!',
            'breakable': 'Ce mur a plusieurs fissures.',
            'noshoot': 'Il est interdit de tirer ici.',
            'heart': 'PV max a augmentÃ© par 10 !',
            'invisible': 'Vous Ãªtes bloquÃ© par un mur invisible.',
            'notdark': 'Vous n\'avez pas besoin d\'une torche ici.',
            'loading': 'Chargement...',
            'loaderror': 'Oups! Chargement echouÃ©.',
            'fatalerror': 'J\'ai l\'erreur, Jim.',
            'incompatible': 'Mais ce fichier est incompatible...',
            'nosave': 'Vous n\'avez plus d\'Ã©space pour sauvegarder.'
        },
        pause: {
            'paused': 'Pause',
            'health': '        PV:',
            'ammo': ' Munitions:',
            'gems': '    Bijous:',
            'torches': '   Torches:',
            'score': '     Score:',
            'keys': '      ClÃ©s:'
        },
        file: {
            'new': 'Espace Vide',
            'saved': 'Jeu SauvegardÃ©',
            'save': 'Sauvegarder',
            'load': 'Ouvrir',
            'restart': 'RÃ©commencer'
        }
    }

};

var currentLanguage;
var currentMessages;

function findMessage(source, key) {

    var path = key.split('.'),
        current = source,
        index;

    for (index = 0; index < path.length; index += 1) {
        if (current[path[index]] === undefined) {
            return undefined;
        }

        current = current[path[index]];

    }

    return current;

}

function getMessage(key) {

    var argumentIndex,
        result = findMessage(currentMessages, key),
        regEx;

    if (result === undefined && currentMessages !== DEFAULT_LANGUAGE) {
        result = findMessage(MESSAGES[DEFAULT_LANGUAGE], key);
    }

    if (result === undefined) {
        return key;
    }

    for (argumentIndex = 1; argumentIndex < arguments.length; argumentIndex += 1) {
        regEx = new RegExp('\\{' + (argumentIndex - 1) + '\\}', 'g');
        result = result.replace(regEx, arguments[argumentIndex]);
    }

    return result;

}

function getLanguage() {
    return currentLanguage;
}

function setLanguage(language) {
    currentLanguage = language;
    currentMessages = MESSAGES.hasOwnProperty(language) ? MESSAGES[language] : MESSAGES[DEFAULT_LANGUAGE];
}

function getBoardMessage(board, potentialKey) {

    if (potentialKey.indexOf('i18n:') === 0) {
        return board.getMessage(potentialKey.substring(5));
    }

    return potentialKey;

}

// Set our default language right off the bat
setLanguage(DEFAULT_LANGUAGE);

// Exports
exports.DefaultLanguage = DEFAULT_LANGUAGE;
exports.Messages = MESSAGES;
exports.getMessage = getMessage;
exports.findMessage = findMessage;
exports.getLanguage = getLanguage;
exports.setLanguage = setLanguage;
exports.getBoardMessage = getBoardMessage;

},{}],7:[function(_dereq_,module,exports){
/**
 * JZTScript Commands
 * Copyright Â© 2014 Orangeline Interactive, Inc.
 * @author Mark McIntyre
 */

/*jslint node:true */

'use strict';

var ThingFactory = _dereq_('./things').ThingFactory,
    BasicDirection = _dereq_('./basic').Direction,
    ConstructorError = _dereq_('./basic').ConstructorError,
    GameState = _dereq_('./game-state').GameState,
    getBoardMessage = _dereq_('./i18n').getBoardMessage;

/**
 * {@code CommandResult} is an object containing definitions of
 * command results. The values are NORMAL, CONTINUE, and REPEAT.
 * NORMAL: Returned when a Command executes normally.
 * CONTINUE: Requests that the next command be executed immediately.
 * REPEAT: Requests that the same command be executed again next cycle.
 */
var CommandResult = Object.freeze({
    NORMAL: 0,
    CONTINUE: 1,
    CONTINUE_AFTER_JUMP: 2,
    REPEAT: 3
});

/**
 * Direction Modifier Enumerated Types
 *
 * Each direction modifier has an associated token value, a display name, and a process function.
 * The process function takes a direction and returns a final, calculated direction value.
 */
var DirectionModifier = Object.freeze({
    CW:   {name: 'Clockwise',              type: 'modifier', process: function (d) { return BasicDirection.clockwise(d); }},
    CCW:  {name: 'Counter-clockwise',      type: 'modifier', process: function (d) { return BasicDirection.counterClockwise(d); }},
    OPP:  {name: 'Opposite',               type: 'modifier', process: function (d) { return BasicDirection.opposite(d); }},
    RNDP: {name: 'Perpendicularly Random', type: 'modifier', process: function (d) { return BasicDirection.randomPerpendicular(d); }}
});


/**
 * Direction Enumerated Types
 *
 * Each direction has an associated token value, a display name, and a process function.
 * The process function takes a JztObject and returns a final, calculated direction value.
 */
var Direction = Object.freeze({
    SEEK:  {name: 'Toward player',            type: 'terminal', process: function (o) { return o.getPlayerDirection(); }},
    SMART: {name: 'Smart seek',               type: 'terminal', process: function (o) { return o.getSmartDirection() || o.getPlayerDirection(); }},
    FLOW:  {name: 'Current orientation',      type: 'terminal', process: function (o) { return o.orientation; }},
    RAND:  {name: 'Random direction',         type: 'terminal', process: function () { return BasicDirection.random(); }},
    RANDF: {name: 'Random free direction',    type: 'terminal', process: function (o) { return BasicDirection.random(o.getFreeDirections()); }},
    RANDB: {name: 'Random blocked direction', type: 'terminal', process: function (o) { return BasicDirection.random(o.getBlockedDirections()); }},
    RNDEW: {name: 'Randomly East or West',    type: 'terminal', process: function () { return BasicDirection.randomEastWest(); }},
    RNDNS: {name: 'Randomly North or South',  type: 'terminal', process: function () { return BasicDirection.randomNorthSouth(); }},
    RNDNE: {name: 'Randomly North or East',   type: 'terminal', process: function () { return BasicDirection.randomNorthEast(); }},
    NORTH: {name: 'North',                    type: 'terminal', process: function () { return BasicDirection.North; }},
    EAST:  {name: 'East',                     type: 'terminal', process: function () { return BasicDirection.East; }},
    SOUTH: {name: 'South',                    type: 'terminal', process: function () { return BasicDirection.South; }},
    WEST:  {name: 'West',                     type: 'terminal', process: function () { return BasicDirection.West; }},
    N:     {name: 'North shorthand',          type: 'terminal', process: function () { return BasicDirection.North; }},
    E:     {name: 'East shorthand',           type: 'terminal', process: function () { return BasicDirection.East; }},
    S:     {name: 'South shorthand',          type: 'terminal', process: function () { return BasicDirection.South; }},
    W:     {name: 'West shorthand',           type: 'terminal', process: function () { return BasicDirection.West; }}
});

/**
 * Label
 *
 * A label is a named line identifier used to jump to instruction locations within
 * a script. A label isn't strictly a command and can't be executed; instead, it's
 * used as a marker in a parsed script result.
 */
function Label(name) {

    if (!(this instanceof Label)) {
        throw ConstructorError;
    }

    this.name = name;
}

/**
 * DirectionExpression
 *
 * A DirectionExpression consists of a direction terminal and a series of optional
 * modifiers that transform the direction into a final result.
 */
function DirectionExpression(terminal) {

    if (!(this instanceof DirectionExpression)) {
        throw ConstructorError;
    }

    this.modifiers = [];
    this.terminal = terminal;
    this.count = 1;
}

/**
 * Executes this DirectionExpression and returns a concrete Direction instance.
 */
DirectionExpression.prototype.getResult = function (owner) {

    // Get our direction from our expression
    var direction = this.terminal.process(owner),
        modifiers = this.modifiers.slice(0);

    while (modifiers.length) {
        direction = modifiers.pop().process(direction);
    }

    // Return our result
    return direction;
};

/**
 * BecomeCommand
 *
 * When executed, a provided owner Thing will be replaced with another Thing specified
 * by this command's template.
 */
function BecomeCommand(thingTemplate) {

    if (!(this instanceof BecomeCommand)) {
        throw ConstructorError;
    }

    this.thingTemplate = thingTemplate;

}

/**
 * Replace a provided owner with another Thing based on this command's
 * associated thing template.
 */
BecomeCommand.prototype.execute = function (owner) {

    // Create our new thing
    var newThing = ThingFactory.deserialize(this.thingTemplate, owner.board);

    // Replace our owner's tile with the new thing
    owner.board.replaceTile(owner.point, newThing);

};

/**
 * ChangeCommand
 *
 * When executed, a board will have all instances of things
 * specified by this commands template by another type of Thing.
 */
function ChangeCommand(fromTemplate, toTemplate) {
    if (!(this instanceof ChangeCommand)) {
        throw ConstructorError;
    }

    this.fromTemplate = fromTemplate;
    this.toTemplate = toTemplate;
}

/**
 * Replaces all things on a provided owner's board matching this command's fromTemplate.
 */
ChangeCommand.prototype.execute = function (owner) {
    owner.board.changeTiles(this.fromTemplate, this.toTemplate);
    return CommandResult.CONTINUE;
};

/**
 * CharCommand
 *
 * A command that changes an owner's character code to a specified value.
 */
function CharCommand(value) {
    if (!(this instanceof CharCommand)) {
        throw ConstructorError;
    }
    this.value = value;
}

/**
 * Changes a provided owner's character value.
 */
CharCommand.prototype.execute = function (owner) {
    owner.spriteIndex = this.value;
};

/**
 * DieCommand
 *
 * A Command that removes an owner from its board.
 */
function DieCommand(magnetically) {
    if (!(this instanceof DieCommand)) {
        throw ConstructorError;
    }
    this.magnetically = magnetically;
}

/**
 * Removes a provided owner from its associated board.
 */
DieCommand.prototype.execute = function (owner) {
    owner.remove();
    if (this.magnetically) {
        owner.board.player.push(BasicDirection.opposite(owner.getPlayerDirection()));
    }
};

/**
 * EndCommand
 *
 * A command that halts script execution on its owner's script context.
 */
function EndCommand() {
    if (!(this instanceof EndCommand)) {
        throw ConstructorError;
    }
}

/**
 * Halt script execution on a provided owner's script context.
 */
EndCommand.prototype.execute = function (owner) {
    owner.scriptContext.stop();
};

/**
 * GiveCommand
 *
 * Increases a game counter by a specified amount.
 */
function GiveCommand(counter, amount) {
    if (!(this instanceof GiveCommand)) {
        throw ConstructorError;
    }
    this.counter = counter.toUpperCase();
    this.amount = amount;
}

/**
 * Increases a counter on this owner's game by an amount specified
 * by this command.
 */
GiveCommand.prototype.execute = function (owner) {
    owner.board.game.adjustCounter(this.counter, this.amount);
    return CommandResult.CONTINUE;
};

/**
 * IfCommand
 *
 * Jumps to a new execution location if an expression evaluates to true.
 */
function IfCommand(label, expression) {
    if (!(this instanceof IfCommand)) {
        throw ConstructorError;
    }
    this.label = label;
    this.expression = expression;
}

/**
 * Jumps to an owner's label if this command's expression evaluates to true.
 */
IfCommand.prototype.execute = function (owner) {
    if (this.expression.getResult(owner)) {
        owner.scriptContext.jumpToLabel(this.label);
        return CommandResult.CONTINUE_AFTER_JUMP;
    }
    return CommandResult.CONTINUE;
};

/**
 * LockCommand
 *
 * When executed, an owner will no longer be able to receive messages
 * from other scripts.
 */
function LockCommand() {
    if (!(this instanceof LockCommand)) {
        throw ConstructorError;
    }
}

/**
 * Locks the provided owner so that it can no longer receive messages from other scripts.
 */
LockCommand.prototype.execute = function (owner) {
    owner.locked = true;
    return CommandResult.CONTINUE;
};

/**
 * MoveCommand
 *
 * When executed, an owner will be moved according to this command's
 * direction expression and options.
 */
function MoveCommand(directionExpression, forceful) {
    this.directionExpression = directionExpression;
    this.forceful = forceful;
}

/**
 * Executes this MoveCommand, moving a provided owner on the board
 * according to the result of this command's direction expression and
 * options.
 */
MoveCommand.prototype.execute = function (owner) {

    return this.forceful ? this.forcefulMove(owner) : this.move(owner);

};

/**
 * Moves a provided owner gently in a direction according to
 * this command's direction expression result.
 */
MoveCommand.prototype.move = function (owner) {

    var heap = owner.scriptContext.heap,
        direction = this.directionExpression.getResult(owner),
        count = '<count>';

    if (!heap[count]) {
        heap[count] = this.directionExpression.count;
    }

    // If a direction is available
    if (direction) {

        // If we are to go a number of times...
        if (heap[count] > 0) {

            heap[count] -= 1;

            if (owner.move(direction)) {
                return CommandResult.REPEAT;
            }

        } else {
            delete heap[count];
        }

    }

};

/**
 * Moves a provided owner forcefully in a direction according to
 * this command's direction expression result.
 */
MoveCommand.prototype.forcefulMove = function (owner) {

    var direction,
        heap = owner.scriptContext.heap,
        count = '<count>',
        stuck = '<stuck>',
        success;

    if (!heap[count]) {
        heap[count] = this.directionExpression.count;
    }


    // Depending on if we are stuck or not...
    if (!heap[stuck]) {
        // We're not stuck, so calculate our next direction
        direction = this.directionExpression.getResult(owner);
    } else {
        // We are stuck, continue trying that direction
        direction = BasicDirection.fromName(heap[stuck]);
    }

    // If a direction is available
    if (direction) {

        success = owner.move(direction);

        // If we were not successful, we're stuck
        if (!success) {

            heap[stuck] = BasicDirection.getShortName(direction);

            // We will try again until we're free
            return CommandResult.REPEAT;

        }

        // We aren't stuck, so count our moves down
        heap[count] -= 1;
        if (heap[count] > 0) {
            delete heap[stuck];
            return CommandResult.REPEAT;
        }

        // We're not moving anymore...
        delete heap[count];
        delete heap[stuck];

    }

};

/**
 * PlayCommand
 *
 * When executed, has the owner play a specified audio sequence.
 */
function PlayCommand(sequence) {
    this.sequence = sequence;
}

/**
 * Play this command's audio sequence with the owner.
 */
PlayCommand.prototype.execute = function (owner) {
    owner.play(this.sequence, true);
    return CommandResult.CONTINUE;
};

/**
 * PutCommand
 *
 * Put is a command that, when executed, adds a new instance of a provided
 * template at a space in a provided direction relative to an owner.
 */
function PutCommand(thingTemplate, directionExpression) {
    this.thingTemplate = thingTemplate;
    this.directionExpression = directionExpression;
}

/**
 * Inserts a new instance of this command's thing template at a location
 * directly adjacent to a provided owner, if the space isn't already occupied.
 */
PutCommand.prototype.execute = function (owner) {

    var newThing,
        direction = this.directionExpression.getResult(owner),
        point = owner.point.add(direction),
        obstacle,
        isFreeSpace;

    // If our point is off the board, return immediately
    if (owner.board.isOutside(point)) {
        return;
    }


    // Get the tile in the way, if applicable
    obstacle = owner.board.getTile(point);

    // Determine if there is free space, or if we can make some by pushing an obstacle
    isFreeSpace = obstacle ? owner.board.moveTile(owner.point, point, false, true) : true;

    // Create our new thing
    newThing = ThingFactory.deserialize(this.thingTemplate, owner.board);


    // Depending on if there's space and a thing available...
    if (isFreeSpace && newThing) {

        // There's space, so add our thing
        owner.board.addThing(point, newThing);

    } else if (!isFreeSpace && !newThing) {

        // There's no free space, and we're putting emptiness,
        // so delete the existing tile.
        owner.board.deleteTile(point);

    }

};

/**
 * Restore Command
 *
 * When executed, an associated label is restored in a provided
 * owner's script context.
 */
function RestoreCommand(label) {
    this.label = label;
}

/**
 * Restores this command's associated label in a provided owner's
 * script context.
 */
RestoreCommand.prototype.execute = function (owner) {
    owner.scriptContext.restoreLabel(this.label);
    return CommandResult.CONTINUE;
};

/**
 * Say Command
 * When executed, a textual alert is requested to be displayed by
 * a provided owner.
 */
function SayCommand(text) {
    this.text = text;
}

/**
 * Display this command's textual alert via a provided owner.
 */
SayCommand.prototype.execute = function (owner) {
    var message = getBoardMessage(owner.board, this.text);
    owner.board.setDisplayMessage(message);
    return CommandResult.CONTINUE;
};

/**
 * ScrollCommand
 *
 * When executed, adds a line of text to a provided owner's
 * script context's scroll queue, with optional bold formatting
 * and an optional jump label for creating command options.
 */
function ScrollCommand(text, bold, label) {
    this.text = text;
    this.bold = bold;
    this.label = label;
    this.modifiesScroll = true;
}

/**
 * Adds a line of text based on this command's configuration to
 * a provided owner's script context's scroll queue.
 */
ScrollCommand.prototype.execute = function (owner) {
    var message = getBoardMessage(owner.board, this.text);
    owner.scriptContext.addScrollContent(message, this.bold, this.label);
    return CommandResult.CONTINUE;
};

/**
 * SendCommand
 *
 * When executed, sends a message to a provided recipient via a
 * specified owner. If a recipient is SELF, then the message is
 * delivered to the owner directly. If a recipient is ALL, then
 * the message is delivered to all scriptable things on the board.
 */
function SendCommand(recipient, message) {
    this.recipient = recipient;
    this.message = message;
}

/**
 * Sends a message to a provided recipient via a specified owner.
 * If a recipient is SELF, then the message is delivered to the owner
 * directly. If a recipient is ALL, then the message is delivered
 * to all scriptable things on the board.
 */
SendCommand.prototype.execute = function (owner) {

    var recipients,
        index;

    if (this.recipient === 'SELF') {
        owner.scriptContext.jumpToLabel(this.message);
        return CommandResult.CONTINUE_AFTER_JUMP;
    }

    if (this.recipient === 'ALL') {
        recipients = owner.board.getScripables();
    } else {
        recipients = owner.board.getScriptables(this.recipient);
    }

    for (index = 0; index < recipients.length; index += 1) {
        recipients[index].sendMessage(this.message);
    }

    return CommandResult.CONTINUE;

};

/**
 * SetCommand
 *
 * When executed, sets a counter to a provided value.
 */
function SetCommand(counter, value) {
    this.counter = counter;
    this.value = value;
}

/**
 * Sets a counter to this command's associated value.
 */
SetCommand.prototype.execute = function (owner) {
    owner.board.game.setCounterValue(this.counter, this.value);
};

/**
 * ShootCommand
 *
 * When executed, adds a directed bullet to an owner's board relative
 * to the position of the owner.
 */
function ShootCommand(directionExpression) {
    this.directionExpression = directionExpression;
}

/**
 * Places a directed bullet relative to the position of a provided owner.
 */
ShootCommand.prototype.execute = function (owner) {

    // Get our final direction
    var direction = this.directionExpression.getResult(owner);

    // If a direction is available
    if (direction) {

        // Play a shooting noise
        owner.play('c-f#');

        // Shoot
        ThingFactory.shoot(owner.board, owner.point.add(direction), direction, false);

    }

};

/**
 * StandCommand
 *
 * When executed, halts an owner from walking.
 */
function StandCommand() {
    if (!(this instanceof StandCommand)) {
        throw ConstructorError;
    }
}

/**
 * Halts a provided owner from walking.
 */
StandCommand.prototype.execute = function (owner) {
    owner.walkDirection = undefined;
};

/**
 * TakeCommand
 *
 * When executed, subtracts a provided value from a given counter.
 * If it is not possible to subtract the required amount, then execution
 * should jump to a specified label instead.
 */
function TakeCommand(counter, value, label) {
    this.counter = counter;
    this.value = value;
    this.label = label;
}

/**
 * Subtracts a provided value from a given counter.
 * If it is not possible to subtract the required amount, then execution
 * should jump to a specified label within a provided owner's context instead.
 */
TakeCommand.prototype.execute = function (owner) {

    // Depending on if there's enough counter available to take...
    if (owner.board.game.getCounterValue(this.counter) < this.value) {

        // There isn't enough counter, so if we've got a label...
        if (this.label) {

            // Jump!
            owner.scriptContext.jumpToLabel(this.label);
            return CommandResult.CONTINUE_AFTER_JUMP;

        }

    } else {

        // Take away our counter value
        owner.board.game.adjustCounter(this.counter, -1 * this.value);
        return CommandResult.CONTINUE;

    }
};

/**
 * ThrowStar Command
 *
 * When executed, launches a throwing star in a direction relative
 * to this command's provided owner.
 */
function ThrowStarCommand(directionExpression) {
    this.directionExpression = directionExpression;
}

/**
 * Launches a throwing star in a direction relative to a provided owner.
 */
ThrowStarCommand.prototype.execute = function (owner) {
    // Get our final direction
    var direction = this.directionExpression.getResult(owner);

    // If a direction is available
    if (direction) {

        // Shoot
        ThingFactory.shoot(owner.board, owner.point.add(direction), direction, false, true);

    }
};

/**
 * Torch Command
 *
 * When executes, sets an owner's torch radius to this command's associated
 * radius.
 */
function TorchCommand(radius) {
    this.radius = radius;
}

/**
 * Sets an owner's torch radius to this command's associated
 * radius.
 */
TorchCommand.prototype.execute = function (owner) {
    owner.setTorchRadius(this.radius);
};

/**
 * UnlockCommand
 *
 * When executed, sets a provided owner's locked state to false,
 * allowing it to once again receive messages from other
 * Scriptables.
 */
function UnlockCommand() {
    if (!(this instanceof UnlockCommand)) {
        throw ConstructorError;
    }
}

/**
 * Sets a provided owner's locked state to false,
 * allowing it to once again receive messages from other
 * Scriptables.
 */
UnlockCommand.prototype.execute = function (owner) {
    owner.locked = false;
    return CommandResult.CONTINUE;
};

/**
 * VictoryCommand
 *
 * When executed, sets the owner's game's state to Victory.
 */
function VictoryCommand() {
    if (!(this instanceof VictoryCommand)) {
        throw ConstructorError;
    }
}

/**
 * Sets a provided owner's game's state to victory.
 */
VictoryCommand.prototype.execute = function (owner) {
    owner.board.game.setState(GameState.Victory);
};

/**
 * WaitCommand
 *
 * When executed, pauses script execution for a number
 * of specified cycles.
 */
function WaitCommand(count) {
    this.count = count;
}

/**
 * Pauses script execution for a number
 * of specified cycles.
 */
WaitCommand.prototype.execute = function (owner) {

    var heap = owner.scriptContext.heap,
        cycles = '<cycles>';

    if (!heap[cycles]) {
        heap[cycles] = this.count;
    }

    heap[cycles] -= 1;
    if (heap[cycles] > 0) {
        return CommandResult.REPEAT;
    }

    // If we've got no more heap cycles, delete it entirely
    delete heap[cycles];

};

/**
 * WalkCommand
 *
 * When executed, instructs a provided owner to begin walking
 * in a direction as evaluated by this command's provided
 * direction expression;
 */
function WalkCommand(directionExpression) {
    this.directionExpression = directionExpression;
}

/**
 * Instructs a provided owner to begin walking
 * in a direction as evaluated by this command's provided
 * direction expression;
 */
WalkCommand.prototype.execute = function (owner) {
    var direction = this.directionExpression.getResult(owner);
    owner.walkDirection = direction;
    return CommandResult.CONTINUE;
};

/**
 * ZapCommand
 *
 * When executed, zaps a provided label from an owner's script
 * context.
 */
function ZapCommand(label) {
    this.label = label;
}

/**
 * Zaps a provided label from an owner's script context.
 */
ZapCommand.prototype.execute = function (owner) {
    owner.scriptContext.zapLabel(this.label);
    return CommandResult.CONTINUE;
};

// EXPRESSIONS ------------------------------------------------

/**
 * NotExpression
 */
function NotExpression(expression) {
    this.subExpression = expression;
}

NotExpression.prototype.getResult = function (owner) {
    return !this.subExpression.getResult(owner);
};

/**
 * AdjacentExpression
 */
function AdjacentExpression() {
    if (!(this instanceof AdjacentExpression)) {
        throw ConstructorError;
    }
}

AdjacentExpression.prototype.getResult = function (owner) {
    return owner.isPlayerAdjacent();
};

/**
 * BlockedExpression
 */
function BlockedExpression(directionExpression) {
    this.directionExpression = directionExpression;
}

BlockedExpression.prototype.getResult = function (owner) {
    return owner.isBlocked(this.directionExpression.getResult(owner));
};

/**
 * AlignedExpression
 */
function AlignedExpression(directionExpression) {
    this.directionExpression = directionExpression;
}

AlignedExpression.prototype.getResult = function (owner) {
    return this.directionExpression ? owner.isPlayerAligned(1, this.directionExpression.getResult(owner)) : owner.isPlayerAligned(1);
};

/**
 * PeepExpression
 */
function PeepExpression(radius) {
    this.radius = radius;
}

PeepExpression.prototype.getResult = function (owner) {
    return owner.isPlayerVisible(this.radius);
};

/**
 * ExistsExpression
 */
function ExistsExpression(thingTemplate, count) {
    this.thingTemplate = thingTemplate;
    this.count = count;
}

ExistsExpression.prototype.getResult = function (owner) {
    return owner.board.hasTile(this.thingTemplate, this.count);
};

/**
 * TestingExpression
 */
function TestingExpression(counter, operand, value) {
    this.counter = counter;
    this.operand = operand;
    this.value = value;
}

TestingExpression.prototype.getResult = function (owner) {

    // Get our counter value
    var counterValue = owner.getCounterValue(this.counter);

    switch (this.operand) {
    case '>':
        return counterValue > this.value;
    case '<':
        return counterValue < this.value;
    case '>=':
        return counterValue >= this.value;
    case '<=':
        return counterValue <= this.value;
    case '=':
        return counterValue === this.value;
    }

    return undefined;
};

// PUBLIC INTERFACE -------------------------------------------

exports.CommandResult = CommandResult;

exports.DirectionModifier = DirectionModifier;
exports.Direction = Direction;

exports.DirectionExpression = DirectionExpression;

exports.Label = Label;

exports.BecomeCommand = BecomeCommand;
exports.ChangeCommand = ChangeCommand;
exports.CharCommand = CharCommand;
exports.DieCommand = DieCommand;
exports.EndCommand = EndCommand;
exports.GiveCommand = GiveCommand;
exports.IfCommand = IfCommand;
exports.LockCommand = LockCommand;
exports.MoveCommand = MoveCommand;
exports.PlayCommand = PlayCommand;
exports.PutCommand = PutCommand;
exports.ScrollCommand = ScrollCommand;
exports.SendCommand = SendCommand;
exports.SetCommand = SetCommand;
exports.TakeCommand = TakeCommand;
exports.ThrowStarCommand = ThrowStarCommand;
exports.TorchCommand = TorchCommand;
exports.RestoreCommand = RestoreCommand;
exports.SayCommand = SayCommand;
exports.ShootCommand = ShootCommand;
exports.StandCommand = StandCommand;
exports.UnlockCommand = UnlockCommand;
exports.VictoryCommand = VictoryCommand;
exports.WaitCommand = WaitCommand;
exports.WalkCommand = WalkCommand;
exports.ZapCommand = ZapCommand;

exports.NotExpression = NotExpression;
exports.AdjacentExpression = AdjacentExpression;
exports.BlockedExpression = BlockedExpression;
exports.AlignedExpression = AlignedExpression;
exports.PeepExpression = PeepExpression;
exports.ExistsExpression = ExistsExpression;
exports.TestingExpression = TestingExpression;

},{"./basic":1,"./game-state":4,"./i18n":6,"./things":13}],8:[function(_dereq_,module,exports){
/**
 * JZTScript Context
 * Copyright Â© 2014 Orangeline Interactive, Inc.
 * @author Mark McIntyre
 */

/*jslint node:true */

'use strict';

var GameState = _dereq_('./game-state').GameState,
    commands = _dereq_('./jzt-script-commands');

/**
 * A ScriptContext is a context in which a script can run, including an associated
 * Scriptable, a current execution index, labels, and more.
 *
 * @param script A script which this ScriptContext is set to execute.
 * @param owner A Scriptable to own this ScriptContext.
 */
function JztScriptContext(script, owner) {
    this.owner = owner;
    this.script = script;
    this.commandIndex = 0;
    this.currentLabels = {};
    this.heap = {};
    this.initializeLabels(script);
    this.scrollContent = [];
    this.jumpCount = 0;
}

/**
 * Serializes this JztScriptContext to a data object.
 *
 * @return A data object representing this JztScriptContext.
 */
JztScriptContext.prototype.serialize = function () {

    var result = {},
        label;
    result.commandIndex = this.commandIndex;
    result.currentLabels = {};
    result.heap = this.heap;
    for (label in this.currentLabels) {
        if (this.currentLabels.hasOwnProperty(label) && this.currentLabels[label]) {
            result.currentLabels[label] = this.currentLabels[label];
        }
    }

    return result;

};

/**
 * De-serializes a provided data object to initialize this JztScriptContext.
 *
 * @param data A serialized JztScriptContext.
 */
JztScriptContext.prototype.deserialize = function (data) {

    var label;

    this.commandIndex = data.commandIndex;
    this.heap = data.heap;
    for (label in data.currentLabels) {
        if (data.currentLabels.hasOwnProperty(label)) {
            this.currentLabels[label] = data.currentLabels[label];
        }
    }

};

/**
 * Determines whether or not we are in a default state for this JztScriptContext.
 * A script context that's in its default state has no need of being serialized.
 *
 * @return true if in a default state, false otherwise.
 */
JztScriptContext.prototype.inDefaultState = function () {

    var defaultState = true,
        labelIndex;

    // Look for evidence that we're not in a default state
    if (this.commandIndex > 0) {

        // We aren't at the first command
        defaultState = false;

    } else if (Object.keys(this.heap).length > 0) {

        // The heap is not empty
        defaultState = false;

    } else {

        // We have some non-zero label indicies
        for (labelIndex in this.currentLabels) {
            if (this.currentLabels.hasOwnProperty(labelIndex) && this.currentLabels[labelIndex] !== 0) {
                defaultState = false;
                break;
            }
        }

    }

    return defaultState;

};

/**
 * Initializes this JztScriptContext's labels to that of a provided Script instance.
 *
 * @param script A Script used to initialize this JztScriptContext's labels.
 */
JztScriptContext.prototype.initializeLabels = function (script) {
    var label;
    for (label in script.labelIndicies) {
        if (script.labelIndicies.hasOwnProperty(label)) {
            this.currentLabels[label] = 0;
        }
    }
};

/**
 * Retrieves whether or not this JztScriptContext is currently running.
 *
 * @return true if this JztScriptContext is running, false otherwise.
 */
JztScriptContext.prototype.isRunning = function () {
    return this.commandIndex >= 0 && this.commandIndex < this.script.commands.length;
};

/**
 * Stops running this JztScriptContext.
 */
JztScriptContext.prototype.stop = function () {
    this.commandIndex = -1;
};

JztScriptContext.prototype.addScrollContent = function (line, center, lineLabel) {
    var newLine = {
        'text': line,
        'center': center,
        'label': lineLabel
    };
    this.scrollContent.push(newLine);
};

JztScriptContext.prototype.displayScroll = function () {
    var index,
        line;

    this.owner.board.game.scroll.setTitle(this.owner.name);
    this.owner.board.game.scroll.clearLines();
    this.owner.board.game.scroll.listener = this.owner;

    for (index = 0; index < this.scrollContent.length; index += 1) {
        line = this.scrollContent[index];
        this.owner.board.game.scroll.addLine(line.text, line.center, line.label);
    }

    this.scrollContent = [];
    this.owner.board.game.setState(GameState.Reading);

};

/**
 * Executes a single tick of this JztScriptContext, taking a command from its associated
 * Script and executing it.
 */
JztScriptContext.prototype.executeTick = function () {

    var message,
        command,
        result;

    // If our owner has a message waiting...
    if (this.owner.messageQueue.length > 0) {

        // Grab our most recent message
        message = this.owner.messageQueue.shift();

        // If we were able to receive this message
        if (!this.owner.locked) {
            this.jumpToLabel(message);
        }

    }

    if (this.isRunning()) {

        // Fetch a new command
        command = this.script.getCommand(this.commandIndex);

        if (command) {

            result = command.execute(this.owner);

            // If the command doesn't modify the scroll, and there's scroll content...
            if (this.scrollContent.length > 0 && !command.modifiesScroll) {

                // It's time to show the scroll content
                this.displayScroll();

            }

            switch (result) {

            // Normal execution, advance line
            case undefined:
            case commands.CommandResult.NORMAL:
                this.advanceLine();
                this.doneTick();
                break;

            // Execute a second tick
            case commands.CommandResult.CONTINUE:
                this.advanceLine();
                this.executeTick();
                break;

            // Normal execution, assuming the counter is at the right location
            case commands.CommandResult.CONTINUE_AFTER_JUMP:

                // If we haven't jumped too many times already, go ahead
                // Otherwise, we're done for this tick.
                if (this.jumpCount <= 5) {
                    this.executeTick();
                } else {
                    this.doneTick();
                }
                break;

            // Execute the same command next tick
            case commands.CommandResult.REPEAT:
                this.doneTick();
                break;

            default:
                throw 'Unexpected command execution.';
            }

        }

    }

};

/**
 * Indicates that this script is done executing for this tick.
 */
JztScriptContext.prototype.doneTick = function () {
    this.jumpCount = 0;
};

/**
 * Updates the active command of this JztScriptContext to that of a provided label
 * name.
 *
 * @param label A name of a label to which to jump.
 */
JztScriptContext.prototype.jumpToLabel = function (label) {

    if (this.currentLabels.hasOwnProperty(label)) {

        var labelIndex = this.currentLabels[label],
            labelIndicies = this.script.labelIndicies[label];

        // If all labels aren't zapped...
        if (labelIndex < labelIndicies.length) {

            // We're about to jump successfully, so clear out temporary heap items
            this.clearTemporaryHeapItems();

            // Set our current line to the active label index
            this.commandIndex = labelIndicies[labelIndex];

            // Increment our jump count for this tick
            this.jumpCount += 1;

        }

    }

};

JztScriptContext.prototype.clearTemporaryHeapItems = function () {
    var heapItem;
    for (heapItem in this.heap) {
        if (this.heap.hasOwnProperty(heapItem) && heapItem[0] === '<' && heapItem[heapItem.length - 1] === '>') {
            delete this.heap[heapItem];
        }
    }
};

/**
 * Zaps a provided label name, making it no longer jumpable. If more than one
 * label with the same name exists, only the first will be zapped. Subsequent
 * zaps will zap the next unzapped label.
 *
 * @param label A name of a label to zap.
 */
JztScriptContext.prototype.zapLabel = function (label) {

    var labelIndex;

    if (this.currentLabels.hasOwnProperty(label)) {
        labelIndex = this.currentLabels[label];
        if (labelIndex + 1 <= this.script.labelIndicies[label].length) {
            this.currentLabels[label] += 1;
        }
    }

};

/**
 * Restores a previously zapped label, making it resumable for jupming. If more than
 * one label with the same name has been zapped, the most recently zapped label will
 * be unzapped.
 *
 * @param label A name of a label to restore.
 */
JztScriptContext.prototype.restoreLabel = function (label) {

    var labelIndex;

    if (this.currentLabels.hasOwnProperty(label)) {
        labelIndex = this.currentLabels[label];
        if (labelIndex - 1 >= 0) {
            this.currentLabels[label] -= 1;
        }
    }

};

/**
 * Advances this JztScriptContext by one line, preparing a new command to be executed
 * at the next tick event.
 */
JztScriptContext.prototype.advanceLine = function () {
    if (this.isRunning()) {
        this.commandIndex += 1;
    }
};

exports.JztScriptContext = JztScriptContext;

},{"./game-state":4,"./jzt-script-commands":7}],9:[function(_dereq_,module,exports){
/**
 * JZTScript
 * Copyright Â© 2014 Orangeline Interactive, Inc.
 * @author Mark McIntyre
 */

/*jslint node: true */

'use strict';

var Literal = _dereq_('./parser').Literal,
    Alternation = _dereq_('./parser').Alternation,
    Empty = _dereq_('./parser').Empty,
    Sequence = _dereq_('./parser').Sequence,
    Repetition = _dereq_('./parser').Repetition,
    ParserNumber = _dereq_('./parser').Number,
    Word = _dereq_('./parser').Word,
    NewLine = _dereq_('./parser').NewLine,
    Assembly = _dereq_('./parser').Assembly,
    ParserString = _dereq_('./parser').String,
    Lexer = _dereq_('./lexer').Lexer,
    commands = _dereq_('./jzt-script-commands'),
    Colors = _dereq_('./graphics').Colors,
    ConstructorError = _dereq_('./basic').ConstructorError,
    serializeColor = _dereq_('./graphics').serialize;

/**
 * JztScriptParser
 */
function JztScriptParser(validateOnly) {

    if (!(this instanceof JztScriptParser)) {
        throw ConstructorError;
    }

    function popAllTokensUntil(assembly, tokenName, tokenValue, discardFence) {

        var result = [],
            top = assembly.peek();

        function matches(token, tokenName, tokenValue) {
            return token && token.name === tokenName.toUpperCase() && token.value && token.value.toUpperCase() === tokenValue.toUpperCase();
        }

        while (!matches(top, tokenName, tokenValue)) {
            result.unshift(assembly.pop());
            top = assembly.peek();
        }

        if (matches(top, tokenName, tokenValue) && discardFence) {
            assembly.pop();
        }

        return result;

    }

    function choice(parserOne, parserTwo) {
        var result = new Alternation();
        result.add(parserOne);
        result.add(parserTwo);
        return result;
    }

    function optional(parser) {
        return choice(parser, new Empty());
    }

    /**
     * Creates an Assembler object with a provided assemble function
     * definition if validateOnly is not set.
     */
    function createAssembler(assemblerFunction) {
        return validateOnly ? undefined : {
            assemble: assemblerFunction
        };
    }

    /**
     * Direction Modifier Parser
     * Creates and returns a 'direction modifier' parser.
     * @return A 'direction modifier' parser.
     */
    function createDirectionModifierParser() {
        var directionModifier = new Alternation();

        // Add direction modifier options
        directionModifier.add(new Literal('CW'));
        directionModifier.add(new Literal('CCW'));
        directionModifier.add(new Literal('OPP'));
        directionModifier.add(new Literal('RNDP'));

        // Create assembler
        directionModifier.assembler = createAssembler(function (assembly) {
            assembly.push(commands.DirectionModifier[assembly.pop().value.toUpperCase()]);
        });

        return directionModifier;
    }

    /**
     * Direction Terminal Parser
     * Creates and returns a 'direction terminal' parser.
     * @return A 'direction terminal' parser.
     */
    function createDirectionTerminalParser() {
        var directionTerminal = new Alternation();

        // Add direction terminal options
        // Future Improvement: Can we get this from basic.js?
        directionTerminal.add(new Literal('SEEK'));
        directionTerminal.add(new Literal('SMART'));
        directionTerminal.add(new Literal('FLOW'));
        directionTerminal.add(new Literal('RAND'));
        directionTerminal.add(new Literal('RANDF'));
        directionTerminal.add(new Literal('RANDB'));
        directionTerminal.add(new Literal('RNDEW'));
        directionTerminal.add(new Literal('RNDNS'));
        directionTerminal.add(new Literal('RNDNE'));
        directionTerminal.add(new Literal('NORTH'));
        directionTerminal.add(new Literal('EAST'));
        directionTerminal.add(new Literal('SOUTH'));
        directionTerminal.add(new Literal('WEST'));
        directionTerminal.add(new Literal('N'));
        directionTerminal.add(new Literal('E'));
        directionTerminal.add(new Literal('S'));
        directionTerminal.add(new Literal('W'));

        // Create assembler
        directionTerminal.assembler = createAssembler(function (assembly) {
            assembly.push(commands.Direction[assembly.pop().value.toUpperCase()]);
        });

        return directionTerminal;
    }

    /**
     * Direction Parser
     * Creates and returns a 'direction' parser.
     * @return A 'direction' parser.
     */
    function createDirectionParser() {
        var direction = new Sequence(),
            modifiers = new Repetition(createDirectionModifierParser());
        direction.add(modifiers);
        direction.add(createDirectionTerminalParser());

        // Add assembler
        direction.assembler = createAssembler(function (assembly) {

            var directionExpression = new commands.DirectionExpression(assembly.pop());

            while (assembly.peek() && assembly.peek().type === 'modifier') {
                directionExpression.modifiers.unshift(assembly.pop());
            }

            assembly.push(directionExpression);

        });

        return direction;
    }

    /**
     * Countable Direction Parser
     * Creates and returns a 'countable direction' parser.
     * @return A 'countable direction' parser.
     */
    function createCountableDirectionParser() {
        var direction = new Sequence();
        direction.add(createDirectionParser());
        direction.add(new ParserNumber());
        direction.assembler = createAssembler(function (assembly) {
            var count = assembly.pop().value;
            assembly.peek().count = count;
        });
        return direction;
    }

    /**
     * Color Parser
     * Creates and returns a 'color' parser.
     * @return A 'color' parser.
     */
    function createColorParser() {
        var color = new Alternation();

        // Add alternation values
        color.add(new Literal('Black'));
        color.add(new Literal('Blue'));
        color.add(new Literal('Green'));
        color.add(new Literal('Cyan'));
        color.add(new Literal('Red'));
        color.add(new Literal('Magenta'));
        color.add(new Literal('Brown'));
        color.add(new Literal('White'));
        color.add(new Literal('Grey'));
        color.add(new Literal('BrightBlue'));
        color.add(new Literal('BrightGreen'));
        color.add(new Literal('BrightCyan'));
        color.add(new Literal('BrightRed'));
        color.add(new Literal('BrightMagenta'));
        color.add(new Literal('Yellow'));
        color.add(new Literal('BrightWhite'));

        // Define assembler
        color.assembler = validateOnly ? undefined : {
            assemble: function (assembly) {
                assembly.push(Colors[assembly.pop().value.toUpperCase()]);
            }
        };

        return color;
    }

    /**
     * Thing parser
     * Creates and returns a 'thing' parser.
     * @return A 'thing' parser.
     */
    function createThingParser() {
        var thing = new Alternation();

        // Add alternation values
        // Future Improvement: Can we get these from things directly?
        thing.add(new Literal('Empty'));
        thing.add(new Literal('ActiveBomb'));
        thing.add(new Literal('Ammo'));
        thing.add(new Literal('Bear'));
        thing.add(new Literal('Blinker'));
        thing.add(new Literal('BlinkWall'));
        thing.add(new Literal('Bomb'));
        thing.add(new Literal('Boulder'));
        thing.add(new Literal('BreakableWall'));
        thing.add(new Literal('Bullet'));
        thing.add(new Literal('Centipede'));
        thing.add(new Literal('Conveyor'));
        thing.add(new Literal('Door'));
        thing.add(new Literal('Duplicator'));
        thing.add(new Literal('Explosion'));
        thing.add(new Literal('FakeWall'));
        thing.add(new Literal('Forest'));
        thing.add(new Literal('Gem'));
        thing.add(new Literal('Heart'));
        thing.add(new Literal('InvisibleWall'));
        thing.add(new Literal('Key'));
        thing.add(new Literal('Lava'));
        thing.add(new Literal('LineWall'));
        thing.add(new Literal('Lion'));
        thing.add(new Literal('Passage'));
        thing.add(new Literal('Player'));
        thing.add(new Literal('Pusher'));
        thing.add(new Literal('Ricochet'));
        thing.add(new Literal('River'));
        thing.add(new Literal('Ruffian'));
        thing.add(new Literal('Signpost'));
        thing.add(new Literal('SliderEw'));
        thing.add(new Literal('SliderNs'));
        thing.add(new Literal('Snake'));
        thing.add(new Literal('SolidWall'));
        thing.add(new Literal('Spider'));
        thing.add(new Literal('SpiderWeb'));
        thing.add(new Literal('SpinningGun'));
        thing.add(new Literal('Teleporter'));
        thing.add(new Literal('Text'));
        thing.add(new Literal('ThrowingStar'));
        thing.add(new Literal('Tiger'));
        thing.add(new Literal('Torch'));
        thing.add(new Literal('Wall'));
        thing.add(new Literal('Water'));

        // Define assembler
        thing.assembler = validateOnly ? undefined : {
            assemble: function (assembly) {
                assembly.push({
                    type: assembly.pop().value.toUpperCase()
                });
            }
        };

        return thing;
    }

    /**
     * Colorful Thing Parser
     * Creates and returns a 'colorful thing' parser.
     * @return A 'colorful thing' parser.
     */
    function createColorfulThingParser() {
        var colorfulThing = new Sequence();

        // Add sequence items
        colorfulThing.add(createColorParser());
        colorfulThing.add(createThingParser());

        // Define assembler
        colorfulThing.assembler = validateOnly ? undefined : {
            assemble: function (assembly) {
                var thing = assembly.pop();
                thing.color = serializeColor(undefined, assembly.pop());
                assembly.push(thing);
            }
        };

        return colorfulThing;
    }

    /**
     * Not Expression Parser
     * Creates and returns a Not expression parser.
     * @return A not expression parser.
     */
    function createNotExpressionParser(expressionParser) {
        var notExpression = new Sequence();

        // Add not expression parser elements
        notExpression.addDiscard(new Literal('Not'));
        notExpression.add(expressionParser);

        // Define assembler
        notExpression.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.NotExpression(assembly.pop()));
        });

        return notExpression;
    }

    /**
     * Adjacent Expression Parser
     * Creates and returns an adjacent expression parser
     * @return An adjacent expression parser
     */
    function createAdjacentExpressionParser() {
        var adjacentExpression = new Literal('Adjacent');
        adjacentExpression.discard = true;
        adjacentExpression.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.AdjacentExpression());
        });
        return adjacentExpression;
    }

    /**
     * Blocked Expression Parser
     * Creates and returns a blocked expression parser
     * @return A blocked expression parser
     */
    function createBlockedExpressionParser() {
        var blockedExpression = new Sequence();
        blockedExpression.addDiscard(new Literal('Blocked'));
        blockedExpression.add(createDirectionParser());
        blockedExpression.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.BlockedExpression(assembly.pop()));
        });
        return blockedExpression;
    }

    /**
     * Aligned Expression Parser
     * Creates and returns an aligned expression parser.
     * @return An aligned expression parser.
     */
    function createAlignedExpressionParser() {
        var alignedExpression = new Sequence();
        alignedExpression.addDiscard(new Literal('Aligned'));
        alignedExpression.add(createDirectionParser());
        alignedExpression.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.AlignedExpression(assembly.pop()));
        });
        return alignedExpression;
    }

    /**
     * Peep Expression Parser
     * Creates and returns a peep expression parser.
     * @return A peep expression parser
     */
    function createPeepExpressionParser() {
        var peepExpression = new Sequence();
        peepExpression.addDiscard(new Literal('Peep'));
        peepExpression.add(optional(new ParserNumber()));
        peepExpression.assembler = createAssembler(function (assembly) {
            var count = assembly.peek() && assembly.peek().name === 'NUMBER' ? assembly.pop().value : undefined;
            assembly.push(new commands.PeepExpression(count));
        });
        return peepExpression;
    }

    /**
     * Exists Expression Parser
     * Creates and returns an exists expression parser.
     * @return An exists expression parser.
     */
    function createExistsExpressionParser() {
        var existsExpression = new Sequence();
        existsExpression.addDiscard(new Literal('Exists'));
        existsExpression.add(optional(new ParserNumber()));
        existsExpression.add(choice(createThingParser(), createColorfulThingParser()));
        existsExpression.assembler = createAssembler(function (assembly) {
            var thingTemplate = assembly.pop(),
                count = assembly.peek() && assembly.peek().name === 'NUMBER' ? assembly.pop().value : undefined;
            assembly.push(new commands.ExistsExpression(thingTemplate, count));
        });
        return existsExpression;
    }

    /**
     * Testing Expression Parser
     * Creates and returns a testing expression parser.
     * @return A testing expression parser.
     */
    function createTestingExpressionParser() {
        var testingExpression = new Sequence(),
            operator = new Alternation();
        operator.add(new Literal('<'));
        operator.add(new Literal('<='));
        operator.add(new Literal('>'));
        operator.add(new Literal('>='));
        operator.add(new Literal('='));
        testingExpression.add(new Word());
        testingExpression.add(operator);
        testingExpression.add(new ParserNumber());
        testingExpression.assembler = createAssembler(function (assembly) {
            var value = assembly.pop().value,
                operand = assembly.pop().value,
                counter = assembly.pop().value.toUpperCase();
            assembly.push(new commands.TestingExpression(counter, operand, value));
        });
        return testingExpression;
    }

    /**
     * Expression Parser
     * Creates and returns an expression parser.
     * @return An expression parser.
     */
    function createExpressionParser() {
        var expression = new Alternation();
        expression.add(createNotExpressionParser(expression));
        expression.add(createAdjacentExpressionParser());
        expression.add(createBlockedExpressionParser());
        expression.add(createAlignedExpressionParser());
        expression.add(createPeepExpressionParser());
        expression.add(createExistsExpressionParser());
        expression.add(createTestingExpressionParser());
        return expression;
    }

    /**
     * Label Parser
     * Creates and returns a new label parser
     * @return A label parser.
     */
    function createLabelParser() {
        var label = new Sequence();

        // Add sequence items
        label.addDiscard(new Literal(':'));
        label.add(new Word());
        label.addDiscard(new NewLine());

        // Define assembler
        label.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.Label(assembly.pop().value.toUpperCase()));
        });

        return label;
    }

    /**
     * Become Statement Parser
     * Creates and returns a new 'become' statement parser
     * @return A 'become' statement parser.
     */
    function createBecomeStatementParser() {
        var become = new Sequence();

        // Add sequence tokens
        become.addDiscard(new Literal('Become'));
        become.add(choice(createColorfulThingParser(), createThingParser()));

        // Define assembler
        become.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.BecomeCommand(assembly.pop()));
        });

        return become;
    }

    /**
     * Change Statement Parser
     * Creates and returns a new 'change' statement parser
     * @return A 'change' statement parser
     */
    function createChangeStatementParser() {
        var change = new Sequence();

        // Add sequence tokens
        change.addDiscard(new Literal('Change'));
        change.add(choice(createColorfulThingParser(), createThingParser()));
        change.add(choice(createColorfulThingParser(), createThingParser()));

        // Define assembler
        change.assembler = createAssembler(function (assembly) {
            var toTemplate = assembly.pop();
            assembly.push(new commands.ChangeCommand(assembly.pop(), toTemplate));
        });

        return change;
    }

    /**
     * Char Statement Parser
     * Creates and returns a new 'char' statement parser.
     * @return A 'char' statement parser
     */
    function createCharStatementParser() {
        var char = new Sequence();

        // Add sequence tokens
        char.addDiscard(new Literal('Char'));
        char.add(new ParserNumber());

        // Define assembler
        char.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.CharCommand(assembly.pop().value));
        });

        return char;
    }

    /**
     * Die Statement Parser
     * Creates and returns a new 'die' statement parser.
     * @return A 'die' statement parser.
     */
    function createDieStatementParser() {
        var die = new Sequence();

        // Add sequence tokens
        die.addDiscard(new Literal('Die'));
        die.add(optional(new Literal('Magnetically')));

        // Define assembler
        die.assembler = createAssembler(function (assembly) {
            var nextToken = assembly.peek();
            if (nextToken && nextToken.name === 'WORD' && nextToken.value.toUpperCase() === 'MAGNETICALLY') {
                assembly.pop();
                assembly.push(new commands.DieCommand(true));
            } else {
                assembly.push(new commands.DieCommand());
            }
        });

        return die;
    }

    /**
     * End Statement Parser
     * Creates and returns a new 'end' statement parser.
     * @return A 'end' statement parser
     */
    function createEndStatementParser() {
        var endStatement = new Literal('End');

        // Add sequence tokens
        endStatement.discard = true;

        // Define assembler
        endStatement.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.EndCommand());
        });

        return endStatement;
    }

    /**
     * Go Statement Parser
     *
     * Creates and returns a new 'go' statement parser.
     * @param {string} [alias] - An optional alias to use for the parser instead of GO
     * @param {boolean} [forceful] - Whether or not this parser should result in a forceful move command
     * @returns {object} - A 'go' statement parser.
     */
    function createGoStatementParser(alias, forceful) {

        var go = new Sequence(),
            subsequentDirections = new Sequence(),
            direction = choice(createDirectionParser(), createCountableDirectionParser());

        // Forceful defaults to true
        forceful = forceful === undefined ? true : forceful;

        subsequentDirections.addDiscard(new Literal(','));
        subsequentDirections.add(direction);

        // Add sequence tokens
        go.add(new Literal(alias || 'Go'));
        go.add(direction);
        go.add(new Repetition(subsequentDirections));

        // Define assembler
        go.assembler = createAssembler(function (assembly) {

            var index,
                expression,
                expressions = popAllTokensUntil(assembly, 'WORD', alias || 'GO', true);

            for (index = 0; index < expressions.length; index += 1) {
                expression = expressions[index];
                assembly.push(new commands.MoveCommand(expression, forceful));
            }

        });

        return go;

    }

    /**
     * Give Statement Parser
     * Creates and returns a new 'give' statement parser.
     * @return A 'give' statement parser
     */
    function createGiveStatementParser() {
        var give = new Sequence();

        // Add sequence tokens
        give.addDiscard(new Literal('Give'));
        give.add(new ParserNumber());
        give.add(new Word());

        // Define assembler
        give.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.GiveCommand(assembly.pop().value, assembly.pop().value));
        });

        return give;
    }

    /**
     * If Statement Parser
     * Creates and returns a new 'if' statement parser
     * @return An 'if' statement parser
     */
    function createIfStatementParser() {
        var ifStatement = new Sequence();

        // Add sequence tokens
        ifStatement.addDiscard(new Literal('If'));
        ifStatement.add(createExpressionParser());
        ifStatement.add(new Word());

        // Define assembler
        ifStatement.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.IfCommand(assembly.pop().value.toUpperCase(), assembly.pop()));
        });

        return ifStatement;
    }

    /**
     * Lock Statement Parser
     * Creates and returns a new 'lock' statment parser.
     * @return A 'lock' statement parser.
     */
    function createLockStatementParser() {

        // Create lock parser
        var lock = new Literal('Lock');
        lock.discard = true;

        // Define assembler
        lock.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.LockCommand());
        });

        return lock;
    }

    /**
     * Play Statement Parser
     * Creates and returns a new 'play' statement paser.
     * @return A 'play' statement parser.
     */
    function createPlayStatementParser() {
        var play = new Sequence();

        // Add play items
        play.addDiscard(new Literal('Play'));
        play.add(new ParserString());

        // Define assembler
        play.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.PlayCommand(assembly.pop().value));
        });

        return play;
    }

    /**
     * Put Statement Parser
     * Creates and returns a new 'put' statement parser.
     * @return A 'put' statement paser.
     */
    function createPutStatementParser() {
        var put = new Sequence();

        // Add put items
        put.addDiscard(new Literal('Put'));
        put.add(createDirectionParser());
        put.add(choice(createThingParser(), createColorfulThingParser()));

        // Define assembler
        put.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.PutCommand(assembly.pop(), assembly.pop()));
        });

        return put;
    }

    /**
     * Scroll Statement Parser
     * Creates and returns a 'scroll' statement paser.
     * @return A 'scroll' statment paser.
     */
    function createScrollStatementParser() {
        var scroll = new Sequence();

        // Add scroll sequence items
        scroll.addDiscard(new Literal('Scroll'));
        scroll.add(optional(new Literal('Bold')));
        scroll.add(new ParserString());
        scroll.add(optional(new Word()));

        // Define assembler
        scroll.assembler = createAssembler(function (assembly) {
            var jumpLabel = assembly.peek().name === 'WORD' ? assembly.pop().value.toUpperCase() : undefined,
                text = assembly.pop().value,
                boldOption = assembly.peek() && assembly.peek().name === 'WORD' && assembly.peek().value.toUpperCase() === 'BOLD' ? assembly.pop() : false;
            assembly.push(new commands.ScrollCommand(text, !!boldOption, jumpLabel));
        });

        return scroll;
    }

    /**
     * Send Statement Parser
     * Creates and returns a 'send' statement parser
     * @return A 'send' statement paser.
     */
    function createSendStatementParser() {
        var send = new Sequence();

        // Add send sequence items
        send.add(new Literal('Send'));
        send.add(optional(new Word()));
        send.add(new Word());

        // Define assembler
        send.assembler = createAssembler(function (assembly) {
            var parameters = popAllTokensUntil(assembly, 'WORD', 'SEND', true),
                label = parameters.pop().value.toUpperCase(),
                recipient = parameters.length > 0 ? parameters.pop().value.toUpperCase() : 'SELF';
            assembly.push(new commands.SendCommand(recipient, label));
        });

        return send;
    }

    /**
     * Set Statement Parser
     * Creates and returns a 'set' statement paser
     * @return A 'set' statement parser.
     */
    function createSetStatementParser() {
        var set = new Sequence();

        // Add set sequence items
        set.addDiscard(new Literal('Set'));
        set.add(optional(new ParserNumber()));
        set.add(new Word());

        // Define assembler
        set.assembler = createAssembler(function (assembly) {
            var counter = assembly.pop().value.toUpperCase(),
                value = assembly.peek() && assembly.peek().name === 'NUMBER' ? assembly.pop().value : 1;
            assembly.push(new commands.SetCommand(counter, value));
        });

        return set;
    }

    /**
     * Take Statement Parser
     * Creates and returns a 'take' statement parser.
     * @return A 'take' statement parser.
     */
    function createTakeStatementParser() {
        var take = new Sequence();

        // Add take sequence items
        take.addDiscard(new Literal('Take'));
        take.add(new ParserNumber());
        take.add(new Word());
        take.add(optional(new Word()));

        // Define assembler
        take.assembler = createAssembler(function (assembly) {
            var token1 = assembly.pop().value.toUpperCase(),
                token2 = assembly.peek().name === 'WORD' ? assembly.pop().value.toUpperCase() : undefined,
                count = +(assembly.pop().value);
            assembly.push(new commands.TakeCommand(token2 || token1, count, token2 ? token1 : undefined));
        });

        return take;
    }

    /**
     * ThrowStar Statement Parser
     * Creates and returns a 'throwstar' statement parser.
     * @return A 'throwstar' statment parser.
     */
    function createThrowStarStatementParser() {
        var throwStar = new Sequence();

        // Add throwstar sequence items
        throwStar.addDiscard(new Literal('ThrowStar'));
        throwStar.add(createDirectionParser());

        // Define assembler
        throwStar.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.ThrowStarCommand(assembly.pop()));
        });

        return throwStar;
    }

    /**
     * Torch Statement Parser
     * Creates and returns a 'torch' statement parser.
     * @return A 'torch' statement parser.
     */
    function createTorchStatementParser() {
        var torch = new Sequence();

        // Add torch sequence items
        torch.addDiscard(new Literal('Torch'));
        torch.add(optional(new ParserNumber()));

        // Define assembler
        torch.assembler = createAssembler(function (assembly) {
            var radius = assembly.peek() && assembly.peek().name === 'NUMBER' ? assembly.pop().value : 0;
            assembly.push(new commands.TorchCommand(radius));
        });

        return torch;
    }

    /**
     * Restore Statement Parser
     * Creates and returns a 'restore' statement parser.
     * @return A 'restore' statement parser.
     */
    function createRestoreStatementParser() {
        var restore = new Sequence();

        // Add restore sequence items
        restore.addDiscard(new Literal('Restore'));
        restore.add(new Word());

        // Define assembler
        restore.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.RestoreCommand(assembly.pop().value.toUpperCase()));
        });

        return restore;
    }

    /**
     * Say Statement Parser
     * Creates and returns a 'say' statement parser.
     * @return A 'say' statement parser.
     */
    function createSayStatementParser() {
        var say = new Sequence();

        // Add say sequence items
        say.addDiscard(new Literal('Say'));
        say.add(new ParserString());

        // Define assembler
        say.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.SayCommand(assembly.pop().value));
        });

        return say;
    }

    /**
     * Shoot Statement Parser
     * Creates and returns a 'shoot' statement parser.
     * @return A 'shoot' statement parser.
     */
    function createShootStatementParser() {
        var shoot = new Sequence();

        // Add shoot sequence items
        shoot.addDiscard(new Literal('Shoot'));
        shoot.add(createDirectionParser());

        // Define assembler
        shoot.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.ShootCommand(assembly.pop()));
        });

        return shoot;
    }

    /**
     * Stand Statement Parser
     * Creates and returns a 'stand' statement parser.
     * @return A 'stand' statement parser.
     */
    function createStandStatementParser() {
        var stand = new Literal('Stand');
        stand.discard = true;
        stand.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.StandCommand());
        });
        return stand;
    }

    /**
     * Unlock Statement Parser
     * Creates and returns an 'unlock' statement parser.
     * @return An 'unlock' statement parser.
     */
    function createUnlockStatementParser() {
        var unlock = new Literal('Unlock');
        unlock.discard = true;
        unlock.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.UnlockCommand());
        });
        return unlock;
    }

    /**
     * Victory Statement Parser
     * Creates and returns a 'victory' statement parser.
     * @return A 'victory' statement parser.
     */
    function createVictoryStatementParser() {
        var victory = new Literal('Victory');
        victory.discard = true;
        victory.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.VictoryCommand());
        });
        return victory;
    }

    /**
     * Wait Statement Parser
     * Creates and returns a 'wait' statement parser.
     * @return A 'wait' statement parser.
     */
    function createWaitStatementParser() {
        var wait = new Sequence();

        // Add wait sequence items
        wait.addDiscard(new Literal('Wait'));
        wait.add(optional(new ParserNumber()));

        // Define assembler
        wait.assembler = createAssembler(function (assembly) {
            var cycles = assembly.peek() && assembly.peek().name === 'NUMBER' ? assembly.pop().value : undefined;
            assembly.push(new commands.WaitCommand(cycles));
        });
        return wait;
    }

    /**
     * Walk Statement Parser
     * Creates and returns a 'walk' statement parser.
     * @return A 'walk' statement parser.
     */
    function createWalkStatementParser() {
        var walk = new Sequence();
        walk.addDiscard(new Literal('Walk'));
        walk.add(createDirectionParser());
        walk.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.WalkCommand(assembly.pop()));
        });
        return walk;
    }

    /**
     * Zap Statement Parser
     * Creates and returns a 'zap' statement parser.
     * @return A 'zap' statement parser.
     */
    function createZapStatementParser() {
        var zap = new Sequence();
        zap.addDiscard(new Literal('Zap'));
        zap.add(new Word());
        zap.assembler = createAssembler(function (assembly) {
            assembly.push(new commands.ZapCommand(assembly.pop().value.toUpperCase()));
        });
        return zap;
    }

    /**
     * Statement Parser
     * Creates and returns a new statement parser.
     * @return A statement parser.
     */
    function createStatementParser() {
        var statement = new Sequence(),
            statementOptions = new Alternation();

        // Add statement items
        statementOptions.add(createBecomeStatementParser());
        statementOptions.add(createChangeStatementParser());
        statementOptions.add(createCharStatementParser());
        statementOptions.add(createDieStatementParser());
        statementOptions.add(createEndStatementParser());
        statementOptions.add(createGoStatementParser());
        statementOptions.add(createGiveStatementParser());
        statementOptions.add(createIfStatementParser());
        statementOptions.add(createLockStatementParser());
        statementOptions.add(createPlayStatementParser());
        statementOptions.add(createPutStatementParser());
        statementOptions.add(createScrollStatementParser());
        statementOptions.add(createSendStatementParser());
        statementOptions.add(createSetStatementParser());
        statementOptions.add(createTakeStatementParser());
        statementOptions.add(createThrowStarStatementParser());
        statementOptions.add(createTorchStatementParser());
        statementOptions.add(createGoStatementParser('Try', false));
        statementOptions.add(createRestoreStatementParser());
        statementOptions.add(createSayStatementParser());
        statementOptions.add(createShootStatementParser());
        statementOptions.add(createStandStatementParser());
        statementOptions.add(createUnlockStatementParser());
        statementOptions.add(createVictoryStatementParser());
        statementOptions.add(createWaitStatementParser());
        statementOptions.add(createWalkStatementParser());
        statementOptions.add(createZapStatementParser());
        statement.add(statementOptions);
        statement.addDiscard(new NewLine());

        return statement;
    }

    /**
     * JztScript Parser
     * Creates and returns a new JztScript parser.
     * @return A JZT script parser.
     */
    function createJztScriptParser() {

        var program,
            line = new Alternation();
        line.add(createLabelParser());
        line.add(createStatementParser());
        line.addDiscard(new NewLine());
        program = new Repetition(line);
        return program;

    }

    this.parser = createJztScriptParser();

}

JztScriptParser.prototype.parse = function (script) {

    var lexer,
        tokens,
        assembly,
        result;

    // If our script doesn't already end in a newline, add it now
    if (script.charAt(script.length - 1) !== '\n') {
        script += '\n';
    }

    lexer = new Lexer(script);
    tokens = lexer.tokenizeAll();
    assembly = new Assembly(tokens);
    result = this.parser.completeMatch(assembly);

    if (result === undefined) {
        throw 'Catestrophic script error. No result.';
    }

    return result.stack;

};

exports.JztScriptParser = JztScriptParser;

},{"./basic":1,"./graphics":5,"./jzt-script-commands":7,"./lexer":11,"./parser":12}],10:[function(_dereq_,module,exports){
/**
 * JZTScript
 * Copyright Â© 2014 Orangeline Interactive, Inc.
 * @author Mark McIntyre
 */

/*jslint node:true */

'use strict';

var commands = _dereq_('./jzt-script-commands'),
    JztScriptParser = _dereq_('./jzt-script-parser').JztScriptParser,
    scriptParser = new JztScriptParser(),
    ConstructorError = _dereq_('./basic').ConstructorError,
    GameState = _dereq_('./game-state').GameState;

/**
 * JztScript
 */
function JztScript(name, rawScript, compileImmediately) {

    if (!(this instanceof JztScript)) {
        throw ConstructorError;
    }

    this.name = name;
    this.rawScript = rawScript;
    this.labelIndicies = {};
    this.commands = [];

    if (compileImmediately) {
        this.compile();
    }

}

JztScript.prototype.compile = function () {

    var index,
        element,
        commandStack = scriptParser.parse(this.rawScript);

    /**
     * Adds a provided label to this JztScript to be associated with a provided
     * command index.
     *
     * @param label A name of a label
     * @param commandIndex A numeric index
     */
    function addLabel(owner, label, commandIndex) {
        // If no command index was provided, use the current command position
        commandIndex = commandIndex === undefined ? owner.commands.length : commandIndex;

        // Have we seen this label before?
        if (owner.labelIndicies.hasOwnProperty(label.name)) {

            // The label already exists, so push the new label
            // to the stack
            owner.labelIndicies[label.name].push(commandIndex);

        } else {

            // We've got a new label
            owner.labelIndicies[label.name] = [commandIndex];

        }
    }

    // Put the commands into our target
    for (index = 0; index < commandStack.length; index += 1) {

        // Grab our next element
        element = commandStack[index];

        // What do we have, exactly?
        if (element instanceof commands.Label) {

            // It's a label. Add it.
            addLabel(this, element);

        } else if (typeof element.execute === 'function') {

            // We've got an executable item
            this.commands.push(element);

        } else {

            // We've got something else. Something... unexpected!
            throw 'Catestrophic script error. Unexpected object in command stack.';

        }

    }

};

JztScript.prototype.getCommand = function (index) {
    return this.commands[index];
};

JztScript.prototype.serialize = function () {
    return {
        name: this.name,
        rawScript: this.rawScript
    };
};

exports.JztScript = JztScript;

},{"./basic":1,"./game-state":4,"./jzt-script-commands":7,"./jzt-script-parser":9}],11:[function(_dereq_,module,exports){
/**
 * JZT Lexer
 * Copyright Â© 2014 Orangeline Interactive, Inc.
 * @author Mark McIntyre
 */

/*jslint node:true */

'use strict';

var ConstructorError = _dereq_('./basic').ConstructorError;

function isNewLine(character) {
    return character === '\r' || character === '\n';
}

function isWhiteSpace(character) {
    return character === ' ' || character === '\t' || character === '\r';
}

function isAlpha(character) {
    return (character >= 'a' && character <= 'z') || (character >= 'A' && character <= 'Z') || character === '_';
}

function isNumeric(character) {
    return (character >= '0' && character <= '9');
}

function isAlphaNumeric(character) {
    return isAlpha(character) || isNumeric(character);
}

/**
 * Constructs a new Lexer instance
 * @param inputString Input text to be lexed
 * @param skipComments Whether or not to skip comments from the token stream (default is true)
 */
function Lexer(inputString, skipComments) {

    if (!(this instanceof Lexer)) {
        throw ConstructorError;
    }

    this.skipComments = skipComments !== undefined ? skipComments : true;
    this.setInput(inputString);

}

Lexer.prototype.setInput = function (inputString) {

    this.position = 0;
    this.buffer = inputString;
    this.bufferLength = this.buffer.length;
    this.line = 1;
    this.column = 1;

};

Lexer.prototype.tokenizeAll = function () {

    var result = [],
        token = this.nextToken();
    while (token) {
        result.push(token);
        token = this.nextToken();
    }

    return result;

};

/**
 * Retrieves the next token in our input stream and returns it. If no tokens are left,
 * undefined is returned.
 *
 * @return a next token or undefined
 */
Lexer.prototype.nextToken = function () {

    var c,
        token,
        next;

    // Consume non-tokens first
    this.consumeNonTokens();

    // If there is nothing left to return, exit without a return value
    if (this.position >= this.bufferLength) {
        return;
    }

    c = this.getCharacter();

    // Comment
    if (c === '/' && this.getCharacter(1) === '/') {
        token = this.createCommentToken();
        return this.skipComments ? this.nextToken() : token;
    }

    // String
    if (c === '"') {
        return this.createStringToken();
    }

    // Operator
    if (c === '<' || c === '>' || c === '=' || c === ':') {

        next = this.getCharacter(1);
        if (next === '=' && c !== '=') {
            return this.createToken('OPERATOR', c + next);
        }

        return this.createToken('OPERATOR', c);

    }

    // Punctuation
    if (c === ',') {
        return this.createToken('PUNCTUATION', c);
    }

    // New Line
    if (isNewLine(c)) {
        token = this.createToken('NEWLINE', '[New Line]', 1);
        this.column = 1;
        this.line += 1;
        return token;
    }

    // Number Token
    if (isNumeric(c)) {
        return this.createNumberToken();
    }

    // Word Token
    if (isAlpha(c)) {
        return this.createWordToken();
    }

    throw 'Unrecognized token on line ' + this.line + ', column ' + this.column;


};

/**
 * Gets a character from our input string with an optional offset.
 *
 * @param An optional numerical offset
 * @return a single character from our input string
 */
Lexer.prototype.getCharacter = function (offset) {

    var position = offset === undefined ? this.position : this.position + offset;
    if (position < 0 || position >= this.bufferLength) {
        return undefined;
    }
    return this.buffer.charAt(position);
};

/**
 * Creates a comment token
 */
Lexer.prototype.createCommentToken = function () {

    var token,
        endPosition;

    // The end position is our position plus the length of the comment characters
    endPosition = this.position + '//'.length;

    // Loop until the first new line
    while (endPosition < this.bufferLength && !isNewLine(this.buffer.charAt(endPosition))) {
        endPosition += 1;
    }

    // Create our token
    token = this.createToken('COMMENT', this.buffer.substring(this.position + '//'.length, endPosition), endPosition - this.position);

    // Return our token
    return token;

};

Lexer.prototype.createStringToken = function () {

    var token,
        c,
        result = '',
        endPosition;

    // The end position is our position plus the length of our string character
    endPosition = this.position + 1;

    // Loop until we get a non-escaped string terminal
    while (endPosition < this.bufferLength) {

        // Grab the next character
        c = this.buffer.charAt(endPosition);

        // Determine our next character sequence
        if (c === '\\' && this.buffer.charAt(endPosition + 1) === '"') {

            // We've encounterd an escaped quote
            result += '"';
            endPosition += 2;

        } else if (c === '\\' && this.buffer.charAt(endPosition + 1) === 'n') {

            // We've encountered an escaped newline
            result += '\n';
            endPosition += 2;

        } else {

            // If we encounter an end quote our string is over
            if (c === '"') {
                endPosition += 1;
                break;
            }

            // Newlines are invalid
            if (isNewLine(c)) {
                throw 'Unterminated string literal on line ' + this.line + ', column ' + this.column;
            }

            result += c;
            endPosition += 1;

        }

    }

    // Create our token
    token = this.createToken('STRING', result, endPosition - this.position);

    return token;

};

Lexer.prototype.createNumberToken = function () {

    var endPosition = this.position;
    while (endPosition < this.bufferLength && isNumeric(this.buffer.charAt(endPosition))) {
        endPosition += 1;
    }

    return this.createToken('NUMBER', +(this.buffer.substring(this.position, endPosition)), endPosition - this.position);

};

Lexer.prototype.createWordToken = function () {

    var endPosition = this.position;
    while (endPosition < this.bufferLength && isAlphaNumeric(this.buffer.charAt(endPosition))) {
        endPosition += 1;
    }

    return this.createToken('WORD', this.buffer.substring(this.position, endPosition));

};

/**
 * Consumes whitespace from our input string
 */
Lexer.prototype.consumeNonTokens = function () {

    // Loop through our characters...
    while (this.position < this.bufferLength) {

        if (!isWhiteSpace(this.getCharacter())) {
            return;
        }

        this.position += 1;
        this.column += 1;

    }

};

Lexer.prototype.createToken = function (name, value, realLength) {

    realLength = realLength === undefined ? value.length : realLength;

    var token = {
        name: name,
        value: value,
        line: this.line,
        column: this.column,
        position: this.position
    };

    this.position += realLength;
    this.column += realLength;

    return token;

};

exports.Lexer = Lexer;

},{"./basic":1}],12:[function(_dereq_,module,exports){
/**
 * JZT Parser
 * Copyright Â© 2014 Orangeline Interactive, Inc.
 * @author Mark McIntyre
 */

/*jslint node: true */

'use strict';

var ConstructorError = _dereq_('./basic').ConstructorError;

/*
 * Assembly
 */
function Assembly(tokens) {

    if (!(this instanceof Assembly)) {
        throw ConstructorError;
    }

    this.tokens = tokens;
    this.index = 0;
    this.stack = [];
    this.target = undefined;

}

Assembly.prototype.clone = function () {
    var result = new Assembly();
    result.tokens = this.tokens.slice(0);
    result.index = this.index;
    result.stack = this.stack.slice(0);
    result.target = this.target ? this.target.clone() : undefined;
    return result;
};

Assembly.prototype.current = function () {
    return this.tokens[this.index];
};

Assembly.prototype.peek = function () {
    return this.stack[this.stack.length - 1];
};

Assembly.prototype.pop = function () {
    return this.stack.pop();
};

Assembly.prototype.push = function (item) {
    this.stack.push(item);
};

Assembly.prototype.isDone = function () {
    return this.index >= this.tokens.length;
};

Assembly.prototype.next = function () {
    var result = this.tokens[this.index];
    this.index += 1;
    return result;
};

/*
 * Parser
 */
function Parser() {
    if (!(this instanceof Parser)) {
        throw ConstructorError;
    }
    this.assembler = undefined;
}

Parser.prototype.match = function () {
    return [];
};

Parser.prototype.bestMatch = function (assembly) {
    var result = this.matchAndAssemble([assembly]);
    return this.findBestAssembly(result);
};

Parser.prototype.completeMatch = function (assembly) {
    var result = this.bestMatch(assembly),
        token;
    if (result !== undefined && result.isDone()) {
        return result;
    }

    token = result.current();
    throw 'Unexpected token \'' + token.value + '\' on line ' + token.line + ', column ' + token.column;
};

Parser.prototype.matchAndAssemble = function (assemblies) {

    var result = this.match(assemblies),
        index;

    // If we've got an assembler, have it assemble
    if (this.assembler) {

        for (index = 0; index < result.length; index += 1) {
            this.assembler.assemble(result[index]);
        }
    }

    return result;

};

Parser.prototype.findBestAssembly = function (assemblies) {

    var bestAssembly,
        index,
        assembly;

    for (index = 0; index < assemblies.length; index += 1) {

        assembly = assemblies[index];

        if (!bestAssembly) {
            bestAssembly = assembly;
        } else if (assembly.index > bestAssembly.index) {
            bestAssembly = assembly;
        }
    }

    return bestAssembly;

};

Parser.prototype.cloneAssemblies = function (assemblies) {

    var result = [], index, assembly;

    for (index = 0; index < assemblies.length; index += 1) {
        assembly = assemblies[index];
        result.push(assembly.clone());
    }

    return result;

};

/*
 * Repetition
 */
function Repetition(subParser) {

    if (!(this instanceof Repetition)) {
        throw ConstructorError;
    }

    if (!subParser) {
        throw 'Subparser is required.';
    }
    this.subParser = subParser;
    this.assembler = undefined;
    this.preAssembler = undefined;
}
Repetition.prototype = new Parser();
Repetition.prototype.constructor = Repetition;

Repetition.prototype.match = function (assemblies) {

    var index, assembly, result;

    // If we have a preassember, assemble now
    if (this.preAssembler !== undefined) {
        for (index = 0; index < assemblies.length; index += 1) {
            assembly = assemblies[index];
            this.preAssembler.assemble(assembly);
        }
    }

    result = this.cloneAssemblies(assemblies);
    while (assemblies.length > 0) {
        assemblies = this.subParser.matchAndAssemble(assemblies);
        result = result.concat(assemblies);
    }

    return result;

};

/*
 * Empty
 */
function Empty() {
    if (!(this instanceof Empty)) {
        throw ConstructorError;
    }
    this.assembler = undefined;
}
Empty.prototype = new Parser();
Empty.prototype.constructor = Empty;

Empty.prototype.match = function (assemblies) {
    return this.cloneAssemblies(assemblies);
};

/*
 * CollectionParser
 */
function CollectionParser() {
    if (!(this instanceof CollectionParser)) {
        throw ConstructorError;
    }
    this.assembler = undefined;
    this.subParsers = [];
}
CollectionParser.prototype = new Parser();
CollectionParser.constructor = CollectionParser;

CollectionParser.prototype.add = function (subParser) {
    this.subParsers.push(subParser);
};

CollectionParser.prototype.addDiscard = function (subParser) {
    subParser.discard = true;
    this.subParsers.push(subParser);
};

/*
 * Sequence
 */
function Sequence() {
    if (!(this instanceof Sequence)) {
        throw ConstructorError;
    }
    this.assembler = undefined;
    this.subParsers = [];
}
Sequence.prototype = new CollectionParser();
Sequence.prototype.constructor = Sequence;

Sequence.prototype.match = function (assemblies) {

    var started = false,
        previousResult = assemblies,
        result = assemblies,
        index,
        subParser;

    for (index = 0; index < this.subParsers.length; index += 1) {

        subParser = this.subParsers[index];

        result = subParser.matchAndAssemble(result);
        if (result.length <= 0) {
            if (started) {
                this.determineTokenError(previousResult);
            }
            return result;
        }

        started = true;
        previousResult = result;

    }

    return result;

};

Sequence.prototype.determineTokenError = function (previousResult) {

    var best = this.findBestAssembly(previousResult),
        token;

    if (best.current() === undefined) {
        throw 'Token expected';
    }

    token = best.current();
    throw 'Unexpected token \'' + token.value + '\' on line ' + token.line + ', column ' + token.column;

};

/*
 * Alternation
 */
function Alternation() {
    if (!(this instanceof Alternation)) {
        throw ConstructorError;
    }
    this.assembler = undefined;
    this.subParsers = [];
}
Alternation.prototype = new CollectionParser();
Alternation.prototype.constructor = Alternation;

Alternation.prototype.match = function (assemblies) {

    var result = [],
        error,
        subParser,
        alternationResult,
        index;

    for (index = 0; index < this.subParsers.length; index += 1) {
        subParser = this.subParsers[index];
        try {
            alternationResult = subParser.matchAndAssemble(assemblies);
            result = result.concat(alternationResult);
        } catch (tokenError) {
            error = tokenError;
        }
    }

    if (result.length <= 0 && error !== undefined) {
        throw error;
    }

    return result;

};

/*
 * Terminal
 */
function Terminal() {
    if (!(this instanceof Terminal)) {
        throw ConstructorError;
    }
    this.assembler = undefined;
    this.discard = false;
}
Terminal.prototype = new Parser();
Terminal.prototype.constructor = Terminal;


Terminal.prototype.qualifies = function () {
    return true;
};

Terminal.prototype.match = function (assemblies) {

    var result = [], index, assembly, assemblyResult;

    for (index = 0; index < assemblies.length; index += 1) {
        assembly = assemblies[index];
        assemblyResult = this.matchAssembly(assembly);
        if (assemblyResult !== undefined) {
            result.push(assemblyResult);
        }
    }

    return result;

};

Terminal.prototype.matchAssembly = function (assembly) {

    var result,
        token;

    if (assembly.isDone()) {
        return undefined;
    }

    if (this.qualifies(assembly.current())) {

        result = assembly.clone();

        token = result.next();
        if (!this.discard) {
            result.stack.push(token);
        }
        return result;
    }

    return undefined;

};

/*
 *  Number
 */
function Number() {
    if (!(this instanceof Number)) {
        throw ConstructorError;
    }
    this.assembler = undefined;
    this.discard = false;
}
Number.prototype = new Terminal();

Number.prototype.qualifies = function (token) {
    return token.name === 'NUMBER' && !isNaN(token.value);
};

/*
 * Literal
 */
function Literal(literalValue, caseSensitive) {
    if (!(this instanceof Literal)) {
        throw ConstructorError;
    }
    this.assembler = undefined;
    this.caseSensitive = caseSensitive;
    this.literalValue = literalValue;
    this.discard = false;
    if (!caseSensitive) {
        this.literalValue = this.literalValue.toUpperCase();
    }

}
Literal.prototype = new Terminal();
Literal.prototype.constructor = Literal;

Literal.prototype.qualifies = function (token) {

    var value = token.value;

    if (typeof value === 'string' && !this.caseSensitive) {
        value = value.toUpperCase();
    }

    return this.literalValue === value;

};

/*
 * Word
 */
function Word() {
    if (!(this instanceof Word)) {
        throw ConstructorError;
    }
    this.assembler = undefined;
    this.discard = false;
}
Word.prototype = new Terminal();
Word.prototype.constructor = Word;
Word.prototype.qualifies = function (token) {

    if (token.name === 'WORD') {
        return isNaN(parseInt(token.value, 10));
    }

    return false;

};

/*
 * String
 */
function String() {
    if (!(this instanceof String)) {
        throw ConstructorError;
    }
    this.assembler = undefined;
    this.discard = false;
}
String.prototype = new Terminal();
String.prototype.constructor = String;
String.prototype.qualifies = function (token) {
    return token.name === 'STRING';
};

/*
 * NewLine
 */
function NewLine() {
    if (!(this instanceof NewLine)) {
        throw ConstructorError;
    }
    this.assembler = undefined;
    this.discard = false;
}
NewLine.prototype = new Terminal();
NewLine.prototype.constructor = NewLine;
NewLine.prototype.qualifies = function (token) {
    return token.name === 'NEWLINE';
};

exports.Alternation = Alternation;
exports.Assembly = Assembly;
exports.Parser = Parser;
exports.Repetition = Repetition;
exports.CollectionParser = CollectionParser;
exports.Sequence = Sequence;
exports.Empty = Empty;
exports.Terminal = Terminal;
exports.Literal = Literal;
exports.NewLine = NewLine;
exports.Number = Number;
exports.String = String;
exports.Word = Word;

},{"./basic":1}],13:[function(_dereq_,module,exports){
/**
 * JZT Things
 * Copyright Â© 2014 Orangeline Interactive, Inc.
 * @author Mark McIntyre
 */

/*jslint node: true */

'use strict';

var Point = _dereq_('./basic').Point,
    Colors = _dereq_('./graphics').Colors,
    CyclingColor = _dereq_('./graphics').CyclingColor,
    deserializeForeground = _dereq_('./graphics').deserializeForeground,
    deserializeBackground = _dereq_('./graphics').deserializeBackground,
    serializeColor = _dereq_('./graphics').serialize,
    utilities = _dereq_('./basic').utilities,
    Direction = _dereq_('./basic').Direction,
    GameState = _dereq_('./game-state').GameState,
    JztScriptContext = _dereq_('./jzt-script-context').JztScriptContext,
    DelayedEventScheduler = _dereq_('./basic').DelayedEventScheduler,
    i18n = _dereq_('./i18n'),
    ThingFactory = {},
    MOVE_ACTION = 0,
    SHOOT_ACTION = 1,
    TORCH_TTL = 60000,
    MAX_TORCH_STRENGTH = 4;

/**
 * Defines a thing by adding a property with its named construction function. Additionally
 * adds a 'type' property to the function so it can be serialized even after minification.
 */
exports.things = {};
function defineThing(name, thingFunction) {
    exports.things[name] = thingFunction;
    thingFunction.type = name;
}

/*
 * Thing represents a single 'thing' that can be associated with a Board. This can
 * range from players, to walls, to Scriptables. Each Thing has a location,
 * sprite index, and foreground and background color. Each Thing should also
 * be able to handle its own serialization and deserialization. Things may also
 * receive messages and take actions accordingly, either altering its own state
 * or making requests to its owner Board.
 *
 * @param board A Board instance to "own" this Thing.
 */
function Thing(board) {
    this.spriteIndex = 63;
    this.board = board;
    this.point = new Point(0, 0);
    this.foreground = Colors.Yellow;
    this.background = undefined;
    this.x = 0;
    this.y = 0;
    this.type = this.constructor.type;
}

/**
 * Serializes this Thing to an object and returns it.
 *
 * @return A serialized version of this Thing.
 */
Thing.prototype.serialize = function () {
    var result = {};
    result.type = this.constructor.type;
    result.color = serializeColor(this.background, this.foreground);
    if (this.under) {
        result.under = this.under.serialize();
    }
    return result;
};

/**
 * Deserializes a given data object and update's this Thing's state to
 * that data.
 *
 * @param data An object to be deserialized into this Thing.
 */
Thing.prototype.deserialize = function (data) {

    if (data.color) {
        this.foreground = deserializeForeground(data.color);
        this.background = deserializeBackground(data.color);
    } else {
        if (!this.foreground) {
            this.foreground = Colors.Yellow;
        }
        this.background = undefined;
    }

    if (data.under) {
        this.under = ThingFactory.deserialize(data.under, this.board);
    }

};

/**
 * Plays a given audio notation. This function is a convenient shorthand
 * for a full call chain.
 *
 * @param notation An audio notation to play.
 * @param uninterruptable Whether or not this notation can be interrupted by another.
 * @param defer If set, we do not even schedule our notation if another is already playing.
 */
Thing.prototype.play = function (notation, uninterruptable, defer) {

    /*
     * Deferring audio means we don't even attempt to play something if another
     * is already playing. This not only saves wasted time scheduling audio
     * that will be cancelled by a future sound, but also allows previously
     * triggered sounds to take priority even if that sound wasn't declared
     * uninterruptable.
     */
    if (!defer || !this.board.game.resources.audio.isPlaying()) {
        this.board.game.resources.audio.play(notation, uninterruptable);
    }

};

/**
 * Adjusts a game counter by a provided value offset. This offset may be
 * positive (to increase the counter), or negative (to decrease it).
 *
 * @param counter A name of a counter
 * @param value A value by which to adjust a counter
 */
Thing.prototype.adjustCounter = function (counter, value) {
    this.board.game.adjustCounter(counter, value);
};

Thing.prototype.setCounterValue = function (counter, value) {
    this.board.game.setCounterValue(counter, value);
};

Thing.prototype.getCounterValue = function (counter) {
    return this.board.game.getCounterValue(counter);
};

/**
 * Delivers a provided message to this Thing.
 *
 * @param messageName a name of a message to deliver.
 */
Thing.prototype.sendMessage = function () {
    return undefined;
};

/**
 * Receives a request to be pushed in a given direction.
 *
 * @param direction A direction in which this Thing is requested to move.
 * @param pusher A Thing that is requesting the push.
 * @return true if the push resulted in a teleportation, undefined otherwise.
 */
Thing.prototype.push = function () {
    return undefined;
};

/**
 * Returns whether or not this Thing declares itself to be surrenderable to
 * a given sender.
 *
 * A Thing that is surrenderable will allow another Thing to occupy its
 * space on a board and will agree to be 'under' that Thing.
 *
 * @param sender A Thing requesting a surrender
 * @return true if this Thing agrees to surrender, false otherwise.
 */
Thing.prototype.isSurrenderable = function () {
    return false;
};

/**
 * Retrieves whether or not this Thing instance is blocked in a given direction.
 * A Thing is defined as blocked if a tile appears at that direction that is occupied
 * and is not willing to surrender its position to another tile.
 *
 * @param direction A direction in which to test if this Thing is blocked
 * @return true if this Thing is blocked, false otherwise.
 */
Thing.prototype.isBlocked = function (direction) {

    var newPoint = this.point.add(direction),
        obstacle;

    if (this.board.isFree(newPoint)) {
        return false;
    }

    if (this.board.isOutside(newPoint)) {
        return true;
    }

    obstacle = this.board.getTile(newPoint);
    if (obstacle) {
        return !obstacle.isSurrenderable(this);
    }

};

/**
 * Retrieves whether or not this Thing has a line of sight to a Player within a provided
 * distance. A line of sight may be broken by any Thing, in which case this function
 * returns false.
 *
 * @param distance a number of tiles determining the visibility distance
 * @return true if there is an uninterrupted straight line between this thing and a player.
 */
Thing.prototype.isPlayerVisible = function (distance) {

    var line = utilities.generateLineData(this.point, this.board.player.point),
        me = this,
        currentPoint = this.point,
        result = true;

    function isBlocked(point) {
        var tile = me.board.getTile(point);
        return tile && (tile !== me) && (tile.type !== 'Player');
    }

    if (line.points.length > distance) {
        return false;
    }

    line.forEach(function (point) {

        // If we're doing a diagnoal step, test both paths to that step
        if (currentPoint.x !== point.x && currentPoint.y !== point.y) {

            if (isBlocked(new Point(currentPoint.x, point.y)) || isBlocked(new Point(point.x, currentPoint.y))) {
                result = false;
            }

        }

        if (isBlocked(point)) {
            result = false;
        }

        currentPoint = point;

    });

    return result;

};

/**
 * Retrieves whether or not this Thing instance is directly adjacent to a Player Thing in
 * a provided direction.
 *
 * @param direction A direction in which to test if this Thing is player adjacent
 * @return true if a Player thing is directly adjacent in a given direction, false otherwise.
 */
Thing.prototype.isPlayerAdjacent = function (direction) {
    var tile = this.board.getTile(this.point.add(direction));
    return tile && tile.type === 'Player';
};

/**
 * Returns whether or not this Thing is aligned to the player
 * with a certain spread.
 *
 * @return true if player is aligned, false otherwise.
 */
Thing.prototype.isPlayerAligned = function (spread, direction) {
    return this.point.aligned(this.board.player.point, spread, direction);
};

/**
 * Moves this Thing in a provided Direction and returns its success.
 *
 * @param direction A Direction in which to move this Thing.
 * @param weak If true, we will move weakly.
 * @return true if the move was successful, false otherwise.
 */
Thing.prototype.move = function (direction, weak) {
    return this.board.moveTile(this.point, this.point.add(direction), weak);
};

/**
 * Removes this Thing from its owner board.
 */
Thing.prototype.remove = function () {
    this.board.deleteTile(this.point);
};

/**
 * Retrieves a sprite index to be used to represent this Thing.
 *
 * @return A sprite index.
 */
Thing.prototype.getSpriteIndex = function () {
    return this.spriteIndex;
};

/**
 * Retrieves a Thing that is directly adjacent to this Thing in a given direction.
 *
 * @param direction A direction to retrieve another Thing.
 * @return a Thing, or undefined if no such Thing exists.
 */
Thing.prototype.getAdjacentThing = function (direction) {
    return this.board.getTile(this.point.add(direction));
};

/**
 * Retrieves whether or not this Thing has the same type and color as provided.
 *
 * @param type a case-insensitive serializable type name
 * @param color An optional color
 * @return true if this Thing has a matching serializable type and color (if provided)
 */
Thing.prototype.equals = function (template) {

    var type = template.type.toUpperCase(),
        color = template.color ? deserializeForeground(template.color) : undefined;

    if (this.constructor.type.toUpperCase() === type) {

        return color === undefined ? true : color === this.foreground;

    }

    return false;

};

/**
 * Displays a short, localizable message exactly once.
 *
 * @param messageKey A localization key for a message to display.
 */
Thing.prototype.oneTimeMessage = function (messageKey) {

    this.board.game.oneTimeMessage(messageKey);

};

/**
 * Returns a new Thing instance with the same properties as this Thing.
 * This clone function works by serializing the current Thing and deserializing
 * the data as a new Thing, and should work for any serializable Thing.
 *
 * @return A clone of this Thing.
 */
Thing.prototype.clone = function () {
    var clone = this.serialize();
    return ThingFactory.deserialize(clone, this.board);
};

// ------------------------------------------------------------------------------

/*
 * Updateable Thing is a Thing that can be updated during an execution cycle
 * of its owner board. UpdateableThings may take different actions during updates.
 *
 * @param board A Board to which this UpdateableThing belongs.
 */
function UpdateableThing(board) {
    Thing.call(this, board);
    this.cycleCount = 0;
    this.speed = 3;
}
UpdateableThing.prototype = new Thing();

/**
 * Serializes this Thing to an object and returns it.
 *
 * @return A serialized version of this Thing.
 */
UpdateableThing.prototype.serialize = function () {
    var result = Thing.prototype.serialize.call(this) || {};
    result.speed = this.speed;
    return result;
};

/**
 * Deserializes a given data object and update's this Thing's state to
 * that data.
 *
 * @param data An object to be deserialized into this Thing.
 */
UpdateableThing.prototype.deserialize = function (data) {
    Thing.prototype.deserialize.call(this, data);
    if (data.speed) {
        this.speed = data.speed;
    }
    this.cycleCount = Math.floor(Math.random() * this.speed);
};

/**
 * Retrieves a Direction toward this UpdateableThing's Board's Player.
 *
 * @return a Direction toward a Player.
 */
UpdateableThing.prototype.getPlayerDirection = function (axis) {
    return this.point.directionTo(this.board.player.point, axis);
};

UpdateableThing.prototype.getSmartDirection = function () {
    return this.board.getSmartDirection(this.point);
};

UpdateableThing.prototype.influenceSmartPath = function () {
    return undefined;
};

/**
 * Returns whether or not a position in a provided direction is attackable
 * by this UpdateableThing. Attackable positions are defined as free spots
 * or spots occupied by a player.
 *
 * return true if a provided direction is attackable, false otherwise
 */
UpdateableThing.prototype.isAttackable = function (direction) {
    return !this.isBlocked(direction) || this.isPlayerAdjacent(direction);
};

/**
 * Retrieves an Array of Directions in which this UpdateableThing can attack.
 * An attackable direction is defined as any direction that is free, or is
 * occupied by the player.
 *
 * @return An array of Directions
 */
UpdateableThing.prototype.getAttackableDirections = function () {

    var result = [],
        instance = this;
    Direction.each(function (direction) {
        if (instance.isAttackable(direction)) {
            result.push(direction);
        }
    });
    return result;

};

/**
 * Retrievs an Array of Directions in which this UpdateableThing is
 * free to move on its owner Board.
 *
 * @return An array of Directions.
 */
UpdateableThing.prototype.getFreeDirections = function () {

    var result = [],
        instance = this;

    Direction.each(function (direction) {
        if (!instance.isBlocked(direction)) {
            result.push(direction);
        }
    });

    return result;

};

/**
 * Retrieves an Array of Directions in which this UpdateableThing is not free
 * to move on its owner Board.
 *
 * @return An array of Directions.
 */
UpdateableThing.prototype.getBlockedDirections = function () {

    var result = [],
        instance = this;

    Direction.each(function (direction) {
        if (instance.isBlocked(direction)) {
            result.push(direction);
        }
    });

    return result;

};

/**
 * Updates this UpdateableThing for a single execution cycle.
 */
UpdateableThing.prototype.update = function () {

    if (this.board.game.state === GameState.GameOver) {
        this.doTick();
        return;
    }

    this.cycleCount += 1;

    if (this.cycleCount >= this.speed * this.board.game.CYCLE_RATE) {
        this.cycleCount = 0;
        this.doTick();
    }

};

UpdateableThing.prototype.updateOnReverse = function () {
    return false;
};

/**
 * Updates this UpdateableThing on its tick update cycle.
 */
UpdateableThing.prototype.doTick = function () {
    return undefined;
};

// ------------------------------------------------------------------------------

/*
 * Scriptable Thing is an UpdateableThing capable of executing a Script instance
 * for its update cycles. This Script will be updated in a ScriptContext unique
 * to this Scriptable.
 *
 * @param board An owner board for this Scriptable.
 */
function Scriptable(board) {
    UpdateableThing.call(this, board);
    this.name = 'UnknownScriptable';
    this.scriptContext = undefined;
    this.messageQueue = [];
    this.walkDirection = undefined;
    this.locked = false;
    this.orientation = undefined;
    this.spriteIndex = 1;
    this.torchRadius = undefined;
    this.pushable = false;
}
Scriptable.prototype = new UpdateableThing();
Scriptable.prototype.constructor = Scriptable;

/**
 * Serializes this Thing to an object and returns it.
 *
 * @return A serialized version of this Thing.
 */
Scriptable.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this) || {};

    result.name = this.name;
    result.spriteIndex = this.spriteIndex;
    result.script = this.scriptName;

    utilities.storeOption(result, 'pushable', this.pushable, false);

    if (this.torchRadius > 0) {
        result.torchRadius = this.torchRadius;
    }

    if (this.scriptContext) {

        if (!(this.scriptContext.inDefaultState())) {
            result.scriptContext = this.scriptContext.serialize();
        }
        if (this.messageQueue.length > 0) {
            result.messageQueue = this.messageQueue.slice(0);
        }
        utilities.storeOption(result, 'walkDirection', Direction.getName(this.walkDirection));
        utilities.storeOption(result, 'locked', this.locked, false);
        utilities.storeOption(result, 'orientation', Direction.getName(this.orientation));
    }

    return result;

};

/**
 * Deserializes a given data object and update's this Thing's state to
 * that data.
 *
 * @param data An object to be deserialized into this Thing.
 */
Scriptable.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.name = data.name || 'UnknownScriptable';
    this.spriteIndex = data.spriteIndex !== undefined ? data.spriteIndex : 1;
    this.setTorchRadius(data.torchRadius !== undefined ? data.torchRadius : 0);
    this.pushable = data.pushable !== undefined ? data.pushable : false;
    this.locked = data.locked;
    if (data.walkDirection) {
        this.walkDirection = Direction.fromName(data.walkDirection);
    }
    if (data.orientation) {
        this.orientation = Direction.fromName(data.orientation);
    }
    this.scriptName = data.script;
    var script = this.board.getScript(this.scriptName);
    if (script) {
        this.scriptContext = new JztScriptContext(script, this);
        if (data.scriptContext) {
            this.scriptContext.deserialize(data.scriptContext);
        }

        if (Array.isArray(data.messageQueue) && data.messageQueue.length > 0) {
            this.messageQueue = data.messageQueue.slice(0);
        }

    }
};

/**
 * Delivers a message to this Scriptable. This message will be passed
 * on to its Script during its next execution cycle if this ScriptableInstance
 * is not in a locked state.
 *
 * @param message A message to be delivered to this Scriptable.
 */
Scriptable.prototype.sendMessage = function (message) {

    // If we are ready to receive a message...
    if (!this.locked) {

        // We disallow duplicate messages in a row
        if (this.messageQueue[this.messageQueue.length - 1] !== message) {
            this.messageQueue.push(message);
        }

    }

};

/**
 * Moves this Thing in a provided Direction and returns its success.
 *
 * @param direction A Direction in which to move this Thing.
 * @return true if the move was successful, false otherwise.
 */
Scriptable.prototype.move = function (direction) {
    this.orientation = direction;
    return UpdateableThing.prototype.move.call(this, direction);
};

/**
 * Pushes this Scriptable in a provided Direction.
 */
Scriptable.prototype.push = function (direction) {
    if (this.pushable) {
        this.move(direction);
    }
};

/**
 * Makes this Scriptable walk in its current walking direction.
 * Scriptables can walk while executing other instructions. If this
 * Scriptable walks into an obsticle and cannot continue walking,
 * it will receive a 'THUD' message and halt its walking direction.
 */
Scriptable.prototype.walk = function () {
    if (this.walkDirection) {

        if (!this.move(this.walkDirection)) {
            this.sendMessage('THUD');
        }

    }
};

/**
 * Updates this Scriptable for a single execution cycle, including its
 * associated Script.
 */
Scriptable.prototype.doTick = function () {

    this.walk();
    if (this.scriptContext) {
        this.scriptContext.executeTick();
    }

};

Scriptable.prototype.setTorchRadius = function (radius) {
    this.torchRadius = radius;
};

Scriptable.prototype.getTorch = function () {
    if (this.torchRadius > 0) {
        return utilities.generateCircleData(this.point, this.torchRadius);
    }
};

/*==================================================================================
 * BUILT-IN THINGS
 *=================================================================================*/

 /**
  * ActiveBomb is an UpdateableThing that counts down from 9 to 0 before exploding.
  *
  * @param board A board to own this ActiveBomb
  */
function ActiveBomb(board) {
    UpdateableThing.call(this, board);
    this.timeToLive = 9;
    this.speed = 6;
    this.spriteIndex = 57;
    this.radius = 4;
    this.conveyable = true;
}
ActiveBomb.prototype = new UpdateableThing();
ActiveBomb.prototype.constructor = ActiveBomb;

ActiveBomb.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    result.timeToLive = this.timeToLive;
    result.radius = this.radius;
    return result;
};

ActiveBomb.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.timeToLive = data.timeToLive || 9;
    this.radius = data.radius || 4;
};

ActiveBomb.prototype.push = function (direction) {
    this.move(direction);
};

ActiveBomb.prototype.getSpriteIndex = function () {
    return 57 - (9 - this.timeToLive);
};

ActiveBomb.prototype.doTick = function () {

    var explosion;
    this.play(this.timeToLive % 2 ? '8' : '5');

    this.timeToLive -= 1;
    if (this.timeToLive < 0) {
        explosion = new exports.things.Explosion(this.board);
        explosion.radius = this.radius;
        this.board.replaceTile(this.point, explosion);
    }

};


//--------------------------------------------------------------------------------


/**
 * Ammo is a Thing that acts as an item capable of increasing a Game's 'ammo' counter
 * by five units when collected.
 *
 * @param board A board to own this Ammo instance
 */
function Ammo(board) {
    Thing.call(this, board);
    this.spriteIndex = 132;
    this.background = undefined;
    this.foreground = Colors.Cyan;
}
Ammo.prototype = new Thing();
Ammo.prototype.constructor = Ammo;

Ammo.prototype.serialize = function () {
    var result = Thing.prototype.serialize.call(this);
    delete result.color;
    return result;
};

Ammo.prototype.deserialize = function (data) {
    Thing.prototype.deserialize.call(this, data);
    this.background = undefined;
    this.foreground = Colors.Cyan;
};

/**
 * Pushes this Ammo in a provided direction on its owner Board.
 *
 * @param direction A direction in which to push this Ammo
 */
Ammo.prototype.push = function (direction) {
    this.move(direction);
};

/**
 * Sends a provided message to this Ammo instance. If a TOUCH message is received
 * then this Ammo instance will be removed and increase the Game's 'ammo' counter
 * by five units.
 */
Ammo.prototype.sendMessage = function (message) {
    if (message === 'TOUCH') {
        this.oneTimeMessage('status.ammo');
        this.play('tcc#d');
        this.adjustCounter('AMMO', 5);
        this.remove();
    }
};

//--------------------------------------------------------------------------------

/**
 * Bear represents an UpdateableThing that will attack a Player when it is aligned
 * vertically or horizontally within a defined sensitivity range.
 *
 * @param board A Board to own this Bear.
 */
function Bear(board) {
    UpdateableThing.call(this, board);
    this.spriteIndex = 153;
    this.background = undefined;
    this.foreground = Colors.Brown;
    this.sensitivity = 9;
    this.speed = 3;
    this.conveyable = true;
}
Bear.prototype = new UpdateableThing();
Bear.prototype.constructor = Bear;

/**
 * Serializes this Bear to an Object.
 *
 * @return A serialized Bear
 */
Bear.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    delete result.color;
    result.sensitivity = this.sensitivity;
    return result;
};

/**
 * Deserializes this Bear from a provided data Object
 *
 * @param data A data Bear object to be deserialized.
 */
Bear.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.background = undefined;
    this.foreground = Colors.Brown;
    this.sensitivity = data.sensitivity || 9;
};

/**
 * Pushes this Bear in a given direction. If this Bear cannot be pushed,
 * it will be squished and removed from its owner Board.
 *
 * @param direction A direction in which to push this Bear.
 */
Bear.prototype.push = function (direction, pusher) {

    if (pusher.type === 'River') {
        this.move(direction, true);
    } else if (!this.move(direction)) {
        this.play('t+c---c++++c--c');
        this.remove();
    }

};

/**
 * Delivers a provided message to this Thing. If a SHOT message is received,
 * then this Bear will be deleted from the board. If a TOUCH message is
 * received, then the player will be sent a SHOT message.
 *
 * @param messageName a name of a message to deliver.
 */
Bear.prototype.sendMessage = function (message) {

    if (message === 'SHOT' || message === 'BOMBED') {
        this.play('t+c---c++++c--c', true);
        this.adjustCounter('SCORE', 10);
        this.remove();
    } else if (message === 'TOUCH') {
        this.board.player.sendMessage('SHOT');
        this.remove();
    }

};

/**
 * Updates this Bear for a provided timestamp. This Bear will move itself randomly
 * during updates. If a Player blocks its movement, then the player will be sent
 * a SHOT message and this Bear will be removed from its parent board.
 */
Bear.prototype.doTick = function () {

    var thing,
        direction;

    if (this.isPlayerAligned(10 - this.sensitivity)) {

        // X-Axis always gets priority
        direction = this.getPlayerDirection('x');

        // If we are already aligned with the player...
        if (direction === undefined) {
            direction = this.getPlayerDirection('y');
        }

        thing = this.board.getTile(this.point.add(direction));
        if (thing && (thing.type === 'BreakableWall' || thing.type === 'Player')) {
            thing.sendMessage('SHOT');
            this.remove();
            return;
        }

        // Don't attempt to move in the direction of a river
        if (thing && thing.type === 'River' && thing.direction === Direction.opposite(direction)) {
            return;
        }

        this.move(direction, true);
    }

};

//--------------------------------------------------------------------------------

function Blinker(board) {
    UpdateableThing.call(this, board);
    this.direction = Direction.North;
    this.period = 3;
    this.delay = 0;
    this.currentTick = 0;
    this.spriteIndex = 206;
    this.background = undefined;
    this.foreground = Colors.Yellow;
    this.blinkState = false;
}
Blinker.prototype = new UpdateableThing();
Blinker.prototype.constructor = Blinker;

Blinker.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    result.period = this.period;
    result.delay = this.delay;
    result.direction = Direction.getShortName(this.direction);
    return result;
};

Blinker.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.cycleCount = 0;
    this.period = data.period || 3;
    this.delay = data.delay || 0;
    this.currentTick = this.period - this.delay - 1;
    this.direction = data.direction ? Direction.fromName(data.direction) : Direction.North;
};

Blinker.prototype.doTick = function () {

    this.currentTick += 1;
    if (this.currentTick >= this.period) {
        this.currentTick = 0;
        this.blinkState = !this.blinkState;
        this.blink();
    }

};

Blinker.prototype.blink = function () {

    var point = this.point,
        tile,
        moved;

    while (true) {

        // Increment our point of interest
        point = point.add(this.direction);

        // If it's off the board, stop immediately
        if (this.board.isOutside(point)) {
            break;
        }

        // Grab our tile of interest
        tile = this.board.getTile(point);


        // If we actually found a tile...
        if (tile) {


            if (!this.blinkState && tile.type === 'BlinkWall') {

                // We're not blinking, so remove the BlinkWall tile
                tile.remove();

            } else if (tile.type === 'Player') {

                // Harm the player
                tile.sendMessage('SHOT');

                // Shove the player out of the way if possible
                if (!tile.isBlocked(Direction.clockwise(this.direction))) {
                    moved = tile.move(Direction.clockwise(this.direction));
                } else if (!tile.isBlocked(Direction.counterClockwise(this.direction))) {
                    moved = tile.move(Direction.counterClockwise(this.direction));
                }

                // If we weren't able to move our player
                if (!moved) {
                    break;
                }

            } else {

                // All other tiles aren't affected
                break;

            }

        }

        // If we are blinking...
        if (this.blinkState) {

            // Add a blinkwall
            this.board.addThing(point, this.createBlinkWall());

        }

    }

};

Blinker.prototype.createBlinkWall = function () {
    var blinkWall = new exports.things.BlinkWall(this.board);
    blinkWall.horizontal = (this.direction === Direction.North || this.direction === Direction.South) ? false : true;
    blinkWall.foreground = this.foreground;
    return blinkWall;
};

//--------------------------------------------------------------------------------

/**
 * BlinkWall is a special type of wall generated by Blinkers.
 */
function BlinkWall(board) {
    Thing.call(this, board);
    this.horizontal = false;
    this.background = undefined;
    this.foreground = Colors.Yellow;
}
BlinkWall.prototype = new Thing();
BlinkWall.prototype.constructor = BlinkWall;

BlinkWall.prototype.serialize = function () {
    var result = Thing.prototype.serialize.call(this);
    if (this.horizontal) {
        result.horizontal = this.horizontal;
    }
    return result;
};

BlinkWall.prototype.deserialize = function (data) {
    Thing.prototype.deserialize.call(this, data);
    this.horizontal = data.horizontal !== undefined ? data.horizontal : false;
};

BlinkWall.prototype.getSpriteIndex = function () {
    return this.horizontal ? 205 : 186;
};

//--------------------------------------------------------------------------------

/**
 * A Bomb is a Thing that becomes an ActiveBomb when touched.
 *
 * @param board An owner board for this Bomb
 */
function Bomb(board) {
    Thing.call(this, board);
    this.radius = 4;
    this.spriteIndex = 11;
    this.conveyable = true;
}
Bomb.prototype = new Thing();
Bomb.prototype.constructor = Bomb;

Bomb.prototype.deserialize = function (data) {
    Thing.prototype.deserialize.call(this, data);
    this.radius = data.radius || 4;
};

Bomb.prototype.serialize = function () {
    var result = Thing.prototype.serialize.call(this);
    result.radius = this.radius;
    return result;
};

Bomb.prototype.push = function (direction) {
    this.move(direction);
};

Bomb.prototype.sendMessage = function (message) {
    var bomb;
    if (message === 'TOUCH') {
        this.play('tcf+cf+c');
        bomb = new ActiveBomb(this.board);
        bomb.radius = this.radius;
        bomb.foreground = this.foreground;
        bomb.background = this.background;
        this.board.replaceTile(this.point, bomb);
    }
};

//--------------------------------------------------------------------------------

/*
 * A Boulder is a Thing that is pushable in all directions.
 *
 * @param board An owner board for this Boulder.
 */
function Boulder(board) {
    Thing.call(this, board);
    this.conveyable = true;
    this.spriteIndex = 254;
}
Boulder.prototype = new Thing();
Boulder.prototype.constructor = Boulder;

/**
 * Receives a request to be pushed in a given direction.
 *
 * @param direction A direction in which this Thing is requested to move.
 */
Boulder.prototype.push = function (direction, pusher) {

    if (pusher.type === 'River') {
        this.move(direction, true);
    } else if (this.move(direction)) {
        this.play('t--f', false, true);
    }
};

//--------------------------------------------------------------------------------

/**
 * BreakableWall represents an obstacle for a player until it is shot, at which
 * point the wall is removed from its owner Board.
 *
 * @param board An owner board for this BreakableWall.
 */
function BreakableWall(board) {
    Thing.call(this, board);
    this.spriteIndex = 177;
    this.background = Colors.Black;
    this.foreground = Colors.BrightCyan;
}
BreakableWall.prototype = new Thing();
BreakableWall.prototype.constructor = BreakableWall;

/**
 * Sends a provided message to this BreakableWall. If a SHOT message
 * is received, then this BreakableWall will vanish.
 *
 * @param message A message to receive.
 */
BreakableWall.prototype.sendMessage = function (message) {
    if (message === 'SHOT' || message === 'BOMBED') {
        this.play('t-c');
        this.remove();
    } else if (message === 'TOUCH') {
        this.oneTimeMessage('status.breakable');
    }
};

//--------------------------------------------------------------------------------

/**
 * A Bullet is an UpdateableThing that represents a projectile.
 *
 * @param board An owner board for this Bullet
 */
function Bullet(board) {
    UpdateableThing.call(this, board);
    this.spriteIndex = 248;
    this.foreground = Colors.BrightWhite;
    this.background = undefined;
    this.direction = Direction.North;
    this.speed = 1;
}
Bullet.prototype = new UpdateableThing();
Bullet.prototype.constructor = Bullet;

/**
 * Serializes this Thing to an object and returns it.
 *
 * @return A serialized version of this Thing.
 */
Bullet.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this) || {};
    delete result.color;
    result.direction = Direction.getShortName(this.direction);
    if (this.fromPlayer) {
        result.fromPlayer = true;
    }
    return result;
};

/**
 * Deserializes a given data object and update's this Thing's state to
 * that data.
 *
 * @param data An object to be deserialized into this Thing.
 */
Bullet.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.background = undefined;
    this.foreground = Colors.BrightWhite;
    this.direction = Direction.fromName(data.direction);
    if (data.fromPlayer) {
        this.fromPlayer = data.fromPlayer;
    }
};

/**
 * Sends a provided message to this Bullet instance. If a Touch message is
 * received then the player will be sent a shot message and this Bullet will
 * be removed from its owner Board.
 *
 * @param message A message to be delivered to this Bullet.
 */
Bullet.prototype.sendMessage = function (message) {
    if (message === 'TOUCH') {
        this.board.player.sendMessage('SHOT');
        this.remove();
    }
};

/**
 * Retrieves whether or not this Bullet instance wishes to be updated on its owner Board's
 * reverse update cycle.
 */
Bullet.prototype.updateOnReverse = function () {
    return this.direction === Direction.South || this.direction === Direction.East;
};

Bullet.prototype.influenceSmartPath = function () {

    var point,
        index;

    // If we are a player bullet...
    if (this.fromPlayer) {

        point = this.point;

        // Weight the ten spaces in front of our bullet as aversion points
        for (index = 0; index < 10; index += 1) {
            point = point.add(this.direction);
            this.board.adjustSmartPathWeight(point, 100 - (index * 10));
        }

    }

};

/**
 * Updates this bullet, moving it one tile in its associated
 * direction.
 */
Bullet.prototype.doTick = function () {

    // If we are unable to move, attack our obstacle
    if (!this.move(this.direction, true)) {
        this.attack();
        this.react();
    }

};

/**
 * Attempts to Attack a Thing in this Bullet's path. If a player, Scriptable, or BreakableWall is in
 * its path, that Thing will be sent a SHOT message.
 */
Bullet.prototype.attack = function () {

    // See what was in our way.
    var thing = this.board.getTile(this.point.add(this.direction));

    /*
     * Send a SHOT message if the bullet was from the player
     * otherwise we only send the SHOT message to the player, Scriptables, and BreakableWalls.
     */
    if (thing && (this.fromPlayer ||
            thing.type === 'Player' || thing.type === 'Scriptable' || thing.type === 'BreakableWall')) {
        thing.sendMessage('SHOT');
    }

};

/**
 * Make this Bullet react to its environment by looking for ricochet points or removing itself
 * from the board.
 */
Bullet.prototype.react = function () {

    // If we are still blocked (by a non-player), check if we should ricochet
    var thing = this.getAdjacentThing(this.direction);
    if (thing && thing.type !== 'Player') {

        // If there is a ricochet in our direction, reflect in the opposite direction if we're not blocked that way
        if (thing.type === 'Ricochet') {
            this.ricochet(Direction.opposite(this.direction));
            return;
        }

        // If there is a ricochet to our right, reflect to the left if we're not blocked that way
        thing = this.getAdjacentThing(Direction.clockwise(this.direction));
        if (thing && thing.type === 'Ricochet') {
            this.ricochet(Direction.counterClockwise(this.direction));
            return;
        }

        // If there is a ricochet to our left, reflect to our right if we're not blocked that way
        thing = this.getAdjacentThing(Direction.counterClockwise(this.direction));
        if (thing && thing.type === 'Ricochet') {
            this.ricochet(Direction.clockwise(this.direction));
            return;
        }

    }

    // Otherwise remove this bullet...
    this.remove();

};

/**
 * Change the direction of this bullet (with a ricochet sound) if we're capable of moving that way.
 *
 * @param A direction in which to ricochet
 */
Bullet.prototype.ricochet = function (direction) {

    // Change directions
    this.direction = direction;

    // If we're free to ricochet in the provided direction...
    if (this.move(direction, true)) {

        // Play our ricochet sound
        this.play('9', false, true);

    } else {

        // We're not free to Ricochet, so attack and remove ourselves
        this.attack();
        this.remove();

    }
};

/**
 * Attempts to push this Bullet.
 */
Bullet.prototype.push = function () {
    this.remove();
};

//--------------------------------------------------------------------------------

/**
 * Centipede is an UpdateableThing capable of chaining itself to other
 * Centipedes and moving around the board as a unit.
 *
 * @param board An owner board for this Centipede
 */
function Centipede(board) {
    UpdateableThing.call(this, board);
    this.spriteIndex = 79;
    this.foreground = Colors.BrightBlue;
    this.background = undefined;
    this.speed = 3;
    this.follower = undefined;
    this.head = false;
    this.leader = undefined;
    this.linked = false;
    this.firstTick = true;
    this.orientation = undefined;
    this.deviance = 0;
    this.intelligence = 0;
}
Centipede.prototype = new UpdateableThing();
Centipede.prototype.constructor = Centipede;

/**
 * Serializes this Thing to an object and returns it.
 *
 * @return A serialized version of this Thing.
 */
Centipede.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    result.head = this.head;
    result.deviance = this.deviance;
    result.intelligence = this.intelligence;
    if (this.orientation) {
        result.orientation = Direction.getShortName(this.orientation);
    }
    if (this.follower) {
        result.nextSegment = Direction.getShortName(this.point.directionTo(this.follower.point));
    }
    return result;
};

/**
 * Deserializes a given data object and update's this Thing's state to
 * that data.
 *
 * @param data An object to be deserialized into this Thing.
 */
Centipede.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.head = data.head;
    this.intelligence = data.intelligence;
    this.deviance = data.deviance;
    if (data.orientation) {
        this.orientation = Direction.fromName(data.orientation);
    }
    if (data.nextSegment) {
        this.nextSegment = Direction.fromName(data.nextSegment);
    }
    if (this.deviance > 10) {
        this.deviance = 10;
    }
    if (this.intelligence > 10) {
        this.intelligence = 10;
    }
    if (this.head) {
        this.spriteIndex = 233;
    }
    this.cycleCount = 0;
};

/**
 * Retrieves an unlinked, non-head, adjacent Centipede segment.
 *
 * @return An unlineked, non-head, adjacent Centipede segment.
 */
Centipede.prototype.getAdjacentSegment = function () {

    /**
     * Returns true if a provided candidate Thing is a Centipede, is
     * unlinked, and is not a head.
     *
     * @param candidate a Thing
     * @return true if a candidate is an unlinked, non-head Centipede
     */
    function isUnlinkedSegment(candidate) {
        return candidate && candidate.type === 'Centipede' && !candidate.linked && !candidate.nextSegment && !candidate.head;
    }

    var result;

    // If a next segment direction was explicitly defined...
    if (this.nextSegment) {
        result = this.board.getTile(this.point.add(this.nextSegment));
        delete this.nextSegment;

        // Sanity check before returning our result
        if (result && result.type === 'Centipede' && !result.head) {
            return result;
        }

    }

    // Try North
    result = this.board.getTile(this.point.add(Direction.North));
    if (isUnlinkedSegment(result)) {
        return result;
    }

    // East
    result = this.board.getTile(this.point.add(Direction.East));
    if (isUnlinkedSegment(result)) {
        return result;
    }

    // South
    result = this.board.getTile(this.point.add(Direction.South));
    if (isUnlinkedSegment(result)) {
        return result;
    }

    // West
    result = this.board.getTile(this.point.add(Direction.West));
    if (isUnlinkedSegment(result)) {
        return result;
    }

    return undefined;

};

/**
 * Recursively links adjacent segments to a provided Centipede.
 *
 * @param leader a Centipede
 */
Centipede.prototype.linkSegments = function (leader) {

    this.linked = true;
    this.leader = leader;

    if (this.leader) {
        this.deviance = leader.deviance;
        this.intelligence = leader.intelligence;
        this.cycleCount = leader.cycleCount;
        this.speed = leader.speed;
    }

    this.follower = this.getAdjacentSegment();

    if (this.follower) {

        if (this.head) {
            // Choose a natural initial orientation
            this.orientation = this.follower.point.directionTo(this.point);
        }

        this.follower.linkSegments(this);

    }

};

/**
 * Reverses the follower/leader relationship of this Centipede
 * and its followers.
 */
Centipede.prototype.reverse = function () {


    var nextSegment = this.follower,
        oldLeader = this.leader;

    if (this.head) {
        this.head = false;
        this.spriteIndex = 79;
    }

    this.leader = this.follower;
    this.follower = oldLeader;

    if (nextSegment) {
        nextSegment.reverse();
    } else {
        this.becomeHead();
    }

};

/**
 * Turns this Centipede into a head segment.
 */
Centipede.prototype.becomeHead = function () {

    this.head = true;
    this.spriteIndex = 233;

    this.cycleCount = Math.floor(Math.random() * this.speed);

};

/**
 * Moves this Centipede in a given direction. If a Player is
 * located in that direction, this Centipede will be deleted
 * and the player will be sent a SHOT message, otherwise this
 * Centipede and its followers will move one step.
 *
 * @param direction A direction in which to move. This direction
 * is expected to be free for movement, but may contain a Player.
 */
Centipede.prototype.move = function (direction) {

    var myPlace = this.point.clone();

    // If we're a head, check to see if we're attacking the player
    if (this.head && this.isPlayerAdjacent(direction)) {
        this.board.player.sendMessage('SHOT');
        this.remove();
        return;
    }

    this.board.moveTile(this.point, this.point.add(direction), true);

    if (this.follower) {
        direction = this.follower.point.directionTo(myPlace);
        this.follower.move(direction);
    }

};

/**
 * Requests that this Centipede be pushed in a given direction. Since
 * Centipedes can't be pushed, the Centipede will be deleted instead.
 *
 * @param direction A given direction to push this Centipede.
 */
Centipede.prototype.push = function () {
    this.play('t+c---c++++c--c');
    this.remove();
};

/**
 * Deletes this Centipede from its Board. Any leader and follower
 * Centipedes will be updates to no longer contain this Centipede
 * as well.
 */
Centipede.prototype.remove = function () {

    if (this.leader) {
        this.leader.follower = undefined;
    }
    if (this.follower) {
        this.follower.leader = undefined;
    }

    UpdateableThing.prototype.remove.call(this);

};

/**
 * Sends a provided message to this Centipede. If a SHOT message
 * is received, then this Centipede will be deleted from its board.
 * If a TOUCH message is received, then the board's player will be
 * sent a SHOT message and this Centipede will be deleted.
 *
 * @param message A message to be sent to this Centipede.
 */
Centipede.prototype.sendMessage = function (message) {
    if (message === 'SHOT' || message === 'BOMBED') {
        this.play('t+c---c++++c--c', true);
        this.adjustCounter('SCORE', 10);
        this.remove();
    }
    if (message === 'TOUCH') {
        this.board.player.sendMessage('SHOT');
        this.remove();
    }
};

/**
 * Returns whether or not this Centipede should deviate from
 * its orientation. This is a probability based on this
 * Centipedes deviance property.
 *
 * @return true if this Centipede should deviate now, false otherwise.
 */
Centipede.prototype.deviate = function () {

    if (this.deviance <= 0) {
        return false;
    }

    var randomValue = Math.floor(Math.random() * 20);
    return randomValue <= this.deviance;

};

/**
 * Returns whether or not this Centipede should seek the player
 * at this moment, or if it should move randomly. This is a
 * probability based on this Centipede's intelligence property.
 */
Centipede.prototype.seekPlayer = function () {

    if (this.intelligence <= 0) {
        return false;
    }

    if (this.isPlayerAligned()) {

        var randomValue = Math.floor(Math.random() * 10);
        return randomValue <= this.intelligence;

    }

    return false;

};

/**
 * Performs a tick.
 */
Centipede.prototype.doTick = function () {

    var direction,
        availableDirections;

    if (this.firstTick) {
        this.firstTick = false;
    } else {

        // If we aren't a head and don't have a leader, become one
        if (!this.head && this.leader === undefined) {
            this.becomeHead();
        }

    }

    // Centipedes only update if they are a head
    if (!this.head) {
        return;
    }

    // If we haven't initialized our segments, do it now
    if (!this.linked) {
        this.linkSegments();
    }

    // If we're to see the player now...
    if (this.seekPlayer()) {

        // Set our orientation toward the player
        this.orientation = this.getPlayerDirection();

    }

    // If we've got an orientation and it's attackable, move there
    if (this.orientation && this.isAttackable(this.orientation) && !this.deviate()) {
        this.move(this.orientation);
    } else {

        // Find all attackable directions
        availableDirections = this.getAttackableDirections();

        // If directions are available...
        if (availableDirections.length > 0) {

            // Pick one and remember it as our orientation
            direction = Direction.random(availableDirections);
            this.orientation = direction;
            this.move(direction);

        } else {
            this.reverse();
        }

    }


};

//--------------------------------------------------------------------------------

function Conveyor(board) {
    UpdateableThing.call(this, board);
    this.clockwise = true;
    this.animationIndex = Math.floor(Math.random() * Conveyor.animationFrames.length - 1);
    this.spriteIndex = 179;
}
Conveyor.prototype = new UpdateableThing();
Conveyor.prototype.constructor = Conveyor;
Conveyor.animationFrames = [179, 47, 45, 92];
Conveyor.MoveAction = {MOVE: 1, TENTATIVE: 2};

Conveyor.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    result.clockwise = this.clockwise;
    return result;
};

Conveyor.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.clockwise = data.clockwise;
};

Conveyor.prototype.markPath = function (path) {

    var index,
        tile,
        obstacle,
        MoveAction = Conveyor.MoveAction;

    for (index = path.length - 1; index >= 0; index -= 1) {

        // Grab our tile of interest
        tile = this.board.getTile(path[index]);

        // If it exists and is conveyable...
        if (tile && tile.conveyable) {

            // If we're starting, our move is tentative on the final move
            if (index === path.length - 1) {
                path[index].action = MoveAction.TENTATIVE;
            } else {

                // If the path isn't off the board...
                if (!this.board.isOutside(path[index + 1])) {

                    // Grab our obstacle
                    obstacle = this.board.getTile(path[index + 1]);

                    // If there is no obstacle, or it's surrenderable, then set our action to MOVE
                    if (!obstacle || (!obstacle.conveyable && obstacle.surrenderable)) {

                        path[index].action = MoveAction.MOVE;

                    } else {

                        // Take the same action as our previous path
                        path[index].action = path[index + 1].action;
                    }

                }

            }

        }

    }

    // If the last position is free, or if the last path action is MOVE or TENTATIVE...
    if (this.board.isFreeOrSurrenderable(path[0]) || path[0].action === MoveAction.MOVE || path[0].action === MoveAction.TENTATIVE) {

        // Convert all TENTATIVE actions to MOVE actions
        for (index = 0; index < path.length; index += 1) {
            if (path[index].action === MoveAction.TENTATIVE) {
                path[index].action = MoveAction.MOVE;
            }
        }

    }

};

Conveyor.prototype.executePath = function (path) {

    var index,
        heldThing,
        thing;

    for (index = path.length - 1; index >= 0; index -= 1) {

        if (path[index].action === Conveyor.MoveAction.MOVE) {

            thing = this.board.getTile(path[index]);
            this.board.deleteTile(path[index]);

            if (index === path.length - 1) {
                heldThing = thing;
            } else {
                this.board.addThing(path[index + 1], thing);
            }

        }

    }

    if (heldThing) {
        this.board.addThing(path[0], heldThing);
    }

};

Conveyor.prototype.doTick = function () {

    var path;

    if (this.clockwise) {

        this.animationIndex += 1;
        if (this.animationIndex >= Conveyor.animationFrames.length) {
            this.animationIndex = 0;
        }


        path = [
            new Point(this.point.x - 1, this.point.y - 1),
            new Point(this.point.x, this.point.y - 1),
            new Point(this.point.x + 1, this.point.y - 1),
            new Point(this.point.x + 1, this.point.y),
            new Point(this.point.x + 1, this.point.y + 1),
            new Point(this.point.x, this.point.y + 1),
            new Point(this.point.x - 1, this.point.y + 1),
            new Point(this.point.x - 1, this.point.y)
        ];

    } else {

        this.animationIndex -= 1;
        if (this.animationIndex < 0) {
            this.animationIndex = Conveyor.animationFrames.length - 1;
        }

        path = [
            new Point(this.point.x - 1, this.point.y - 1),
            new Point(this.point.x - 1, this.point.y),
            new Point(this.point.x - 1, this.point.y + 1),
            new Point(this.point.x, this.point.y + 1),
            new Point(this.point.x + 1, this.point.y + 1),
            new Point(this.point.x + 1, this.point.y),
            new Point(this.point.x + 1, this.point.y - 1),
            new Point(this.point.x, this.point.y - 1)
        ];

    }

    this.markPath(path);
    this.executePath(path);

    this.spriteIndex = Conveyor.animationFrames[this.animationIndex];

};

//--------------------------------------------------------------------------------

/**
 * Door is a Thing that acts as an obstacle unless an associated Key has been
 * collected first.
 */
function Door(board) {
    Thing.call(this, board);
    this.spriteIndex = 10;
    this.foreground = Colors.BrightWhite;
    this.background = Colors.Blue;
}
Door.prototype = new Thing();
Door.prototype.constructor = Door;

Door.prototype.deserialize = function (data) {

    Thing.prototype.deserialize.call(this, data);
    this.foreground = Colors.BrightWhite;

    // Sanitize the color if necessary
    if (this.background) {

        if (this.background.isLight()) {
            this.background = this.background.darken();
        }

        if (this.background === Colors.Black) {
            this.background = Colors.White;
        }

    } else {
        this.background = Colors.Blue;
    }

};

/**
 * Delivers a provided message to this Thing. If a TOUCH message is received, then
 * this Door will vanish if an associated Key has been previously collected.
 *
 * @param messageName a name of a message to deliver.
 */
Door.prototype.sendMessage = function (message) {

    var doorType,
        matchingKeyCode;

    if (message === 'TOUCH') {

        // Get a readable door description
        doorType = i18n.getMessage('doors.' + this.background.code);

        // Determine a matching key code
        matchingKeyCode = 'KEY' + this.background.lighten().code;

        if (this.getCounterValue(matchingKeyCode) > 0) {

            // The player has the right key type
            this.remove();
            this.adjustCounter(matchingKeyCode, -1);
            this.board.setDisplayMessage(i18n.getMessage('doors.open', doorType));
            this.play('tcgbcgb+ic');

        } else {

            // The Player does not have the correct key type
            this.board.setDisplayMessage(i18n.getMessage('doors.locked', doorType));
            this.play('t--gc');

        }

    }

};

//--------------------------------------------------------------------------------

function Duplicator(board) {
    UpdateableThing.call(this, board);
    this.MAX_STEPS = 20;
    this.copyDirection = Direction.East;
    this.speed = 10;
    this.spriteIndex = 250;
    this.background = undefined;
    this.currentStep = 0;
    this.foreground = Colors.BrightWhite;
}
Duplicator.prototype = new UpdateableThing();
Duplicator.prototype.constructor = Duplicator;
Duplicator.animationFrames = [250, 249, 7, 9, 111, 79];

Duplicator.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    delete result.color;
    result.copyDirection = Direction.getShortName(this.copyDirection);
    return result;
};

Duplicator.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.background = undefined;
    this.foreground = Colors.BrightWhite;
    this.copyDirection = Direction.fromName(data.copyDirection);
};

Duplicator.prototype.doTick = function () {

    var cloneThing,
        targetThing,
        isFreeSpace,
        clonePoint,
        targetPoint,
        cloned = false;

    this.currentStep += 1;
    if (this.currentStep >= this.MAX_STEPS) {

        this.currentStep = 0;

        // Grab our clone point and thing
        clonePoint = this.point.add(this.copyDirection);
        cloneThing = this.board.getTile(clonePoint);

        // Grab our target point
        targetPoint = this.point.add(Direction.opposite(this.copyDirection));

        // If our target point is on the board, see what's already there
        if (!this.board.isOutside(targetPoint)) {
            targetThing = this.board.getTile(targetPoint);
        } else {
            cloneThing = undefined;
        }

        // If we got a thing to clone...
        if (cloneThing) {

            // Determine if there is free space, or if we can make some by pushing an obstacle
            isFreeSpace = targetThing ? this.board.moveTile(this.point, targetPoint, false, true) : true;

            // If there is free space
            if (isFreeSpace) {

                cloned = true;

                // Create our new thing
                this.board.addThing(targetPoint, cloneThing.clone());

            }

        }


        this.play(cloned ? 'scdefg' : '--g#f#');



    }

    this.spriteIndex = Duplicator.animationFrames[Math.round((this.currentStep / this.MAX_STEPS) * (Duplicator.animationFrames.length - 1))];

};

//--------------------------------------------------------------------------------

function Explosion(board) {
    UpdateableThing.call(this, board);
    this.radius = 4;
    this.timeToLive = Explosion.MAX_TTL;
    this.speed = 1;
    this.spriteIndex = 0;
}
Explosion.prototype = new UpdateableThing();
Explosion.prototype.constructor = Explosion;
Explosion.MAX_TTL = 5;

Explosion.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.radius = data.radius || 4;
    this.timeToLive = data.timeToLive || Explosion.MAX_TTL;
};

Explosion.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize(this);
    result.radius = this.radius;
    result.timeToLive = this.timeToLive;
    return result;
};

Explosion.prototype.doTick = function () {

    var points,
        index,
        tile;

    // If we're at the start of our explosion, send a BOMBED message to all affected Things
    if (this.timeToLive === Explosion.MAX_TTL) {

        this.play('t+++c-c-c-c-c-c', true);

        points = utilities.pointsInCircle(this.point, this.radius);

        for (index = 0; index < points.length; index += 1) {
            tile = this.board.getTile(points[index]);
            if (tile) {
                tile.sendMessage('BOMBED');
            }
        }
    }

    // After our time to live, remove ourselves
    this.timeToLive -= 1;
    if (this.timeToLive <= 0) {
        this.remove();
    }

};

Explosion.prototype.getTorch = function () {
    return utilities.generateCircleData(this.point, Math.round((this.radius * this.timeToLive) / (Explosion.MAX_TTL - 1)) + 2);
};

Explosion.prototype.render = function (context) {

    var points,
        index,
        sprite = this.board.game.resources.graphics.getSprite(176 + Math.round((2 * this.timeToLive) / Explosion.MAX_TTL)),
        radius;

    if (this.timeToLive === Explosion.MAX_TTL) {
        radius = Math.round(this.radius / 2);
    } else {
        radius = Math.round((this.radius * this.timeToLive) / (Explosion.MAX_TTL - 1));
    }

    points = utilities.pointsInCircle(this.point, radius);

    for (index = 0; index < points.length; index += 1) {
        sprite.draw(context, points[index].subtract(this.board.windowOrigin), Colors.Yellow, Colors.Red);
    }

};

//--------------------------------------------------------------------------------

/**
 * FakeWall looks like a normal Wall, but is surrenderable to whatever Thing wishes
 * to move there.
 *
 * @param board An owner board for this FakeWall
 */
function FakeWall(board) {
    Thing.call(this, board);
    this.spriteIndex = 178;
    this.foreground = Colors.Yellow;
    this.background = Colors.Black;
}
FakeWall.prototype = new Thing();
FakeWall.prototype.constructor = FakeWall;

/**
 * Returns whether or not this FakeWall is surrenderable to another thing.
 *
 * @param sender Another Thing that is requesting this Thing to surrender
 * @return true if this Thing is willing to surrender its position.
 */
FakeWall.prototype.isSurrenderable = function () {
    return true;
};

/**
 * Retrieves a sprite index used to represent this FakeWall on a rendered
 * Board. If this FakeWall's owner board's game is in debug mode, then a visible
 * representation will be used.
 */
FakeWall.prototype.getSpriteIndex = function () {
    return this.board.game.isEditor ? 176 : 178;
};

//--------------------------------------------------------------------------------

/*
 * Forest acts as a non-pushable obstacle, like a wall, but it vanishes when the
 * player attempts to move to its location, clearing this Thing from the board.
 *
 * @param board An owner board for this Forest
 */
function Forest(board) {
    Thing.call(this, board);
    this.spriteIndex = 176;
    this.foreground = Colors.Black;
    this.background = Colors.Green;
}
Forest.prototype = new Thing();
Forest.noteCycle = ['e', '-b', 'f#', 'b', 'f', 'c', 'g', '+c'];
Forest.noteIndex = 0;
Forest.prototype.constructor = Forest;

/**
 * Serializes this Forest into a data object.
 */
Forest.prototype.serialize = function () {
    var result = Thing.prototype.serialize.call(this);
    delete result.color;
    return result;
};

/**
 * Deserializes a provided data Object into Forest.
 *
 * @param data A data object to be deserialized into Forest.
 */
Forest.prototype.deserialize = function (data) {
    Thing.prototype.deserialize.call(this, data);
    this.background = Colors.Green;
    this.foreground = Colors.Black;
};

/**
 * Delivers a provided message to this Thing. If a TOUCH message is received,
 * then this Forest will be deleted from the board, allowing movement onto its
 * space.
 *
 * @param messageName a name of a message to deliver.
 */
Forest.prototype.sendMessage = function (message) {
    if (message === 'TOUCH') {

        this.oneTimeMessage('status.forest');

        this.play(Forest.noteCycle[Forest.noteIndex]);

        Forest.noteIndex += 1;

        if (Forest.noteIndex >= Forest.noteCycle.length) {
            Forest.noteIndex = 0;
        }

        this.board.deleteTile(this.point);
    }
};

//--------------------------------------------------------------------------------

function Gem(board) {
    Thing.call(this, board);
    this.spriteIndex = 4;
    this.background = undefined;
    this.foreground = Colors.BrightMagenta;
    this.conveyable = true;
}
Gem.prototype = new Thing();
Gem.prototype.constructor = Gem;

/**
 * Delivers a provided message to this Thing. If a TOUCH message is received,
 * then the game's Gems counter will increase by 1, the health counter will increase
 * by 1, and the score counter will inrease by 10.
 *
 * @param messageName a name of a message to deliver.
 */
Gem.prototype.sendMessage = function (message) {
    if (message === 'TOUCH') {
        this.oneTimeMessage('status.gem');
        this.remove();
        this.adjustCounter('HEALTH', 1);
        this.adjustCounter('GEMS', 1);
        this.adjustCounter('SCORE', 10);
        this.play('t+c-gec');
    } else if (message === 'SHOT' || message === 'BOMBED') {
        this.remove();
        this.play('t-c');
    }
};

/**
 * Pushes this Gem in a provided direction. If this Gem cannot be pushed,
 * then it will be squished and removed from its owner Board.
 *
 * @param direction A direction in which to push this Gem.
 */
Gem.prototype.push = function (direction, pusher) {

    if (pusher.type === 'River') {
        this.move(direction, true);
    } else if (!this.move(direction)) {
        this.remove();
    }

};

//--------------------------------------------------------------------------------

function Heart(board) {
    Thing.call(this, board);
    this.spriteIndex = 3;
    this.foreground = Colors.BrightRed;
    this.background = undefined;
    this.conveyable = true;
}
Heart.prototype = new Thing();
Heart.prototype.constructor = Heart;

Heart.prototype.serialize = function () {
    var result = Thing.prototype.serialize.call(this);
    delete result.color;
    return result;
};

Heart.prototype.deserialize = function (data) {
    Thing.prototype.deserialize.call(this, data);
    this.foreground = Colors.BrightRed;
    this.background = undefined;
};

Heart.prototype.sendMessage = function (message) {
    if (message === 'TOUCH') {
        this.remove();
        this.play('tcefg+ceg');
        this.adjustCounter('HEALTH_MAX', 10);
        this.adjustCounter('HEALTH', 10);
        this.adjustCounter('SCORE', 500);
        this.board.setDisplayMessage(i18n.getMessage('status.heart'));
    }
};

Heart.prototype.push = function (direction, pusher) {

    if (pusher.type === 'River') {
        this.move(direction, true);
    } else {
        this.move(direction);
    }

};

//--------------------------------------------------------------------------------

/*
 * InvisibleWall will appear invisible until it is touched, at which point it
 * becomes a regular Wall.
 *
 * @param board An owner Board.
 */
function InvisibleWall(board) {
    Thing.call(this, board);
    this.spriteIndex = 0;
    this.foreground = Colors.BrightGreen;
}
InvisibleWall.prototype = new Thing();
InvisibleWall.prototype.constructor = InvisibleWall;

/**
 * Delivers a provided message to this Thing. If a TOUCH message is received,
 * then this Thing will turn into a Wall Thing.
 *
 * @param messageName a name of a message to deliver.
 */
InvisibleWall.prototype.sendMessage = function (message) {

    var Wall = exports.things.Wall,
        replacement;

    if (message === 'TOUCH') {
        replacement = new Wall();
        replacement.foreground = this.foreground;
        replacement.background = this.background;
        this.oneTimeMessage('status.invisible');
        this.board.replaceTile(this.point, replacement);
        this.play('t--dc');
    }
};

/**
 * Returns a sprite index to be used to represent this InvisibleWall.
 * If we detect that we are in a game editor, 176 will be used. Otherwise, 0.
 *
 * @return A sprite index.
 */
InvisibleWall.prototype.getSpriteIndex = function () {
    return this.board.game.isEditor ? 176 : 0;
};

//--------------------------------------------------------------------------------

/**
 * Key is a Thing representing a collectable key item. One key of a given color
 * may be collected at a time. Keys are used to unlock Door Things.
 *
 * @param board An owner Board for this Key.
 */
function Key(board) {
    Thing.call(this, board);
    this.spriteIndex = 12;
    this.background = undefined;
    this.foreground = Colors.BrightBlue;
    this.conveyable = true;
}
Key.prototype = new Thing();
Key.prototype.constructor = Key;

Key.prototype.deserialize = function (data) {
    Thing.prototype.deserialize.call(this, data);

    // Keys can only be bright colors
    this.foreground = this.foreground.lighten();

    // Grey and flashing keys don't exist either, so assume white
    if (this.foreground instanceof CyclingColor || this.foreground === Colors.Grey) {
        this.foreground = Colors.BrightWhite;
    }

    this.background = undefined;
};

/**
 * Delivers a provided message to this Thing. If a TOUCH message is
 * received, then this Key will be collected, if an existing Key of this
 * type has not already been collected.
 *
 * @param messageName a name of a message to deliver.
 */
Key.prototype.sendMessage = function (message) {

    var keyType;

    if (message === 'TOUCH') {

        // Get a readable description of this key type
        keyType = i18n.getMessage('keys.' + this.foreground.code);

        // Determine if the player has the key already
        if (this.getCounterValue('KEY' + this.foreground.code) > 0) {

            // The player already has this key type
            this.board.setDisplayMessage(i18n.getMessage('keys.toomany', keyType));
            this.play('sc-c');

        } else {

            // The player doesn't yet have the right key type
            this.remove();
            this.adjustCounter('KEY' + this.foreground.code, 1);
            this.board.setDisplayMessage(i18n.getMessage('keys.collect', keyType));
            this.play('t+cegcegceg+sc');
        }

    }
};

/**
 * Receives a request to be pushed in a given direction.
 *
 * @param direction A direction in which this Thing is requested to move.
 */
Key.prototype.push = function (direction, pusher) {

    if (pusher.type === 'River') {
        this.move(direction, true);
    } else if (pusher.type !== 'Player' && this.move(direction)) {
        this.play('t--f', false, true);
    }
};

//--------------------------------------------------------------------------------
function Lava(board) {
    Thing.call(this, board);
    this.background = Colors.BrightRed;
    this.foreground = Colors.BrightRed;
    this.cycleCount = 0;
    this.cycleRate = board.game.CYCLE_RATE * 5;
    this.spriteIndex = 176;
}
Lava.prototype = new Thing();
Lava.prototype.constructor = Lava;

Lava.prototype.serialize = function () {
    var result = Thing.prototype.serialize.call(this);
    delete result.color;
    return result;
};

Lava.prototype.deserialize = function (data) {
    Thing.prototype.deserialize.call(this, data);
    this.background = Colors.BrightRed;
    this.foreground = Colors.BrightRed;
};

Lava.prototype.updateWhileUnder = function () {

    var thing = this.board.getTile(this.point);

    // If a player stepped on the lava...
    if (thing.type === 'Player') {

        // Damage the player every five cycles
        this.cycleCount += 1;
        if (this.cycleCount > this.cycleRate) {
            this.cycleCount = 0;
            thing.sendMessage('SHOT');
        }

    } else if (thing.type === 'Scriptable') {

        // Scriptables get sent a LAVA message
        thing.sendMessage('LAVA');

    } else if (!thing.lavaWalker) {

        // Anything else that's not a lava walker, gets
        // sent a SHOT message immediately.
        thing.sendMessage('SHOT');

    }

};

Lava.prototype.sendMessage = function (message) {
    if (message === 'TOUCH') {
        this.cycleCount = 0;
        this.board.player.sendMessage('SHOT');
    }
};

Lava.prototype.isSurrenderable = function () {
    return true;
};

//--------------------------------------------------------------------------------

/*
 * LineWall is a Thing representing an immoveable obstacle with line decoration.
 *
 * @param board An owner board for this LineWall.
 */
function LineWall(board) {
    Thing.call(this, board);
    this.spriteIndex = undefined;
}
LineWall.prototype = new Thing();
LineWall.prototype.constructor = LineWall;
LineWall.lineMap = {
    '': 249,
    'N': 208,
    'E': 198,
    'S': 210,
    'W': 181,
    'NE': 200,
    'NS': 186,
    'NW': 188,
    'ES': 201,
    'EW': 205,
    'SW': 187,
    'NES': 204,
    'NEW': 202,
    'NSW': 185,
    'ESW': 203,
    'NESW': 206
};

/**
 * Retrieves a sprite index to be used when visually representing this LineWall on a rendered
 * game Board. The sprite index of this LineWall will depend on its surroundings, altering
 * its image when connecting LineWalls are found.
 */
LineWall.prototype.getSpriteIndex = function () {

    if (this.spriteIndex !== undefined && !this.board.game.isEditor) {
        return this.spriteIndex;
    }

    function isLineAdjacent(source, direction) {
        var tile = source.board.getTile(source.point.add(direction));
        return tile && tile.type === 'LineWall';
    }

    var surroundingPattern = '';
    surroundingPattern += isLineAdjacent(this, Direction.North) ? 'N' : '';
    surroundingPattern += isLineAdjacent(this, Direction.East) ? 'E' : '';
    surroundingPattern += isLineAdjacent(this, Direction.South) ? 'S' : '';
    surroundingPattern += isLineAdjacent(this, Direction.West) ? 'W' : '';

    this.spriteIndex = LineWall.lineMap[surroundingPattern];
    return this.spriteIndex;

};

//--------------------------------------------------------------------------------

/**
 * Lion is an UpdateableThing representing a lion enemy, which moves around
 * with a specified randomness and attacks the player.
 */
function Lion(board) {
    UpdateableThing.call(this, board);
    this.intelligence = 3;
    this.spriteIndex = 234;
    this.foreground = Colors.BrightRed;
    this.background = undefined;
    this.speed = 2;
    this.conveyable = true;
}
Lion.prototype = new UpdateableThing();
Lion.prototype.constructor = Lion;

/**
 * Serializes this Lion to an Object.
 *
 * @return A serialized Lion
 */
Lion.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    delete result.color;
    result.intelligence = this.intelligence;
    return result;
};

/**
 * Deserializes this Lion from a provided data Object
 *
 * @param data A data Lion object to be deserialized.
 */
Lion.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.background = undefined;
    this.foreground = Colors.BrightRed;
    this.intelligence = data.intelligence;
};

/**
 * Delivers a provided message to this Thing. If a SHOT message is received,
 * then this Lion will be deleted from the board. If a TOUCH message is
 * received, then the player will be sent a SHOT message.
 *
 * @param messageName a name of a message to deliver.
 */
Lion.prototype.sendMessage = function (message) {

    if (message === 'SHOT' || message === 'BOMBED') {
        this.play('t+c---c++++c--c', true);
        this.adjustCounter('SCORE', 10);
        this.remove();
    } else if (message === 'TOUCH') {
        this.board.player.sendMessage('SHOT');
        this.remove();
    }

};

/**
 * Receives a request to be pushed in a given direction.
 *
 * @param direction A direction in which this Thing is requested to move.
 */
Lion.prototype.push = function (direction, pusher) {

    if (pusher.type === 'River') {
        this.move(direction, true);
    } else if (!this.move(direction)) {
        this.play('t+c---c++++c--c');
        this.remove();
    }

};

/**
 * Returns whether or not this Lion should seek the player during its next move.
 * The probability of a true result depends on this Lion's intelligence
 * property.
 *
 * @return true if this Lion should seek the player, false otherwise.
 */
Lion.prototype.seekPlayer = function () {

    var randomValue = Math.floor(Math.random() * 10);
    return randomValue <= this.intelligence;

};

/**
 * Updates this Lion for a provided timestamp. This Lion will move itself randomly
 * during updates. If a Player blocks its movement, then the player will be sent
 * a SHOT message and this Lion will be removed from its parent board.
 */
Lion.prototype.doTick = function () {

    var direction = this.seekPlayer() ? this.getPlayerDirection() : Direction.random(),
        thing = this.board.getTile(this.point.add(direction));

    if (thing && thing.type === 'Player') {
        thing.sendMessage('SHOT');
        this.remove();
        return;
    }

    // Don't move in the direction of a River
    if (thing && thing.type === 'River' && thing.direction === Direction.opposite(direction)) {
        return;
    }

    this.move(direction, true);

};

//--------------------------------------------------------------------------------

/**
 * Passage is a Thing capable of moving a player to its matching passage on a target board.
 *
 * @param board An owner board for this Passage
 */
function Passage(board) {
    Thing.call(this, board);
    this.spriteIndex = 240;
    this.foreground = Colors.BrightWhite;
    this.background = Colors.Blue;
    this.targetBoard = undefined;
    this.passageId = 0;
    this.glow = true;
}
Passage.prototype = new Thing();
Passage.prototype.constructor = Passage;

/**
 * Delivers a provided message to this Thing. If a TOUCH message is received,
 * then this Passage will move the player to a matching Passage on its target board.
 *
 * @param messageName a name of a message to deliver.
 */
Passage.prototype.sendMessage = function (message) {
    if (message === 'TOUCH') {
        this.play('tceg tc#fg# tdf#a td#ga# teg#+c');
        this.board.game.movePlayerToPassage(this.passageId, this.targetBoard);
    }
};

/**
 * Serializes this Passage to an Object.
 *
 * @return A serialized Passage
 */
Passage.prototype.serialize = function () {
    var result = Thing.prototype.serialize.call(this);
    result.passageId = this.passageId;
    result.targetBoard = this.targetBoard;
    return result;
};

/**
 * Deserializes a provided data Object into a Passage.
 *
 * @param data A data object to be deserialized into a Passage.
 */
Passage.prototype.deserialize = function (data) {
    Thing.prototype.deserialize.call(this, data);
    this.foreground = Colors.BrightWhite;
    if (!this.background) {
        this.background = Colors.Blue;
    }
    this.targetBoard = data.targetBoard;
    this.passageId = data.passageId;
};


//--------------------------------------------------------------------------------

/*
 * Player is an UpdateableThing that is controllable by the user and represents
 * the primary action point for gameplay.
 *
 * @param board An owner board for this Player.
 */
function Player(board) {
    UpdateableThing.call(this, board);

    this.name = 'Player';
    this.spriteIndex = 2;
    this.point = new Point(-1, -1);
    this.foreground = Colors.BrightWhite;
    this.background = Colors.Blue;
    this.conveyable = true;

    if (board) {
        this.eventScheduler = new DelayedEventScheduler(board.game.CYCLE_TICKS * 2, 0);
    }

    this.game = undefined;
    this.speed = 1;
    this.glow = true;



}
Player.prototype = new UpdateableThing();
Player.prototype.constructor = Player;

/**
 * Serializes this Player instance. Note that players don't actually
 * get serialized. Instead, any tile under the player is returned.
 */
Player.prototype.serialize = function () {

    return this.under ? this.under.serialize() : 0;

};

/**
 * Receives a request to be pushed in a given direction.
 *
 * @param direction A direction in which this Thing is requested to move.
 */
Player.prototype.push = function (direction) {
    this.move(direction);
};

/**
 * Moves this Thing in a provided Direction and returns its success.
 *
 * @param direction A Direction in which to move this Thing.
 * @return true if the move was successful, false otherwise.
 */
Player.prototype.move = function (direction) {

    // Remember our current location
    var startingPoint = this.point.clone(),
        newLocation = this.point.add(direction),
        thing;

    // First, check if the direction is outside the board
    if (this.board.isOutside(newLocation)) {

        // Find out which direction we're moving to
        direction = this.point.directionTo(newLocation);
        this.board.movePlayerOffBoard(direction);

        // This isn't a typical board move
        return false;

    }

    // If we're not moving off board, inspect the thing we're moving to
    thing = this.board.getTile(newLocation);

    // If there's a tile there, send it a touch message
    if (thing) {
        thing.sendMessage('TOUCH');
    }

    // If the player wasn't already moved as a result of above actions, do our move
    if (this.point.equals(startingPoint)) {
        return this.board.moveTile(this.point, newLocation);
    }

    // Otherwise this wasn't a typical move anymore
    return false;

};

/**
 * Shoots a player bullet in a provided Direction.
 *
 * @param A Direction in which to shoot a player bullet.
 */
Player.prototype.shoot = function (direction) {

    // If we can't shoot on this board, return
    if (this.board.canPlayerShoot(true) <= 0) {
        this.play('02');
        return;
    }

    if (this.getCounterValue('AMMO') > 0) {
        this.adjustCounter('AMMO', -1);
        ThingFactory.shoot(this.board, this.point.add(direction), direction, true);
    } else {
        this.board.setDisplayMessage(i18n.getMessage('status.noammo'));
    }
};

/**
 * Performs an update tick of this Player instance, moving or shooting
 * in its direction, as necessary.
 */
Player.prototype.doTick = function () {

    var event = this.eventScheduler.takeEvent();

    if (event) {
        if (event.type === MOVE_ACTION) {
            this.move(event.direction);
        } else if (event.type === SHOOT_ACTION) {
            this.shoot(event.direction);
        }
    }

};


/**
 * Updates this Player for a single execution cycle. During its update,
 * Player will check for keypresses and move accordingly.
 */
Player.prototype.update = function () {

    var k = this.game.keyboard,
        key = k.getMostRecentPress([k.UP, k.RIGHT, k.DOWN, k.LEFT]);

    if (k.isPressed(k.SHIFT) || k.isPressed(k.SPACE)) {

        if (key === k.UP) {
            this.eventScheduler.scheduleEvent(k.isPressed(k.UP), {'type': SHOOT_ACTION,  'direction': Direction.North});
        } else if (key === k.RIGHT) {
            this.eventScheduler.scheduleEvent(k.isPressed(k.RIGHT), {'type': SHOOT_ACTION, 'direction': Direction.East});
        } else if (key === k.DOWN) {
            this.eventScheduler.scheduleEvent(k.isPressed(k.DOWN), {'type': SHOOT_ACTION, 'direction': Direction.South});
        } else if (key === k.LEFT) {
            this.eventScheduler.scheduleEvent(k.isPressed(k.LEFT), {'type': SHOOT_ACTION, 'direction': Direction.West});
        } else {
            this.eventScheduler.cancelEvent();
        }
    } else {
        if (key === k.UP) {
            this.eventScheduler.scheduleEvent(k.isPressed(k.UP), {'type': MOVE_ACTION, 'direction': Direction.North});
        } else if (key === k.RIGHT) {
            this.eventScheduler.scheduleEvent(k.isPressed(k.RIGHT), {'type': MOVE_ACTION, 'direction': Direction.East});
        } else if (key === k.DOWN) {
            this.eventScheduler.scheduleEvent(k.isPressed(k.DOWN), {'type': MOVE_ACTION, 'direction': Direction.South});
        } else if (key === k.LEFT) {
            this.eventScheduler.scheduleEvent(k.isPressed(k.LEFT), {'type': MOVE_ACTION, 'direction': Direction.West});
        } else {
            this.eventScheduler.cancelEvent();
        }

        // If T has been pressed, and we have 10 seconds or less on our current torch
        if (k.isPressed([k.T])) {
            this.useTorch();
        }

    }

    UpdateableThing.prototype.update.call(this);

    // To stay sufficiently responsive, the player torch has to be initialized explicitly here
    this.board.initializeTorch(this);

};

/**
 * Uses a torch, illuminating surrounding tiles if a given board is
 * dark.
 */
Player.prototype.useTorch = function () {

    // If the player has more than 10 seconds left on the current torch,
    // then they don't need another yet.
    if (this.game.getCounterValue('TORCHLIFE') > 10000) {
        return;
    }

    // If the player has torches available...
    if (this.game.getCounterValue('TORCHES') > 0) {

        // If the room isn't dark, let the player keep the torch
        if (!this.board.dark) {
            this.board.setDisplayMessage(i18n.getMessage('status.notdark'));
            return;
        }

        // Decrease our torch count
        this.game.adjustCounter('TORCHES', -1);

        // Specify that we're now using a torch
        this.game.setCounterValue('TORCHLIFE', TORCH_TTL);

    } else {

        // Display a message indicating we have no torches
        this.board.setDisplayMessage(i18n.getMessage('status.notorches'));

    }


};

/**
 * Retrieves a torch area for this Player, if the player's torch is currently active.
 */
Player.prototype.getTorch = function () {

    var torchLife = this.game.getCounterValue('TORCHLIFE'),
        torchStrength = MAX_TORCH_STRENGTH;

    // If we've got a torch...
    if (torchLife > 0) {

        // Start shrinking the radius when there's only 20 seconds left
        if (torchLife < 20000) {
            torchStrength = Math.ceil((torchLife * MAX_TORCH_STRENGTH) / (TORCH_TTL / 3));
        }

        return utilities.generateCircleData(this.point, torchStrength);

    }

};

/**
 * Delivers a provided message to this Thing.
 *
 * @param messageName a name of a message to deliver.
 */
Player.prototype.sendMessage = function (message) {

    if (message === 'SHOT' || message === 'BOMBED') {
        this.play('t--c+c-c+d#', true);
        this.adjustCounter('HEALTH', -10);
        this.board.playerHurt();
    }

};

//--------------------------------------------------------------------------------

/**
 * Pusher represents an UpdateableThing that continually moves in a defined direction,
 * pushing obstacles in its path.
 *
 * @param board An owner board for this Pusher.
 */
function Pusher(board) {
    UpdateableThing.call(this, board);
    this.orientation = Direction.South;
    this.speed = 3;
    this.initializeSprite();
}
Pusher.prototype = new UpdateableThing();
Pusher.prototype.constructor = Pusher;

/**
 * Initializes a spriteIndex for this Pusher based on its defined
 * direction.
 */
Pusher.prototype.initializeSprite = function () {
    if (this.orientation === Direction.North) {
        this.spriteIndex = 30;
    } else if (this.orientation === Direction.East) {
        this.spriteIndex = 16;
    } else if (this.orientation === Direction.South) {
        this.spriteIndex = 31;
    } else if (this.orientation === Direction.West) {
        this.spriteIndex = 17;
    }
};

/**
 * Serializes this Pusher instance to an object.
 *
 * @return A serialized Pusher
 */
Pusher.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    result.orientation = Direction.getName(this.orientation);
    return result;
};

/**
 * Deserializes a provided data object into a Pusher instance.
 *
 * @param data Serializes Pusher data to be deserialized.
 */
Pusher.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.background = undefined;
    if (data.orientation) {
        this.orientation = Direction.fromName(data.orientation);
    }
    this.initializeSprite();
};

/**
 * Performs a tick update of this Pusher.
 */
Pusher.prototype.doTick = function () {
    if (this.move(this.orientation)) {
        this.play('t--f', false, true);
    }
};

//--------------------------------------------------------------------------------

/**
 * Ricochet is a Thing that reflects bullets.
 *
 * @param board An owner board for this Ricochet.
 */
function Ricochet(board) {
    Thing.call(this, board);
    this.spriteIndex = 42;
    this.background = undefined;
    this.foreground = Colors.BrightGreen;
}
Ricochet.prototype = new Thing();
Ricochet.prototype.constructor = Ricochet;

/**
 * Serializes this Ricochet to a data object.
 */
Ricochet.prototype.serialize = function () {
    var result = Thing.prototype.serialize.call(this);
    delete result.color;
    return result;
};

/**
 * Deserializes this Ricochet from a data object.
 */
Ricochet.prototype.deserialize = function (data) {
    Thing.prototype.deserialize.call(this, data);
    this.background = undefined;
    this.foreground = Colors.BrightGreen;
};

//--------------------------------------------------------------------------------

function River(board) {
    Thing.call(this, board);
    this.direction = Direction.North;
    this.background = Colors.Blue;
    this.foreground = Colors.BrightBlue;
    this.speed = 1;
    this.initialize();
}
River.prototype = new Thing();
River.prototype.constructor = River;

River.prototype.initialize = function () {
    switch (Direction.getShortName(this.direction)) {
    case 'N':
        this.spriteIndex = 30;
        break;
    case 'E':
        this.spriteIndex = 16;
        break;
    case 'S':
        this.spriteIndex = 31;
        break;
    case 'W':
        this.spriteIndex = 17;
        break;
    }
};

River.prototype.updateWhileUnder = function () {
    UpdateableThing.prototype.update.call(this);
};

River.prototype.doTick = function () {

    var thing = this.board.getTile(this.point);

    if (thing.conveyable) {
        thing.push(this.direction, this);
    }

};

River.prototype.isSurrenderable = function () {
    return true;
};

River.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    delete result.color;
    delete result.speed;
    result.direction = Direction.getShortName(this.direction);
    return result;
};

River.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.background = Colors.Blue;
    this.foreground = Colors.BrightBlue;
    this.direction = Direction.fromName(data.direction);
    this.initialize();
};

//--------------------------------------------------------------------------------


/**
 * Ruffian is an UpdateableThing that attacks in a burst of movement, followed
 * by a wait time, then another burst of movement.
 *
 * @param board An owner board for this Ruffian.
 */
function Ruffian(board) {
    UpdateableThing.call(this, board);
    this.spriteIndex = 5;
    this.background = undefined;
    this.foreground = Colors.BrightMagenta;
    this.intelligence = 5;
    this.restingTime = 5;
    this.moving = false;
    this.timeLeft = 0;
    this.speed = 1;
    this.orientation = Direction.North;
    this.conveyable = true;
}
Ruffian.prototype = new UpdateableThing();
Ruffian.prototype.constructor = Ruffian;

/**
 * Serializes this Ruffian to a data object.
 *
 * @return A serialized Ruffian.
 */
Ruffian.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    delete result.color;
    result.intelligence = this.intelligence;
    result.restingTime = this.restingTime;
    return result;
};

/**
 * Deserializes a provided data object, configuring this Ruffian.
 *
 * @param data A data object to be deserialized into a Ruffian.
 */
Ruffian.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.background = undefined;
    this.foreground = Colors.BrightMagenta;
    this.intelligence = data.intelligence || 5;
    this.restingTime = data.restingTime || 5;
};

/**
 * Pushes this Ruffian instance in a given direction. If this Ruffian
 * cannot be pushed, it will be squished and removed from its owner Board.
 *
 * @param direction A direction in which to push this Ruffian.
 */
Ruffian.prototype.push = function (direction, pusher) {

    if (pusher && pusher.type === 'River') {
        this.move(direction, true);
    } else if (!this.move(direction)) {
        this.remove();
        this.play('t+c---c++++c--c');
    }

};

/**
 * Sends a provided message to this Ruffian.
 *
 * @param message A message to be delivered to this Ruffian.
 */
Ruffian.prototype.sendMessage = function (message) {
    if (message === 'SHOT' || message === 'BOMBED') {
        this.play('t+c---c++++c--c', true);
        this.adjustCounter('SCORE', 10);
        this.remove();
    } else if (message === 'TOUCH') {
        this.board.player.sendMessage('SHOT');
        this.remove();
    }
};

/**
 * Returns whether or not this Ruffian should seek the player during its next move.
 * The probability of a true result depends on this Ruffian's intelligence
 * property.
 *
 * @return true if this Ruffian should seek the player, false otherwise.
 */
Ruffian.prototype.seekPlayer = function () {

    var randomValue = Math.floor(Math.random() * 10);
    return randomValue <= this.intelligence;

};

/**
 * Performs an update tick for this Ruffian instance.
 */
Ruffian.prototype.doTick = function () {

    // Decrement our remaining time and check if it has elapsed...
    this.timeLeft -= 1;
    if (this.timeLeft <= 0) {

        // Toggle our movement status
        this.moving = !this.moving;

        // If we're about to move, choose a direction and duration
        if (this.moving) {
            this.orientation = this.seekPlayer() ? this.getPlayerDirection() : Direction.random();
            this.timeLeft = Math.floor(Math.random() * 10);
        } else {
            this.timeLeft = Math.floor(Math.random() * 10) - (10 - this.restingTime);
        }

    }

    // If we're moving...
    if (this.moving) {

        // Determine what's in our way
        var thing = this.board.getTile(this.point.add(this.orientation));

        // If it's the player, attack it
        if (thing && thing.type === 'Player') {
            thing.sendMessage('SHOT');
            this.remove();
            return;
        }

        // Don't move in the direction of a River
        if (thing && thing.type === 'River' && thing.direction === Direction.opposite(this.orientation)) {
            return;
        }

        // Otherwise just move
        this.move(this.orientation, true);

    }

};

//--------------------------------------------------------------------------------

/**
 * Signpost is a Thing that displays a message when touched.
 *
 * @param board An owner board
 */
function Signpost(board) {
    Thing.call(this, board);
    this.spriteIndex = 209;
    this.background = undefined;
    this.foreground = Colors.Brown;
    this.text = undefined;
}
Signpost.prototype = new Thing();
Signpost.prototype.constructor = Signpost;

Signpost.prototype.serialize = function () {
    var result = Thing.prototype.serialize.call(this);
    delete result.color;
    result.text = this.text;
    return result;
};

Signpost.prototype.deserialize = function (data) {
    Thing.prototype.deserialize.call(this, data);
    this.background = undefined;
    this.foreground = Colors.Brown;
    this.text = data.text;
};

Signpost.prototype.sendMessage = function (message) {

    var lines,
        index,
        text;

    if (message === 'TOUCH') {

        this.board.game.scroll.setTitle(i18n.getMessage('obstacles.signpost'));
        this.board.game.scroll.clearLines();

        if (!this.text) {
            this.text = i18n.getMessage('obstacles.signpostmessage');
        }

        lines = this.text.split('\n');
        for (index = 0; index < lines.length; index += 1) {
            text = i18n.getBoardMessage(this.board, lines[index]);
            this.board.game.scroll.addLine(text);
        }

        this.play('tc-c+d-d+e-e+f-f+g-g');
        this.board.game.setState(GameState.Reading);

    }

};

//--------------------------------------------------------------------------------

/**
 * SliderEw is a Thing that is pushable only in the East and West direction.
 *
 * @param board An owner board.
 */
function SliderEw(board) {
    Thing.call(this, board);
    this.spriteIndex = 29;
    this.background = undefined;
    this.foreground = Colors.BrightWhite;
}
SliderEw.prototype = new Thing();
SliderEw.prototype.constructor = SliderEw;

/**
 * Receives a request to be pushed in a given direction.
 *
 * @param direction A direction in which this Thing is requested to move.
 */
SliderEw.prototype.push = function (direction) {
    if (direction.equals(Direction.East) || direction.equals(Direction.West)) {
        if (this.move(direction)) {
            this.play('t--f', false, true);
        }
    }
};

//--------------------------------------------------------------------------------

/**
 * SliderNs is a Thing that is pushable only in the North and South direction.
 *
 * @param board An owner board.
 */
function SliderNs(board) {
    Thing.call(this, board);
    this.spriteIndex = 18;
    this.background = undefined;
    this.foreground = Colors.BrightWhite;
}
SliderNs.prototype = new Thing();
SliderNs.prototype.constructor = SliderNs;

/**
 * Receives a request to be pushed in a given direction.
 *
 * @param direction A direction in which this Thing is requested to move.
 */
SliderNs.prototype.push = function (direction) {
    if (direction.equals(Direction.North) || direction.equals(Direction.South)) {
        if (this.move(direction)) {
            this.play('t--f', false, true);
        }
    }
};

//--------------------------------------------------------------------------------

/**
 * Snake is a touch baddie that intelligently finds the player along a precomputed
 * smart path.
 */
function Snake(board) {
    UpdateableThing.call(this, board);
    this.spriteIndex = 235;
    this.background = undefined;
    this.foreground = Colors.Green;
    this.conveyable = true;
    this.speed = 3;
}
Snake.prototype = new UpdateableThing();
Snake.prototype.constructor = Snake;

Snake.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    delete result.color;
    return result;
};

/**
 * Attempts to push this Snake in a provided direction.
 */
Snake.prototype.push = function (direction) {
    if (!this.move(direction)) {
        this.remove();
        this.play('t+c---c++++c--c');
    }
};

/**
 * Sends a provided message to this Ruffian.
 *
 * @param message A message to be delivered to this Ruffian.
 */
Snake.prototype.sendMessage = function (message) {
    if (message === 'SHOT' || message === 'BOMBED') {
        this.play('t+c---c++++c--c', true);
        this.adjustCounter('SCORE', 10);
        this.remove();
    } else if (message === 'TOUCH') {
        this.board.player.sendMessage('SHOT');
        this.remove();
    }
};

/**
 * Updates this Snake. This Snake will move itself along the board's current
 * smart path directly toward the player, going around walls and obstacles.
 * If there is no direct path to the player (including through bullets and
 * other baddies), then it will rest in place.
 */
Snake.prototype.doTick = function () {

    var direction = this.getSmartDirection(),
        thing;

    if (direction) {

        this.foreground = Colors.BrightGreen;

        thing = this.board.getTile(this.point.add(direction));
        if (thing && thing.type === 'Player') {
            thing.sendMessage('SHOT');
            this.remove();
            return;
        }
        this.move(direction, true);

    } else {
        this.foreground = Colors.Green;
    }


};

//--------------------------------------------------------------------------------

/*
 * SolidWall is a Thing representing an immoveable obstacle.
 *
 * @param board An owner board for this SolidWall.
 */
function SolidWall(board) {
    Thing.call(this, board);
    this.spriteIndex = 219;
}
SolidWall.prototype = new Thing();
SolidWall.prototype.constructor = SolidWall;

//--------------------------------------------------------------------------------

/**
 * Spider is an UpdateableThing that only moves along SpideWebs.
 *
 * @param board An owner Board for this Spider
 */
function Spider(board) {
    UpdateableThing.call(this, board);
    this.spriteIndex = 15;
    this.foreground = Colors.BrightRed;
    this.background = undefined;
    this.intelligence = 5;
    this.speed = 1;
}
Spider.prototype = new UpdateableThing();
Spider.prototype.constructor = Spider;

/**
 * Serializes this Spider instance into a data object.
 *
 * @return A serialized Spider
 */
Spider.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    result.intelligence = this.intelligence;
    return result;
};

/**
 * Deserializes a data object and configure this Spider instance.
 *
 * @param data A data object to be deserialized into a Spider.
 */
Spider.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.intelligence = data.intelligence;
};

/**
 * Returns whether or not this Spider instance should seek the player
 * for an attack, or choose a random direction. This decision is weighted
 * based on this Spider's intelligence property.
 *
 * @return true if this Spider should seek the player, false otherwise
 */
Spider.prototype.seekPlayer = function () {

    var randomValue = Math.floor(Math.random() * 10);
    return randomValue <= this.intelligence;

};

/**
 * Returns whether or not a position in a provided direction is attackable
 * by this Spider. Attackable positions are defined as spider webs
 * or spots occupied by a player.
 *
 * return true if a provided direction is attackable, false otherwise
 */
Spider.prototype.isAttackable = function (direction) {
    var thing = this.board.getTile(this.point.add(direction));
    return thing && (thing.type === 'SpiderWeb' || thing.type === 'Player');
};

/**
 * Delivers a provided message to this Thing. If a SHOT message is received,
 * then this Lion will be deleted from the board. If a TOUCH message is
 * received, then the player will be sent a SHOT message.
 *
 * @param messageName a name of a message to deliver.
 */
Spider.prototype.sendMessage = function (message) {

    if (message === 'SHOT' || message === 'BOMBED') {
        this.play('t+c---c++++c--c', true);
        this.adjustCounter('SCORE', 10);
        this.remove();
    } else if (message === 'TOUCH') {
        this.board.player.sendMessage('SHOT');
        this.remove();
    }

};

/**
 * Receives a request to be pushed in a given direction.
 *
 * @param direction A direction in which this Thing is requested to move.
 */
Spider.prototype.push = function (direction) {
    if (!this.move(direction)) {
        this.play('t+c---c++++c--c');
        this.remove();
    }
};

/**
 * Performs an update tick for this Spider instance.
 */
Spider.prototype.doTick = function () {

    // Get a direction based on our intelligence
    var direction = this.seekPlayer() ? this.getPlayerDirection() : Direction.random(this.getAttackableDirections()),
        thing;

    // If a direction was decided upon...
    if (direction !== undefined) {

        // Determine any obstacle in our way
        thing = this.board.getTile(this.point.add(direction));

        // If it's a player, attack it
        if (thing && thing.type === 'Player') {
            thing.sendMessage('SHOT');
            this.remove();
            return;
        }

        // Move along spider webs
        if (thing && thing.type === 'SpiderWeb') {
            this.move(direction, true);
        }

    }
};

//--------------------------------------------------------------------------------

/**
 * SpiderWeb is a Thing that represents a path along which Spiders will travel.
 *
 * @param board An owner Board for this SpiderWeb.
 */
function SpiderWeb(board) {
    Thing.call(this, board);
    this.spriteIndex = undefined;
    this.foreground = Colors.Grey;
    this.background = undefined;
}
SpiderWeb.prototype = new Thing();
SpiderWeb.prototype.constructor = SpiderWeb;
SpiderWeb.lineMap = {
    '': 249,
    'N': 179,
    'E': 196,
    'S': 179,
    'W': 196,
    'NE': 192,
    'NS': 179,
    'NW': 217,
    'ES': 218,
    'EW': 196,
    'SW': 191,
    'NES': 195,
    'NEW': 193,
    'NSW': 180,
    'ESW': 194,
    'NESW': 197
};

/**
 * Retrieves a sprite index to be used as a visual representation of this SpiderWeb.
 * The index returned depends on the surrounings of this SpiderWeb, which will appear
 * to connect with adjacent spider webs.
 */
SpiderWeb.prototype.getSpriteIndex = function () {

    if (this.spriteIndex !== undefined && !this.board.game.isEditor) {
        return this.spriteIndex;
    }

    function isLineAdjacent(source, direction) {
        var tile = source.board.getTile(source.point.add(direction));
        return (tile && (tile.type === 'SpiderWeb' || (tile.under && tile.under.type === 'SpiderWeb')));
    }

    var surroundingPattern = '';
    surroundingPattern += isLineAdjacent(this, Direction.North) ? 'N' : '';
    surroundingPattern += isLineAdjacent(this, Direction.East) ? 'E' : '';
    surroundingPattern += isLineAdjacent(this, Direction.South) ? 'S' : '';
    surroundingPattern += isLineAdjacent(this, Direction.West) ? 'W' : '';

    this.spriteIndex = SpiderWeb.lineMap[surroundingPattern];
    return this.spriteIndex;

};

/**
 * Returns whether or not this SpiderWeb is surrenderable to another thing.
 *
 * @param sender Another Thing that is requesting this Thing to surrender
 * @return true if this Thing is willing to surrender its position.
 */
SpiderWeb.prototype.isSurrenderable = function () {
    return true;
};

//--------------------------------------------------------------------------------

/**
 * SpinningGun is an UpdateableThing that spins in place and shoots. Its shooting
 * behaviour will depend on its intelligence (which affects when it shoots) and its
 * firing rate (which affects how often it shoots).
 *
 * @param board An owner Board for this SpinningGun.
 */
function SpinningGun(board) {
    UpdateableThing.call(this, board);
    this.intelligence = 5;
    this.firingRate = 5;
    this.spriteIndex = 24;
    this.animationIndex = Math.floor(Math.random() * SpinningGun.animationFrames.length - 1);
    this.speed = 2;
}
SpinningGun.prototype = new UpdateableThing();
SpinningGun.prototype.constructor = SpinningGun;
SpinningGun.animationFrames = [24, 26, 25, 27];

/**
 * Serializes this SpinningGun instance into a data object.
 *
 * @return A serialized SpinningGun.
 */
SpinningGun.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    result.intelligence = this.intelligence;
    result.firingRate = this.firingRate;
    return result;
};

/**
 * Deserializes a provided data object to configure this SpinningGun instance.
 *
 * @param data A serialized SpinningGun data object.
 */
SpinningGun.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.intelligence = data.intelligence || 5;
    this.firingRate = data.firingRate || 5;
};

/**
 * Performs a single update tick of this SpinningGun instance.
 */
SpinningGun.prototype.doTick = function () {

    var me = this;
    function shoot(random) {
        if (Math.floor(Math.random() * 10) <= me.firingRate) {
            var direction = random ? Direction.random() : me.getPlayerDirection();
            ThingFactory.shoot(me.board, me.point.add(direction), direction);
        }
    }

    this.animationIndex += 1;
    if (this.animationIndex >= SpinningGun.animationFrames.length) {
        this.animationIndex = 0;
    }
    this.spriteIndex = SpinningGun.animationFrames[this.animationIndex];

    if (Math.floor(Math.random() * 9) <= this.intelligence) {
        if (this.isPlayerAligned(2)) {
            shoot();
        }
    } else {
        shoot(true);
    }

};

//--------------------------------------------------------------------------------

/**
 * Teleporter is an UpdateableThing capable of teleporting the player
 * to an associated opposite teleporter along the same directional axis.
 *
 * @param board An owner Board for this Teleporter.
 */
function Teleporter(board) {
    UpdateableThing.call(this, board);
    this.orientation = Direction.East;
    this.animationFrame = 2;
    this.speed = 3;
}
Teleporter.prototype = new UpdateableThing();
Teleporter.prototype.constructor = Teleporter;
Teleporter.animationFrames = {
    'North': [196, 126, 94, 126],
    'East': [179, 41, 62, 41],
    'South': [196, 126, 118, 126],
    'West': [179, 40, 60, 40]
};

/**
 * Serializes this Teleporter instance into a data object.
 *
 * @return A data object representing a serialized Teleporter.
 */
Teleporter.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    result.orientation = Direction.getName(this.orientation);
    return result;
};

/**
 * Deserializes a provided data object to configure this Teleporter instance.
 *
 * @param data A data object representing a serialized Teleporter.
 */
Teleporter.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    if (data.orientation) {
        this.orientation = Direction.fromName(data.orientation);
    }
};

/**
 * Performs a single update tick of this Teleporter instance.
 */
Teleporter.prototype.doTick = function () {
    this.animationFrame += 1;
    if (this.animationFrame >= Teleporter.animationFrames[Direction.getName(this.orientation)].length) {
        this.animationFrame = 0;
    }
};

/**
 * Retrieves a sprite index used to visually represent this Teleporter instance on
 * a rendered game Board.
 *
 * @return a sprite index.
 */
Teleporter.prototype.getSpriteIndex = function () {
    return Teleporter.animationFrames[Direction.getName(this.orientation)][this.animationFrame];
};

/**
 * Attempts to push this Teleporter instance in a given direction. This teleporter, rather than
 * be pushed, may teleport the item being pushed to another location on its owner Board, based
 * on this Teleporter's orientation, and the location and orientation of other Teleporters on the board.
 *
 * @param direction A direction in which to push this Teleporter.
 */
Teleporter.prototype.push = function (direction) {

    // We only teleport in our current direction
    if (!this.orientation.equals(direction)) {
        return;
    }

    var currentPoint = this.point.add(Direction.opposite(this.orientation)),
        destinationPoint = this.point.add(this.orientation),
        thing,
        tile = this.board.getTile(destinationPoint),
        success = tile && tile.type === 'Teleporter' ? false : this.board.moveTile(currentPoint, destinationPoint);

    // If we couldn't move the tile to the other side of this teleporter...
    if (!success) {

        // While we haven't reached the edge of the board...
        while (!this.board.isOutside(destinationPoint)) {

            // If we found a matching teleporter...
            thing = this.board.getTile(destinationPoint);
            if (thing && thing.type === 'Teleporter' && thing.orientation === Direction.opposite(this.orientation)) {

                // Move the tile to the matching teleporter's destination
                if (this.board.moveTile(currentPoint, destinationPoint.add(this.orientation))) {
                    this.play('tc+d-e+f#-g#+a#c+d');
                    return true;
                }
                break;

            }

            // Look at the next tile in the direction
            destinationPoint = destinationPoint.add(this.orientation);

        }

    } else {
        this.play('tc+d-e+f#-g#+a#c+d');
        return true;
    }

};

//--------------------------------------------------------------------------------

/**
 * Text is a Thing that displays a character depending on the locale of the game.
 *
 * @param board An owner board for this Thing.
 */
function Text(board) {
    Thing.call(this, board);
    this.i18n = {
        en: 0
    };
    this.foreground = Colors.BrightWhite;
    this.background = Colors.Blue;
}
Text.prototype = new Thing();
Text.prototype.constructor = Text;

/**
 * Serializes this Text into a data object.
 *
 * @return A data object representing a serialized Text.
 */
Text.prototype.serialize = function () {
    var result = Thing.prototype.serialize.call(this);
    result.i18n = this.i18n;
    return result;
};

/**
 * Deserializes a provided data object to configure this Text instance.
 *
 * @param A data object representing a serialized Text.
 */
Text.prototype.deserialize = function (data) {

    Thing.prototype.deserialize.call(this, data);
    this.i18n = data.i18n;
    this.foreground = Colors.BrightWhite;

};

Text.prototype.getSpriteIndex = function () {

    var result;

    if (this.i18n.hasOwnProperty(i18n.getLanguage())) {
        result = this.i18n[i18n.getLanguage()];
    } else {
        result = this.i18n[i18n.DefaultLanguage];
    }

    return result || 0;

};


//--------------------------------------------------------------------------------

/**
 * ThrowingStar is an UpdateableThing representing a projectile that seeks the player
 * continually with a spinning animation until its time to live has expired and it
 * is removed from its owner Board.
 *
 * @param board An owner board for this ThrowingStar.
 */
function ThrowingStar(board) {
    UpdateableThing.call(this, board);
    this.speed = 1;
    this.spriteIndex = 179;
    this.animationIndex = Math.floor(Math.random() * ThrowingStar.animationFrames.length - 1);
    this.foreground = Colors.Cycle;
    this.timeToLive = 255;
    this.nextMove = Math.floor(Math.random() * 2);
}
ThrowingStar.prototype = new UpdateableThing();
ThrowingStar.prototype.constructor = ThrowingStar;
ThrowingStar.animationFrames = [179, 47, 196, 92];

/**
 * Serializes this ThrowingStar into a data object.
 *
 * @return A data object representing a serialized ThrowingStar.
 */
ThrowingStar.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    delete result.color;
    result.timeToLive = this.timeToLive;
    return result;
};

/**
 * Deserializes a provided data object to configure this ThrowingStar instance.
 *
 * @param A data object representing a serialized ThrowingStar.
 */
ThrowingStar.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize.call(this, data);
    this.foreground = Colors.Cycle;
    this.background = undefined;
    this.timeToLive = data.timeToLive || 100;
};

/**
 * Sends a provided message to this ThrowingStar instance.
 *
 * @param message A message to send to this ThrowingStar.
 */
ThrowingStar.prototype.sendMessage = function (message) {
    if (message === 'TOUCH') {
        this.board.player.sendMessage('SHOT');
        this.remove();
    }
};

/**
 * Performs a single update tick of this ThrowingStar instance.
 */
ThrowingStar.prototype.doTick = function () {

    var direction,
        thing;

    this.timeToLive -= 1;
    if (this.timeToLive <= 0) {
        this.remove();
        return;
    }

    this.animationIndex += 1;
    if (this.animationIndex >= ThrowingStar.animationFrames.length) {
        this.animationIndex = 0;
    }
    this.spriteIndex = ThrowingStar.animationFrames[this.animationIndex];

    this.nextMove -= 1;
    if (this.nextMove <= 0) {

        this.nextMove = 2;

        direction = this.getPlayerDirection();
        thing = this.board.getTile(this.point.add(direction));
        if (thing && (thing.type === 'BreakableWall' || thing.type === 'Player')) {
            thing.sendMessage('SHOT');
            this.remove();
            return;
        }
        this.move(this.getPlayerDirection());
    }

};

//--------------------------------------------------------------------------------

/**
 * Tiger is an UpdateableThing representing a creature that moves and shoots
 * bullets at a player.
 *
 * @param board An owner Board for this Tiger.
 */
function Tiger(board) {
    UpdateableThing.call(this, board);
    this.spriteIndex = 227;
    this.foreground = Colors.BrightCyan;
    this.background = undefined;
    this.intelligence = 5;
    this.firingRate = 5;
    this.speed = 2;
    this.conveyable = true;
}
Tiger.prototype = new UpdateableThing();
Tiger.prototype.constructor = Tiger;

/**
 * Serializes this Tiger into a data object.
 *
 * @return A data object representing a serialized Tiger.
 */
Tiger.prototype.serialize = function () {
    var result = UpdateableThing.prototype.serialize.call(this);
    delete result.color;
    result.intelligence = this.intelligence;
    result.firingRate = this.firingRate;
    return result;
};

/**
 * Deserializes a provided data object to configure this Tiger instance.
 *
 * @param data A data object representing a serialized Tiger.
 */
Tiger.prototype.deserialize = function (data) {
    UpdateableThing.prototype.deserialize(this, data);
    this.background = undefined;
    this.foreground = Colors.BrightCyan;
    this.intelligence = data.intelligence === undefined ? 5 : data.intelligence;
    this.firingRate = data.firingRate === undefined ? 5 : data.firingRate;
};

/**
 * Delivers a provided message to this Thing. If a SHOT message is received,
 * then this Tiger will be deleted from the board. If a TOUCH message is
 * received, then the player will be sent a SHOT message.
 *
 * @param messageName a name of a message to deliver.
 */
Tiger.prototype.sendMessage = function (message) {

    if (message === 'SHOT' || message === 'BOMBED') {
        this.play('t+c---c++++c--c', true);
        this.adjustCounter('SCORE', 10);
        this.remove();
    } else if (message === 'TOUCH') {
        this.board.player.sendMessage('SHOT');
        this.remove();
    }

};

/**
 * Receives a request to be pushed in a given direction.
 *
 * @param direction A direction in which this Thing is requested to move.
 */
Tiger.prototype.push = function (direction, pusher) {

    if (pusher && pusher.type === 'River') {
        this.move(direction, true);
    } else if (!this.move(direction)) {
        this.play('t+c---c++++c--c');
        this.remove();
    }

};

/**
 * Returns whether or not this Tiger should seek the player during its next move.
 * The probability of a true result depends on this Tiger's intelligence
 * property.
 *
 * @return true if this Tiger should seek the player, false otherwise.
 */
Tiger.prototype.seekPlayer = function () {

    var randomValue = Math.floor(Math.random() * 10);
    return randomValue <= this.intelligence;

};

/**
 * Returns whether or not this Tiger should shoot the player during its next
 * move. The probability of a true result depends on this Tiger's firing rate
 * property.
 *
 * @return true if this Tiger should shoot the player, false otherwise.
 */
Tiger.prototype.shootPlayer = function () {
    var randomValue = Math.floor(Math.random() * 20);
    return randomValue <= this.firingRate;
};

/**
 * Performs a single update tick of this Tiger.
 */
Tiger.prototype.doTick = function () {

    var direction = this.seekPlayer() ? this.getPlayerDirection() : Direction.random(),
        thing = this.board.getTile(this.point.add(direction)),
        playerDirection;

    if (thing && thing.type === 'Player') {
        thing.sendMessage('SHOT');
        this.remove();
        return;
    }

    // Don't attempt to move in the direction of a river
    if (!(thing && thing.type === 'River' && thing.direction === Direction.opposite(direction))) {
        this.move(direction, true);
    }

    if (this.shootPlayer()) {
        playerDirection = this.getPlayerDirection();
        ThingFactory.shoot(this.board, this.point.add(playerDirection), playerDirection);
    }

};

//--------------------------------------------------------------------------------

/*
 *
 */
function Torch(board) {
    Thing.call(this, board);
    this.spriteIndex = 157;
    this.glow = true;
}
Torch.prototype = new Thing();
Torch.prototype.constructor = Torch;

Torch.prototype.serialize = function () {
    var result = Thing.prototype.serialize.call(this);
    delete result.color;
    return result;
};

Torch.prototype.deserialize = function (data) {
    Thing.prototype.deserialize.call(this, data);
    this.background = undefined;
    this.foreground = Colors.Brown;
};

/**
 * Pushes this Torch in a provided direction on its owner Board.
 *
 * @param direction A direction in which to push this Torch
 */
Torch.prototype.push = function (direction) {
    this.move(direction);
};

/**
 * Sends a provided message to this Torch instance. If a TOUCH message is received
 * then this Torch instance will be removed and increase the Game's 'torches' counter
 * by five units.
 */
Torch.prototype.sendMessage = function (message) {
    if (message === 'TOUCH') {
        this.oneTimeMessage('status.torch');
        this.play('tcase');
        this.adjustCounter('TORCHES', 1);
        this.remove();
    }
};

//--------------------------------------------------------------------------------

/*
 * Wall is a Thing representing an immoveable obstacle.
 *
 * @param board An owner board for this Wall.
 */
function Wall(board) {
    Thing.call(this, board);
    this.spriteIndex = 178;
}
Wall.prototype = new Thing();
Wall.prototype.constructor = Wall;

//--------------------------------------------------------------------------------

/*
 * Water is a Thing representing an obstacle to most Things, except for
 * bullets and other potentially flying Things, which can pass over it.
 */
function Water(board) {
    Thing.call(this, board);
    this.spriteIndex = 176;
    this.background = Colors.BrightWhite;
    this.foreground = Colors.BrightBlue;
}
Water.prototype = new Thing();
Water.prototype.constructor = Water;

Water.prototype.serialize = function () {
    var result = Thing.prototype.serialize.call(this);
    delete result.color;
    return result;
};

Water.prototype.deserialize = function (data) {
    Thing.prototype.deserialize.call(this, data);
    this.background = Colors.BrightWhite;
    this.foreground = Colors.BrightBlue;
};

/**
 * Returns whether or not this Water is surrenderable to a provided
 * sender. Water will return true if the sender is a bullet or ThrowingStar,
 * but false otherwise.
 */
Water.prototype.isSurrenderable = function (sender) {
    if (sender && (sender.type === 'Bullet' || sender.type === 'ThrowingStar')) {
        return true;
    }
};

/**
 * Sends a provided message to this Water. If a TOUCH message is received, then
 * a sound effect is played and a message indicating that players cannot
 * move through water is shown.
 *
 * @param message A message to be delivered to this Water.
 */
Water.prototype.sendMessage = function (message) {
    if (message === 'TOUCH') {
        this.play('t+c+c');
        this.board.setDisplayMessage(i18n.getMessage('obstacles.water'), 1);
    }
};

/*==================================================================================
 * THING FACTORY
 *=================================================================================*/

/**
 * Creates a new Thing based on provided serialized data, and assigns it to a given board.
 *
 * @param data Serialized data to turn into a Thing
 * @param board A board which should own the created Thing.
 */
ThingFactory.deserialize = function (data, board) {

    var thingMap,
        ThingFunction,
        result;

    if (data && data.type) {

        thingMap = ThingFactory.getThingMap();
        ThingFunction = thingMap[data.type.toUpperCase()];

        if (ThingFunction) {
            result = new ThingFunction(board);
            result.deserialize(data);
            return result;
        }

    }

};

/**
 * Tests if a provided name corresponds to a known thing that is capable of being deserialized.
 *
 * @param thingName A name of a thing
 * @return true if a Thing of a given name exists, false otherwise
 */
ThingFactory.isKnownThing = function (thingName) {

    var thingMap = ThingFactory.getThingMap();

    return (thingMap[thingName.toUpperCase()] !== undefined);

};

/**
 * Lazily fetches a map of Things that have declared themself as serializeable .
 *
 * @return A map of Thing functions indexed by their symbols or serialization types.
 */
ThingFactory.getThingMap = function () {

    var thing;

    // If we haven't yet constructed our thing map...
    if (ThingFactory.thingMap === undefined) {

        // Create a new thing map
        ThingFactory.thingMap = {};

        // For each thing defined in this module...
        for (thing in exports.things) {

            // If it's a Thing with a defined type...
            if (exports.things.hasOwnProperty(thing) && exports.things[thing].type) {

                // Add it to our thing map by its uppercase name
                ThingFactory.thingMap[thing.toUpperCase()] = exports.things[thing];

            }
        }
    }

    return ThingFactory.thingMap;

};


/**
 * Creates a new Bullet Thing on a provided board at a given point, oriented in
 * a provided direction. If the provided point is blocked by another UpdateableThing,
 * then that UpdateableThing will be sent a 'SHOT' message.
 */
ThingFactory.shoot = function (board, point, direction, fromPlayer, throwingStar) {

    // First, get our destination tile
    var tile = board.getTile(point),
        bullet = throwingStar ? new ThrowingStar(board) : new Bullet(board);

    bullet.direction = direction;
    if (fromPlayer) {
        bullet.fromPlayer = fromPlayer;
    }


    if (tile === undefined || tile.isSurrenderable(bullet)) {

        // We're allowed to spawn a bullet here
        board.addThing(point, bullet, true);
        if (fromPlayer) {
            board.game.resources.audio.play('t+c-c-c');
        }

    } else if (fromPlayer && tile && tile.type === 'Ricochet') {

        // The bullet is from the player and the tile is a Ricochet,
        // so shoot the messenger
        board.player.sendMessage('SHOT');

    } else if (fromPlayer || (tile && (tile.type === 'Player' || tile.type === 'Scriptable' || tile.type === 'BreakableWall'))) {

        // The bullet is from the player, or the tile is a Player or Scriptable
        if (fromPlayer) {
            board.game.resources.audio.play('t+c-c-c');
        }
        tile.sendMessage('SHOT');

    }

};

exports.Thing = Thing;
exports.UpdateableThing = UpdateableThing;

defineThing('Scriptable', Scriptable);
defineThing('ActiveBomb', ActiveBomb);
defineThing('Ammo', Ammo);
defineThing('Bear', Bear);
defineThing('Blinker', Blinker);
defineThing('BlinkWall', BlinkWall);
defineThing('Bomb', Bomb);
defineThing('Boulder', Boulder);
defineThing('BreakableWall', BreakableWall);
defineThing('Bullet', Bullet);
defineThing('Centipede', Centipede);
defineThing('Conveyor', Conveyor);
defineThing('Door', Door);
defineThing('Duplicator', Duplicator);
defineThing('Explosion', Explosion);
defineThing('FakeWall', FakeWall);
defineThing('Forest', Forest);
defineThing('Gem', Gem);
defineThing('Heart', Heart);
defineThing('InvisibleWall', InvisibleWall);
defineThing('Key', Key);
defineThing('Lava', Lava);
defineThing('LineWall', LineWall);
defineThing('Lion', Lion);
defineThing('Passage', Passage);
defineThing('Player', Player);
defineThing('Pusher', Pusher);
defineThing('Ricochet', Ricochet);
defineThing('River', River);
defineThing('Ruffian', Ruffian);
defineThing('Signpost', Signpost);
defineThing('SliderEw', SliderEw);
defineThing('SliderNs', SliderNs);
defineThing('Snake', Snake);
defineThing('SolidWall', SolidWall);
defineThing('Spider', Spider);
defineThing('SpiderWeb', SpiderWeb);
defineThing('SpinningGun', SpinningGun);
defineThing('Teleporter', Teleporter);
defineThing('Text', Text);
defineThing('ThrowingStar', ThrowingStar);
defineThing('Tiger', Tiger);
defineThing('Torch', Torch);
defineThing('Wall', Wall);
defineThing('Water', Water);

exports.ThingFactory = ThingFactory;

},{"./basic":1,"./game-state":4,"./graphics":5,"./i18n":6,"./jzt-script-context":8}],14:[function(_dereq_,module,exports){
/*jslint node: true, browser:true */
/*global LZString, Base64, FileReader, alert, CodeMirror, jQuery */

'use strict';

var JztScript = _dereq_('../jzt-script').JztScript,
    JztScriptParser = _dereq_('../jzt-script-parser').JztScriptParser,
    SpiderWeb = _dereq_('../things').SpideWeb,
    Editor = _dereq_('../editor').Editor,
    boardSelector,
    northSelector,
    eastSelector,
    southSelector,
    westSelector,
    northOffsetSelector,
    eastOffsetSelector,
    southOffsetSelector,
    westOffsetSelector,
    darkSelector,
    maxPlayerBulletSelector,
    reenterSelector,
    templateEditor,
    scriptSelector,
    scriptEditor,
    editArea,
    itemSelector,
    gameName,
    authorName,
    startingBoardSelector,
    titleBoardSelector,
    victoryBoardSelector,
    scriptWarning,
    modeSelector,
    playButton,
    editor,
    oldLine = 1,
    templates,
    scriptTab,
    newBoardDialog,
    mainNavigation,
    parser;

/**
 * Validates a current script and displays or hides a warning as appropriate.
 */
function validateScript() {

    try {
        parser.parse(scriptEditor.getValue());
        scriptWarning.innerHTML = '';
        scriptWarning.style.display = 'none';
    } catch (exception) {
        scriptWarning.innerHTML = '<span class="warning-icon">â </span> ' + exception;
        scriptWarning.style.display = 'block';
    }

    return CodeMirror.Pass;

}

/**
 * Selects a script with a provided name
 *
 * @param scriptName {string} - A script name to be selected
 */
function selectScript(scriptName) {

    var script = editor.currentBoard.getScript(scriptName);

    if (script) {
        scriptTab.classList.remove('noscript');
        scriptEditor.setValue(script.rawScript || script.script || '');
    } else {
        scriptEditor.setValue('');
        scriptTab.classList.add('noscript');
    }

    validateScript();

}

/**
 * Initializes a board options dialog
 *
 * @param dialog {object} - A dialog DOM element
 */
function initializeBoardOptionsDialog(dialog) {

    /**
     * An event handler to be invoked when board options have changed
     */
    function onChange() {
        editor.setBoardOptions({
            north: northSelector.value,
            east: eastSelector.value,
            south: southSelector.value,
            west: westSelector.value,
            northOffset: northOffsetSelector.value,
            eastOffset: eastOffsetSelector.value,
            southOffset: southOffsetSelector.value,
            westOffset: westOffsetSelector.value,
            dark: darkSelector.checked,
            maxPlayerBullets: parseInt(maxPlayerBulletSelector.value, 10),
            reenter: reenterSelector.checked
        });
    }

    northSelector = dialog.querySelector('[data-id="north"]');
    eastSelector = dialog.querySelector('[data-id="east"]');
    southSelector = dialog.querySelector('[data-id="south"]');
    westSelector = dialog.querySelector('[data-id="west"]');
    northOffsetSelector = dialog.querySelector('[data-id="north-offset"]');
    eastOffsetSelector = dialog.querySelector('[data-id="east-offset"]');
    southOffsetSelector = dialog.querySelector('[data-id="south-offset"]');
    westOffsetSelector = dialog.querySelector('[data-id="west-offset"]');
    darkSelector = dialog.querySelector('[data-id="dark"]');
    reenterSelector = dialog.querySelector('[data-id="reenter"]');
    maxPlayerBulletSelector = dialog.querySelector('[data-id="max-player-bullets"]');

    northSelector.addEventListener('change', onChange, false);
    eastSelector.addEventListener('change', onChange, false);
    southSelector.addEventListener('change', onChange, false);
    westSelector.addEventListener('change', onChange, false);
    northOffsetSelector.addEventListener('change', onChange, false);
    eastOffsetSelector.addEventListener('change', onChange, false);
    southOffsetSelector.addEventListener('change', onChange, false);
    westOffsetSelector.addEventListener('change', onChange, false);
    darkSelector.addEventListener('click', onChange, false);
    reenterSelector.addEventListener('click', onChange, false);
    maxPlayerBulletSelector.addEventListener('change', onChange, false);

}

/**
 * Initializes a world options dialog
 *
 * @param dialog {object} - A dialog DOM element
 */
function initializeWorldOptionsDialog(dialog) {

    /**
     * An event handler to be invoked when board options have changed
     */
    function onChange() {
        editor.setGameOptions({
            name: gameName.value,
            author: authorName.value,
            titleBoard: titleBoardSelector.value,
            startingBoard: startingBoardSelector.value,
            victoryBoard: victoryBoardSelector.value
        });
    }

    gameName = dialog.querySelector('[data-id="title"]');
    authorName = dialog.querySelector('[data-id="author"]');
    titleBoardSelector = dialog.querySelector('[data-id="title-board"]');
    startingBoardSelector = dialog.querySelector('[data-id="starting-board"]');
    victoryBoardSelector = dialog.querySelector('[data-id="victory-board"]');

    gameName.addEventListener('change', onChange, false);
    authorName.addEventListener('change', onChange, false);
    titleBoardSelector.addEventListener('change', onChange, false);
    startingBoardSelector.addEventListener('change', onChange, false);
    victoryBoardSelector.addEventListener('change', onChange, false);

}

/**
 * Initializes an open dialog
 *
 * @param dialog {object} - A dialog DOM element
 */
function initializeOpenDialog(dialog) {

    // Load Game
    dialog.querySelector('[data-id="open"]').addEventListener('change', function () {

        var fileReader,
            file;

        if (event.target.files && event.target.files[0]) {

            file = event.target.files[0];
            fileReader = new FileReader();

            fileReader.onload = function () {

                var json;

                if (file.type === 'application/json') {
                    json = fileReader.result;
                } else {
                    json = fileReader.result.split(',')[1];
                    json = LZString.decompressFromBase64(json);
                }

                try {
                    editor.deserialize(JSON.parse(json));
                } catch (exception) {
                    alert(exception);
                }

            };

            if (file.type === 'application/json') {
                fileReader.readAsText(file);
            } else {
                fileReader.readAsDataURL(file);
            }

        }

        event.preventDefault();
        jQuery(dialog.querySelector('.close-reveal-modal')).trigger('click');

    }, false);


}

/**
 * Initializes a script options dialog
 *
 * @param dialog {object} - A dialog DOM element
 */
function initializeScriptDialog(dialog) {

    scriptTab = dialog;
    scriptSelector = dialog.querySelector('[data-id="selector"]');

    scriptEditor = CodeMirror.fromTextArea(dialog.querySelector('[data-id="editor"]'), {
        mode: 'jztscript',
        theme: 'jzt',
        lineNumbers: true,
        lineWrapping: false
    });

    scriptWarning = dialog.querySelector('[data-id="warning"]');

    // New Script Button
    dialog.querySelector('[data-id="new"]').addEventListener('click', function () {

        var script,
            newName = window.prompt('Please enter a script name.', 'Untitled');

        if (newName) {
            newName = editor.getUniqueScriptName(newName);
            script = new JztScript(newName);
            editor.currentBoard.scripts.push(script);
            scriptSelector.options[scriptSelector.options.length] = new Option(newName);
            scriptSelector.value = newName;
            selectScript(newName);
        }

    }, false);

    // Delete Script Button
    dialog.querySelector('[data-id="delete"]').addEventListener('click', function () {

        var index,
            scriptName = scriptSelector.value;

        for (index = 0; index < editor.currentBoard.scripts.length; index += 1) {
            if (editor.currentBoard.scripts[index].name === scriptName) {
                editor.currentBoard.scripts.splice(index, 1);
            }
        }

        scriptSelector.remove(scriptSelector.selectedIndex);

        selectScript(scriptSelector.value);

    }, false);

    // Script Editor
    scriptEditor.on('blur', function () {

        var script = editor.currentBoard.getScript(scriptSelector.value),
            rawScript = scriptEditor.getValue().trim();

        validateScript();
        script.rawScript = rawScript === '' ? undefined : rawScript;

    });

    scriptEditor.on('cursorActivity', function () {
        if (scriptEditor.getCursor().line !== oldLine) {
            validateScript();
        }
        oldLine = scriptEditor.getCursor().line;
    });

    scriptSelector.addEventListener('change', function (event) {
        selectScript(event.target.value);
        validateScript();
    }, false);

}

/**
 * Initializes the new board dialog
 *
 * @param dialog {object} - A dialog that allows the creation of a new board
 */
function initializeNewBoardDialog(dialog) {

    newBoardDialog = dialog;

    dialog.querySelector('[data-id="ok"]').addEventListener('click', function () {

        var name = dialog.querySelector('[data-id="name"]').value,
            width = parseInt(dialog.querySelector('[data-id="width"]').value, 10),
            height = parseInt(dialog.querySelector('[data-id="height"]').value, 10);

        if (name && width && height) {
            name = editor.getUniqueBoardName(name);
            try {
                editor.addBoard(name, width, height);
            } catch (ex) {
                alert(ex);
            }
        }

        jQuery(dialog.querySelector('.close-reveal-modal')).trigger('click');

    });

}

/**
 * Initializes the primary UI options
 *
 * @param options {object} - DOM elements used for user interaction
 */
function initializePrimaryUi(options) {

    var index,
        mainMenu,
        children;

    function onToolChange(event) {

        var toolType = event.target.value,
            activeTemplate;

        if (toolType) {

            if (templates.hasOwnProperty(toolType)) {
                activeTemplate = templates[toolType];
            } else {
                activeTemplate = {type: toolType};
                switch (toolType) {
                case 'Passage':
                    activeTemplate.passageId = 1;
                    activeTemplate.targetBoard = 'Untitled';
                    break;
                case 'Spider':
                    activeTemplate.under = new SpiderWeb().serialize();
                    break;
                case 'Scriptable':
                    activeTemplate.script = 'Untitled Script';
                    break;
                case 'River':
                    activeTemplate.direction = 'N';
                    break;
                }
                templates[toolType] = activeTemplate;
            }

            editor.setActiveTemplate(activeTemplate);

        } else {
            editor.setActiveTemplate(undefined);
        }

    }

    function onModeChange(event) {

        var mode = event.target.getAttribute('data-mode');

        switch (mode) {
        case 'draw':
            editor.setMode(Editor.Mode.DRAW);
            break;
        case 'select':
            editor.setMode(Editor.Mode.SELECT);
            break;
        case 'fill':
            editor.setMode(Editor.Mode.FILL);
            break;
        }

        event.preventDefault();

    }

    function onNoActionClick(event) {
        event.preventDefault();
    }

    mainNavigation = options.mainNavigation;
    mainMenu = mainNavigation.querySelector('section.top-bar-section');
    modeSelector = options.modeSelector;
    playButton = options.playButton;
    boardSelector = options.boardSelector;
    templateEditor = options.templateEditor;
    itemSelector = options.itemSelector;

    // Board Selector
    boardSelector.addEventListener('change', function () {
        editor.switchBoard(event.target.value);
    }, false);

    children = modeSelector.querySelectorAll('[data-mode]');
    for (index = 0; index < children.length; index += 1) {
        children[index].addEventListener('click', onModeChange, false);
    }

    // Template Editor
    templateEditor.addEventListener('blur', function () {
        if (templateEditor.value !== '') {
            editor.setActiveTemplate(JSON.parse(templateEditor.value));
        }
    }, false);

    // New
    mainMenu.querySelector('[data-menu-item="new"]').addEventListener('click', function () {
        if (window.confirm('Are you sure you want to start a new game world?')) {
            editor.newGame();
        }
    }, false);

    // Download
    mainMenu.querySelector('[data-menu-item="download"]').addEventListener('click', function () {

        /*jslint regexp: true */

        var game = editor.serialize(),
            link;

        link = document.createElement('a');
        link.download = game.name.replace(/[^a-z0-9_\-]/gi, '-').toLowerCase() + '.jzt';
        link.href = 'data:application/octet-stream;charset=utf-8;base64,' +     LZString.compressToBase64(JSON.stringify(game));
        link.click();

    }, false);

    // New Board
    mainMenu.querySelector('[data-menu-item="new-board"]').addEventListener('click', function () {

        newBoardDialog.querySelector('[data-id="name"]').value = 'Untitled Board';
        newBoardDialog.querySelector('[data-id="width"]').value = '50';
        newBoardDialog.querySelector('[data-id="height"]').value = '20';

        event.preventDefault();

    }, false);

    // Delete Board
    mainMenu.querySelector('[data-menu-item="delete-board"]').addEventListener('click', function () {

        editor.removeBoard(editor.currentBoard.name);

        event.preventDefault();

    }, false);


    itemSelector.addEventListener('change', onToolChange, false);

    children = mainNavigation.querySelectorAll('[data-noaction]');
    for (index = 0; index < children.length; index += 1) {
        children[index].addEventListener('click', onNoActionClick, false);
    }

    options.sidebarTabs.on('toggled', function () {
        scriptEditor.refresh();
    });

    playButton.addEventListener('click', function (event) {

        window.open(event.target.href, 'jzt-play-test');
        event.preventDefault();

    }, false);

}

/**
 * An event handler when game options have changed
 *
 * @param options {object} - Game options that have changed
 */
function onGameOptionsChanged(options) {

    gameName.value = options.name;
    authorName.value = options.author;
    titleBoardSelector.value = options.titleBoard || '';
    startingBoardSelector.value = options.startingBoard;
    victoryBoardSelector.value = options.victoryBoard || '';

}

/**
 * An event handler to be invoked when a board has been added.
 *
 * @param boardName {string} - A name of a board that's been added.
 */
function onBoardAdded(boardName) {
    boardSelector.options[boardSelector.options.length] = new Option(boardName, boardName);
    northSelector.options[northSelector.options.length] = new Option(boardName, boardName);
    southSelector.options[southSelector.options.length] = new Option(boardName, boardName);
    eastSelector.options[eastSelector.options.length] = new Option(boardName, boardName);
    westSelector.options[westSelector.options.length] = new Option(boardName, boardName);
    titleBoardSelector.options[titleBoardSelector.options.length] = new Option(boardName, boardName);
    startingBoardSelector.options[startingBoardSelector.options.length] = new Option(boardName, boardName);
    victoryBoardSelector.options[victoryBoardSelector.options.length] = new Option(boardName, boardName);
}

/**
 * An event handler to be invoked when a board has been removed.
 *
 * @param boardName {string} = A name of a board that's been removed.
 */
function onBoardRemoved(boardName) {

    function findIndex(element, name) {
        var index;
        for (index = 0; index < element.length; index += 1) {
            if (element.options[index].value === name) {
                return index;
            }
        }
    }

    boardSelector.remove(findIndex(boardSelector, boardName));
    northSelector.remove(findIndex(northSelector, boardName));
    eastSelector.remove(findIndex(eastSelector, boardName));
    southSelector.remove(findIndex(southSelector, boardName));
    westSelector.remove(findIndex(westSelector, boardName));
    titleBoardSelector.remove(findIndex(titleBoardSelector, boardName));
    startingBoardSelector.remove(findIndex(startingBoardSelector, boardName));
    victoryBoardSelector.remove(findIndex(victoryBoardSelector, boardName));

}

/**
 * An event handler to be invoked when a board has changed.
 *
 * @param boardName {string} - A name of a board that's been changed.
 */
function onBoardChanged(boardName) {

    var index;

    boardSelector.value = boardName;
    scriptSelector.options.length = 0;

    for (index = 0; index < editor.currentBoard.scripts.length; index += 1) {
        scriptSelector.options[index] = new Option(editor.currentBoard.scripts[index].name);
    }

    selectScript(scriptSelector.value);

}

/**
 * An event handler to be invoked when board options have been changed.
 *
 * @param options {object} - Board options
 */
function onBoardOptionsChanged(options) {

    northSelector.value = options.north || '';
    eastSelector.value = options.east || '';
    southSelector.value = options.south || '';
    westSelector.value = options.west || '';
    northOffsetSelector.value = options.northOffset || '';
    eastOffsetSelector.value = options.eastOffset || '';
    southOffsetSelector.value = options.southOffset || '';
    westOffsetSelector.value = options.westOffset || '';
    darkSelector.checked = options.dark;
    reenterSelector.checked = options.reenter;
    maxPlayerBulletSelector.value = options.maxPlayerBullets === undefined ? -1 : options.maxPlayerBullets;

}

/**
 * An event handler to be invoked when an active template has changed
 *
 * @param newTemplate {object} - A template
 */
function onTemplateChanged(newTemplate) {

    if (newTemplate) {
        templateEditor.value = JSON.stringify(newTemplate, undefined, 4);

        if (newTemplate.type) {
            itemSelector.value = newTemplate.type;
        }

    } else {
        itemSelector.value = '';
        templateEditor.value = '(None)';
    }

}

/**
 * An event handler to be invoked when an edit mode has changed
 *
 * @param newMode {int} - A new mode
 */
function onModeChanged(newMode) {

    function selectMode(mode) {

        var elements = modeSelector.querySelectorAll('[data-mode]'),
            index;

        for (index = 0; index < elements.length; index += 1) {
            if (elements[index].getAttribute('data-mode') === mode) {
                elements[index].classList.add('active');
            } else {
                elements[index].classList.remove('active');
            }
        }


    }

    switch (newMode) {
    case Editor.Mode.DRAW:
        selectMode('draw');
        break;
    case Editor.Mode.FILL:
        selectMode('fill');
        break;
    case Editor.Mode.SELECT:
        selectMode('select');
        break;
    }
}

/**
 * Initializes a user interface for a JZT game editor.
 *
 * @param options {object} - Initial object elements
 */
function initializeEditorUx(options) {

    /*jslint regexp: true */

    CodeMirror.defineSimpleMode("jztscript", {
        // The start state contains the rules that are intially used
        start: [
            // The regex matches the token, the token property contains the type
            {regex: /"(?:[^\\]|\\.)*?"/, token: "string"},
            {regex: /\b(become|change|char|die|end|give|if|lock|move|play|put|scroll|send|set|take|throwstar|torch|restore|say|shoot|stand|unlock|victory|wait|walk|zap)\b/, token: "command"},
            {regex: /(?:not|adjacent|blocked|aligned|peep|exists)\b/, token: "expression"},
            {regex: /\d/i, token: "number"},
            {regex: /:.*/, token: "label"},
            {regex: /\/\/.*/, token: "comment"}
        ],
        meta: {
            lineComment: "//"
        }
    });

    editArea = options.editArea;
    templates = {};
    editor = new Editor(editArea, {
        addBoard: onBoardAdded,
        removeBoard: onBoardRemoved,
        changeBoard: onBoardChanged,
        changeMode: onModeChanged,
        changeTemplate: onTemplateChanged,
        changeBoardOptions: onBoardOptionsChanged,
        changeGameOptions: onGameOptionsChanged
    });
    parser = new JztScriptParser(true);

    initializeBoardOptionsDialog(options.boardOptionsDialog);
    initializeWorldOptionsDialog(options.worldOptionsDialog);
    initializeOpenDialog(options.openDialog);
    initializeScriptDialog(options.scriptDialog);
    initializeNewBoardDialog(options.newBoardDialog);
    initializePrimaryUi(options);

}

/**
 * An event handler to be triggered when a Cross-Document message is received.
 */
function onMessage(event) {

    var origin = window.location.origin || window.location.protocol + '//' + window.location.host;

    if (event.origin !== origin) {
        return;
    }

    if (event.data === 'send-game') {

        // A game was requested
        event.source.postMessage('play-game:' + JSON.stringify(editor.serialize(true)), event.origin);

    }

}

window.addEventListener('message', onMessage, false);
window.onbeforeunload = function () {
    return 'A friendly heads up: If you leave this page before downloading your work, it will be lost forever.';
};

// Pressing ALT+A toggles Advanced Mode
window.onkeydown = function (event) {
    if (event.keyCode === 65 && event.altKey) {
        document.body.classList.toggle('advanced-mode');
    }
};

exports.initializeEditorUx = initializeEditorUx;

},{"../editor":3,"../jzt-script":10,"../jzt-script-parser":9,"../things":13}]},{},[14])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlcyI6WyIvdXNyL2xvY2FsL2xpYi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1VzZXJzL21hcmttY2ludHlyZS9Eb2N1bWVudHMvQ29kZS9KWlQvc2NyaXB0L2Jhc2ljLmpzIiwiL1VzZXJzL21hcmttY2ludHlyZS9Eb2N1bWVudHMvQ29kZS9KWlQvc2NyaXB0L2JvYXJkLmpzIiwiL1VzZXJzL21hcmttY2ludHlyZS9Eb2N1bWVudHMvQ29kZS9KWlQvc2NyaXB0L2VkaXRvci5qcyIsIi9Vc2Vycy9tYXJrbWNpbnR5cmUvRG9jdW1lbnRzL0NvZGUvSlpUL3NjcmlwdC9nYW1lLXN0YXRlLmpzIiwiL1VzZXJzL21hcmttY2ludHlyZS9Eb2N1bWVudHMvQ29kZS9KWlQvc2NyaXB0L2dyYXBoaWNzLmpzIiwiL1VzZXJzL21hcmttY2ludHlyZS9Eb2N1bWVudHMvQ29kZS9KWlQvc2NyaXB0L2kxOG4uanMiLCIvVXNlcnMvbWFya21jaW50eXJlL0RvY3VtZW50cy9Db2RlL0paVC9zY3JpcHQvanp0LXNjcmlwdC1jb21tYW5kcy5qcyIsIi9Vc2Vycy9tYXJrbWNpbnR5cmUvRG9jdW1lbnRzL0NvZGUvSlpUL3NjcmlwdC9qenQtc2NyaXB0LWNvbnRleHQuanMiLCIvVXNlcnMvbWFya21jaW50eXJlL0RvY3VtZW50cy9Db2RlL0paVC9zY3JpcHQvanp0LXNjcmlwdC1wYXJzZXIuanMiLCIvVXNlcnMvbWFya21jaW50eXJlL0RvY3VtZW50cy9Db2RlL0paVC9zY3JpcHQvanp0LXNjcmlwdC5qcyIsIi9Vc2Vycy9tYXJrbWNpbnR5cmUvRG9jdW1lbnRzL0NvZGUvSlpUL3NjcmlwdC9sZXhlci5qcyIsIi9Vc2Vycy9tYXJrbWNpbnR5cmUvRG9jdW1lbnRzL0NvZGUvSlpUL3NjcmlwdC9wYXJzZXIuanMiLCIvVXNlcnMvbWFya21jaW50eXJlL0RvY3VtZW50cy9Db2RlL0paVC9zY3JpcHQvdGhpbmdzLmpzIiwiL1VzZXJzL21hcmttY2ludHlyZS9Eb2N1bWVudHMvQ29kZS9KWlQvc2NyaXB0L3V4L3V4LWVkaXRvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzl2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcitCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1a0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzU1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiAqIEpaVCBCYXNpY1xuICogQ29weXJpZ2h0IMKpIDIwMTQgT3JhbmdlbGluZSBJbnRlcmFjdGl2ZSwgSW5jLlxuICogQGF1dGhvciBNYXJrIE1jSW50eXJlXG4gKi9cblxuLypqc2xpbnQgbm9kZTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbnN0cnVjdG9yRXJyb3IgPSAnQ29uc3RydWN0b3IgbXVzdCBiZSBjYWxsZWQgd2l0aCBuZXcuJyxcbiAgICBEaXJlY3Rpb247XG5cbi8qKlxuICogUG9pbnQgcmVwcmVzZW50cyBhIHBvaW50IG9uIGEgY2FydGVzaWFuIHBsYW5lLlxuICpcbiAqIEBwYXJhbSB4IEFuIHggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB5IEEgeSBjb29yZGluYXRlLlxuICovXG5mdW5jdGlvbiBQb2ludCh4LCB5KSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUG9pbnQpKSB7XG4gICAgICAgIHRocm93IENvbnN0cnVjdG9yRXJyb3I7XG4gICAgfVxuXG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUG9pbnQgd2l0aCBpZGVudGljYWwgdmFsdWVzIHRvIHRoaXMgb25lLlxuICpcbiAqIEByZXR1cm4gQSBQb2ludC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xufTtcblxuLyoqXG4gKiBBZGRzIGEgcHJvdmlkZWQgcG9pbnQgdG8gdGhpcyBwb2ludCwgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0gb3RoZXIgQW5vdGhlciBwb2ludCB0byBhZGQgdG8gdGhpcyBvbmUuXG4gKiBAcmV0dXJuIEEgbmV3IHBvaW50IHdpdGggdGhlIGFkZGVkIHZhbHVlLlxuICovXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBvdGhlci54LCB0aGlzLnkgKyBvdGhlci55KTtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIGEgcHJvdmlkZWQgcG9pbnQgZnJvbSB0aGlzIHBvaW50IGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIG90aGVyIEFub3RoZXIgcG9pbnQgdG8gc3VidHJhY3QgZnJvbSB0aGlzIG9uZS5cbiAqIEByZXR1cm4gQSBuZXcgcG9pbnQgd2l0aCB0aGUgc3VidHJhY3RlZCB2YWx1ZS5cbiAqL1xuUG9pbnQucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnggLSBvdGhlci54LCB0aGlzLnkgLSBvdGhlci55KTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGlzIHBvaW50IGlzIGRpcmVjdGx5IGFkamFjZW50IHRvIGEgcHJvdmlkZWQgcG9pbnQuXG4gKlxuICogQHBhcmFtIG90aGVyIEFub3RoZXIgcG9pbnQgdG8gdGVzdCBmb3IgYWRqYWNlbmN5XG4gKiBAcmV0dXJuIHRydWUgaWYgYSBwcm92aWRlZCBwb2ludCBpcyBhZGphY2VudCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cblBvaW50LnByb3RvdHlwZS5hZGphY2VudCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXG4gICAgdmFyIHhEZXZpYW5jZSA9IE1hdGguYWJzKHRoaXMueCAtIG90aGVyLngpLFxuICAgICAgICB5RGV2aWFuY2UgPSBNYXRoLmFicyh0aGlzLnkgLSBvdGhlci55KTtcblxuICAgIHJldHVybiAhKHhEZXZpYW5jZSA+IDEgfHwgeURldmlhbmNlID4gMSk7XG5cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHdoZXRoZXIgb3Igbm90IGEgcHJvdmlkZWQgcG9pbnQgaXMgYWxpZ25lZCB3aXRoIHRoaXMgb25lLCB3aXRoaW4gYSBnaXZlblxuICogc3ByZWFkIHRocmVzaG9sZC5cbiAqXG4gKiBAcGFyYW0gb3RoZXIgQSBwb2ludCB0byB0ZXN0IGZvciBhbGlnbm1lbnQuXG4gKiBAcGFyYW0gc3ByZWFkIEEgc3ByZWFkIHRocmVzaG9sZCB0byBhbGxvdyBmb3IgaW4gdGhlIGFsaWduZW1lbnQgY2FsY3VsYXRpb24uXG4gKiBAcmV0dXJuIHRydWUgaWYgYSBwcm92aWRlZCBwb2ludCBpcyBhbGlnbmVkIHdpdGggdGhpcyBvbmUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuUG9pbnQucHJvdG90eXBlLmFsaWduZWQgPSBmdW5jdGlvbiAob3RoZXIsIHNwcmVhZCwgZGlyZWN0aW9uKSB7XG4gICAgc3ByZWFkID0gc3ByZWFkID09PSB1bmRlZmluZWQgPyAxIDogc3ByZWFkO1xuXG4gICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLmFicyh0aGlzLnggLSBvdGhlci54KSA8IHNwcmVhZCkgfHwgKE1hdGguYWJzKHRoaXMueSAtIG90aGVyLnkpIDwgc3ByZWFkKTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLk5vcnRoKSB7XG4gICAgICAgIHJldHVybiAob3RoZXIueSA8IHRoaXMueSkgJiYgTWF0aC5hYnMoKHRoaXMueCAtIG90aGVyLngpKSA8IHNwcmVhZDtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLlNvdXRoKSB7XG4gICAgICAgIHJldHVybiAob3RoZXIueSA+IHRoaXMueSkgJiYgTWF0aC5hYnMoKHRoaXMueCAtIG90aGVyLngpKSA8IHNwcmVhZDtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLkVhc3QpIHtcbiAgICAgICAgcmV0dXJuIChvdGhlci54ID4gdGhpcy54KSAmJiBNYXRoLmFicygodGhpcy55IC0gb3RoZXIueSkpIDwgc3ByZWFkO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uV2VzdCkge1xuICAgICAgICByZXR1cm4gKG90aGVyLnggPCB0aGlzLngpICYmIE1hdGguYWJzKCh0aGlzLnkgLSBvdGhlci55KSkgPCBzcHJlYWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcblxufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgZGlyZWN0aW9uIGZyb20gdGhpcyBwb2ludCB0byBhbm90aGVyIHBvaW50LCBhbG9uZyBhbiBvcHRpb25hbCBheGlzLiBJZlxuICogbm8gYXhpcyBpcyBwcm92aWRlZCwgdGhlbiB0aGUgY2xvc2VzdCBvZiBlaXRoZXIgdGhlIFggb3IgWSBheGlzIHdpbGwgYmUgdXNlZC4gSWZcbiAqIHRoZSBkaXN0YW5jZSBvbiBib3RoIGF4ZXMgYXJlIHRoZSBzYW1lLCB0aGVuIG9uZSB3aWxsIGJlIHBpY2tlZCBhdCByYW5kb20uXG4gKlxuICogQHBhcmFtIG90aGVyIEFub3RoZXIgcG9pbnQgdG8gY2FsY3VsYXRlIHRoZSBkaXJlY3Rpb24gdG93YXJkLlxuICogQHBhcmFtIGF4aXMgJ3gnIG9yICd5JyBkZXBlbmRpbmcgb24gdGhlIGF4aXMgdG8gYmUgdGVzdGVkLlxuICogQHJldHVybiBBIFBvaW50IHJlcHJlc2VudGluZyBhIGRpcmVjdGlvblxuICovXG5Qb2ludC5wcm90b3R5cGUuZGlyZWN0aW9uVG8gPSBmdW5jdGlvbiAob3RoZXIsIGF4aXMpIHtcblxuICAgIHZhciB4RGlzdGFuY2UgPSB0aGlzLnggLSBvdGhlci54LFxuICAgICAgICB5RGlzdGFuY2UgPSB0aGlzLnkgLSBvdGhlci55O1xuXG4gICAgLy8gVGhlcmUgaXMgbm8gZGlyZWN0aW9uIHRvIHRoZSBzYW1lIHBvaW50XG4gICAgaWYgKHhEaXN0YW5jZSA9PT0gMCAmJiB5RGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoYXhpcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh4RGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgICAgIGF4aXMgPSAneSc7XG4gICAgICAgIH0gZWxzZSBpZiAoeURpc3RhbmNlID09PSAwKSB7XG4gICAgICAgICAgICBheGlzID0gJ3gnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXhpcyA9IChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyKSkgPyAneCcgOiAneSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXhpcyA9PT0gJ3gnKSB7XG4gICAgICAgIGlmICh4RGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHhEaXN0YW5jZSA8IDAgPyBEaXJlY3Rpb24uRWFzdCA6IERpcmVjdGlvbi5XZXN0O1xuICAgIH1cblxuICAgIGlmICh5RGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4geURpc3RhbmNlIDwgMCA/IERpcmVjdGlvbi5Tb3V0aCA6IERpcmVjdGlvbi5Ob3J0aDtcblxufTtcblxuLyoqXG4gKiBDb21wYXJlcyBhIHByb3ZpZGVkIFBvaW50IGluc3RhbmNlIHRvIHRoaXMgb25lLlxuICpcbiAqIEByZXR1cm4ge251bWJlcn0gLSBBIG5lZ2F0aXZlIHZhbHVlIGlmIHRoZSBvdGhlciBpbnN0YW5jZSBpcyBzbWFsbGVyLCAwIGlmIGJvdGggYXJlIHRoZSBzYW1lLFxuICogICAgYW5kIGEgcG9zaXRpdmUgdmFsdWUgaWYgb3RoZXIgaXMgZ3JlYXRlci5cbiAqL1xuUG9pbnQucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnggPT09IG90aGVyLnggPyB0aGlzLnkgLSBvdGhlci55IDogdGhpcy54IC0gb3RoZXIueDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGlzIFBvaW50IGlzIGVxdWFsIGluIHZhbHVlIHRvIGFub3RoZXIgcG9pbnQuXG4gKlxuICogQHBhcmFtIG90aGVyIEEgcG9pbnQgdG8gdGVzdCBmb3IgZXF1YWxpdHkuXG4gKiBAcmV0dXJuIHRydWUgaWYgYW5vdGhlciBwb2ludCBpcyBlcXVhbCBpbiB2YWx1ZSB0byB0aGlzIHBvaW50LCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblBvaW50LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy54ID09PSBvdGhlci54ICYmIHRoaXMueSA9PT0gb3RoZXIueTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHBvaW50LlxuICpcbiAqIEByZXR1cm4gQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBwb2ludC5cbiAqL1xuUG9pbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnKCcgKyB0aGlzLnggKyAnLCAnICsgdGhpcy55ICsgJyknO1xufTtcblxuLyoqXG4gKiBEaXJlY3Rpb24gaXMgYW4gZW51bWVyYXRlZCB0eXBlIHJlcHJlc2VudGluZyBlYWNoIG9mIHRoZSBmb3VyIHBvc3NpYmxlIGRpcmVjdGlvbnNcbiAqIG9uIGEgdGlsZS1iYXNlZCBncmlkLlxuICovXG5EaXJlY3Rpb24gPSB7XG4gICAgTm9ydGg6IG5ldyBQb2ludCgwLCAtMSksXG4gICAgRWFzdDogbmV3IFBvaW50KDEsIDApLFxuICAgIFNvdXRoOiBuZXcgUG9pbnQoMCwgMSksXG4gICAgV2VzdDogbmV3IFBvaW50KC0xLCAwKVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIHBvc3NpYmxlIGRpcmVjdGlvbiBvbiBhIHRpbGUtYmFzZWRcbiAqIGdyaWQuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGdpdmVuIGEgc2luZ2xlIHBhcmFtZXRlciBjb250YWluaW5nIHRoZSBkaXJlY3Rpb25cbiAqIGJlaW5nIGl0ZXJhdGVkLlxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuICovXG5EaXJlY3Rpb24uZWFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKERpcmVjdGlvbi5Ob3J0aCk7XG4gICAgY2FsbGJhY2soRGlyZWN0aW9uLkVhc3QpO1xuICAgIGNhbGxiYWNrKERpcmVjdGlvbi5Tb3V0aCk7XG4gICAgY2FsbGJhY2soRGlyZWN0aW9uLldlc3QpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBQb2ludCByZXByZXNlbnRpbmcgYSBkaXJlY3Rpb24gZnJvbSBhIHByb3ZpZGVkIG5hbWUuXG4gKlxuICogQHBhcmFtIG5hbWUgQSBuYW1lIG9mIGEgZGlyZWN0aW9uXG4gKiBAcmV0dXJuIEEgUG9pbnQgcmVwcmVzZW50aW5nIGEgZGlyZWN0aW9uLlxuICovXG5EaXJlY3Rpb24uZnJvbU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ04nOlxuICAgIGNhc2UgJ05vcnRoJzpcbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbi5Ob3J0aDtcbiAgICBjYXNlICdFJzpcbiAgICBjYXNlICdFYXN0JzpcbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbi5FYXN0O1xuICAgIGNhc2UgJ1MnOlxuICAgIGNhc2UgJ1NvdXRoJzpcbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbi5Tb3V0aDtcbiAgICBjYXNlICdXJzpcbiAgICBjYXNlICdXZXN0JzpcbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbi5XZXN0O1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBuYW1lIGZvciBhIHByb3ZpZGVkIFBvaW50IHJlcHJlc2VudGluZyBhIGRpcmVjdGlvbiBmcm9tIG91clxuICogZW51bWVyYXRlZCBkaXJlY3Rpb24gdHlwZXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpcmVjdGlvbiAtIEEgcHJvdmlkZWQgZGlyZWN0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gQSBkaXJlY3Rpb24gbmFtZS5cbiAqL1xuRGlyZWN0aW9uLmdldE5hbWUgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG5cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgRGlyZWN0aW9uLk5vcnRoOlxuICAgICAgICByZXR1cm4gJ05vcnRoJztcbiAgICBjYXNlIERpcmVjdGlvbi5FYXN0OlxuICAgICAgICByZXR1cm4gJ0Vhc3QnO1xuICAgIGNhc2UgRGlyZWN0aW9uLlNvdXRoOlxuICAgICAgICByZXR1cm4gJ1NvdXRoJztcbiAgICBjYXNlIERpcmVjdGlvbi5XZXN0OlxuICAgICAgICByZXR1cm4gJ1dlc3QnO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgJ3Nob3J0JyBuYW1lIGZvciBhIHByb3ZpZGVkIFBvaW50IHJlcHJlc2VudGluZyBhIGRpcmVjdGlvbiBmcm9tXG4gKiBvdXIgZW51bWVyYXRlZCBkaXJlY3Rpb24gdHlwZXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpcmVjdGlvbiAtIEEgcHJvdmlkZWQgZGlyZWN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IC0gQSBkaXJlY3Rpb24gbmFtZVxuICovXG5EaXJlY3Rpb24uZ2V0U2hvcnROYW1lID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICBjYXNlIERpcmVjdGlvbi5Ob3J0aDpcbiAgICAgICAgcmV0dXJuICdOJztcbiAgICBjYXNlIERpcmVjdGlvbi5FYXN0OlxuICAgICAgICByZXR1cm4gJ0UnO1xuICAgIGNhc2UgRGlyZWN0aW9uLlNvdXRoOlxuICAgICAgICByZXR1cm4gJ1MnO1xuICAgIGNhc2UgRGlyZWN0aW9uLldlc3Q6XG4gICAgICAgIHJldHVybiAnVyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcblxufTtcblxuLyoqXG4gKiBHaXZlbiBhIGRpcmVjdGlvbiBmcm9tIG91ciBEaXJlY3Rpb24gZW51bWVyYXRlZCB0eXBlLCByZXR1cm5zIGFub3RoZXJcbiAqIGRpcmVjdGlvbiByZXByZXNlbnRpbmcgYSBjbG9ja3dpc2Ugcm90YXRpb24gb24gOTAgZGVncmVlcy5cbiAqXG4gKiBAcGFyYW0gZGlyZWN0aW9uIEEgZGlyZWN0aW9uLlxuICogQHJldHVybiBBIGNsb2Nrd2lzZSBkaXJlY3Rpb24uXG4gKi9cbkRpcmVjdGlvbi5jbG9ja3dpc2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG5cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgRGlyZWN0aW9uLk5vcnRoOlxuICAgICAgICByZXR1cm4gRGlyZWN0aW9uLkVhc3Q7XG4gICAgY2FzZSBEaXJlY3Rpb24uRWFzdDpcbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbi5Tb3V0aDtcbiAgICBjYXNlIERpcmVjdGlvbi5Tb3V0aDpcbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbi5XZXN0O1xuICAgIGNhc2UgRGlyZWN0aW9uLldlc3Q6XG4gICAgICAgIHJldHVybiBEaXJlY3Rpb24uTm9ydGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcblxufTtcblxuLyoqXG4gKiBHaXZlbiBhIGRpcmVjdGlvbiBmcm9tIG91ciBEaXJlY3Rpb24gZW51bWVyYXRlZCB0eXBlLCByZXR1cm5zIGFub3RoZXIgZGlyZWN0aW9uXG4gKiByZXByZXNlbnRpbmcgYSByYW5kb20gY2hvaWNlIHBlcnBlbmRpY3VsYXIgdG8gdGhlIHByb3ZpZGVkIG9uZS5cbiAqXG4gKiBAcGFyYW0gZGlyZWN0aW9uIEEgZGlyZWN0aW9uLlxuICogQHJldHVybiBBIG5ldyBkaXJlY3Rpb24gcGVycGVuZGljdWxhciB0byB0aGUgcHJvdmlkZWQgb25lLCBhdCByYW5kb20uXG4gKi9cbkRpcmVjdGlvbi5yYW5kb21QZXJwZW5kaWN1bGFyID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICBjYXNlIERpcmVjdGlvbi5Ob3J0aDpcbiAgICBjYXNlIERpcmVjdGlvbi5Tb3V0aDpcbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbi5yYW5kb21FYXN0V2VzdCgpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBEaXJlY3Rpb24ucmFuZG9tTm9ydGhTb3V0aCgpO1xuICAgIH1cblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgUG9pbnQgcmVwcmVzZW50aW5nIGVpdGhlciBOb3J0aCBvciBTb3V0aCwgYXQgcmFuZG9tLlxuICpcbiAqIEByZXR1cm4gQSBQb2ludCBkaXJlY3Rpb24uXG4gKi9cbkRpcmVjdGlvbi5yYW5kb21Ob3J0aFNvdXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEaXJlY3Rpb24ucmFuZG9tKFtEaXJlY3Rpb24uTm9ydGgsIERpcmVjdGlvbi5Tb3V0aF0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgUG9pbnQgcmVwcmVzZW50aW5nIGVpdGhlciBFYXN0IG9yIFdlc3QsIGF0IHJhbmRvbS5cbiAqXG4gKiBAcmV0dXJuIEEgUG9pbnQgZGlyZWN0aW9uLlxuICovXG5EaXJlY3Rpb24ucmFuZG9tRWFzdFdlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIERpcmVjdGlvbi5yYW5kb20oW0RpcmVjdGlvbi5FYXN0LCBEaXJlY3Rpb24uV2VzdF0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgUG9pbnQgcmVwcmVzZW50aW5nIGVpdGhlciBOb3J0aCBvciBFYXN0LCBhdCByYW5kb20uXG4gKlxuICogQHJldHVybiBBIFBvaW50IGRpcmVjdGlvbi5cbiAqL1xuRGlyZWN0aW9uLnJhbmRvbU5vcnRoRWFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGlyZWN0aW9uLnJhbmRvbShbRGlyZWN0aW9uLk5vcnRoLCBEaXJlY3Rpb24uRWFzdF0pO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgcmFuZG9tIGRpcmVjdGlvbiBmcm9tIG91ciBEaXJlY3Rpb24gZW51bWVyYXRlZCB0eXBlIGZyb20gYSBwcm92aWRlZCBhcnJheSBvZlxuICogcG9zc2libGUgZGlyZWN0aW9ucy4gSWYgbm8gc3VjaCBhcnJheSBpcyBwcm92aWRlZCwgdGhlbiBhbGwgZGlyZWN0aW9ucyB3aWxsIGJlIGNvbnNpZGVyZWRcbiAqIGFzIGNhbmRpZGF0ZXMuXG4gKlxuICogQHBhcmFtIGRpcmVjdGlvbnMgQW4gYXJyYXkgb2YgcG9zc2libGUgZGlyZWN0aW9ucyB0byBjaG9vc2UgYXQgcmFuZG9tXG4gKiBAcmV0dXJuIEEgcmFuZG9tIFBvaW50IHJlcHJlc2VudGluZyBhIERpcmVjdGlvbi5cbiAqL1xuRGlyZWN0aW9uLnJhbmRvbSA9IGZ1bmN0aW9uIChkaXJlY3Rpb25zKSB7XG5cbiAgICAvLyBJZiBhbiBhcnJheSBvZiBkaXJlY3Rpb25zIHRvIHBpY2sgZnJvbSB3YXNuJ3Qgc3BlY2lmaWVkLi4uXG4gICAgaWYgKCFkaXJlY3Rpb25zKSB7XG4gICAgICAgIGRpcmVjdGlvbnMgPSBbRGlyZWN0aW9uLk5vcnRoLCBEaXJlY3Rpb24uRWFzdCwgRGlyZWN0aW9uLlNvdXRoLCBEaXJlY3Rpb24uV2VzdF07XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgcmFuZG9tIGRpcmVjdGlvbiBmcm9tIG91ciBhcnJheVxuICAgIHJldHVybiBkaXJlY3Rpb25zW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGRpcmVjdGlvbnMubGVuZ3RoKV07XG5cbn07XG5cbi8qKlxuICogUmV0dXJucyBhIERpcmVjdGlvbiByb3RhdGVkIDkwIGRlZ3JlZXMgY291bnRlci1jbG9ja3dpc2UgdG8gYSBwcm92aWRlZCBEaXJlY3Rpb24uXG4gKlxuICogQHBhcmFtIGRpcmVjdGlvbiBBIGRpcmVjdGlvblxuICogQHJldHVybiBBIGRpcmVjdGlvbiByb3RhdGVkIDkwIGRlZ3JlZXMgY291bnRlci1jbG9ja3dpc2UuXG4gKi9cbkRpcmVjdGlvbi5jb3VudGVyQ2xvY2t3aXNlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuXG4gICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICBjYXNlIERpcmVjdGlvbi5Ob3J0aDpcbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbi5XZXN0O1xuICAgIGNhc2UgRGlyZWN0aW9uLldlc3Q6XG4gICAgICAgIHJldHVybiBEaXJlY3Rpb24uU291dGg7XG4gICAgY2FzZSBEaXJlY3Rpb24uU291dGg6XG4gICAgICAgIHJldHVybiBEaXJlY3Rpb24uRWFzdDtcbiAgICBjYXNlIERpcmVjdGlvbi5FYXN0OlxuICAgICAgICByZXR1cm4gRGlyZWN0aW9uLk5vcnRoO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbn07XG5cbi8qKlxuICogR2l2ZW4gYSBkaXJlY3Rpb24sIHJldHVybnMgYSBkaXJlY3Rpb24gZmFjaW5nIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24uXG4gKlxuICogQHBhcmFtIGRpcmVjdGlvblxuICogQHJldHVybiBBIFBvaW50IHJlcHJlc2VudGluZyBhbiBvcHBvc2l0ZSBkaXJlY3Rpb24uXG4gKi9cbkRpcmVjdGlvbi5vcHBvc2l0ZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcblxuICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgY2FzZSBEaXJlY3Rpb24uTm9ydGg6XG4gICAgICAgIHJldHVybiBEaXJlY3Rpb24uU291dGg7XG4gICAgY2FzZSBEaXJlY3Rpb24uRWFzdDpcbiAgICAgICAgcmV0dXJuIERpcmVjdGlvbi5XZXN0O1xuICAgIGNhc2UgRGlyZWN0aW9uLlNvdXRoOlxuICAgICAgICByZXR1cm4gRGlyZWN0aW9uLk5vcnRoO1xuICAgIGNhc2UgRGlyZWN0aW9uLldlc3Q6XG4gICAgICAgIHJldHVybiBEaXJlY3Rpb24uRWFzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG59O1xuXG4vKipcbiAqIERlbGF5ZWRFdmVudFNjaGVkdWxlciBpcyBhbiBldmVudCBzY2hlZHVsZXIgdGhhdCBpbmNsdWRlcyBhbiBpbml0aWFsIGRlbGF5XG4gKiBiZWZvcmUgcmVwZWF0aW5nIGV2ZW50cy4gVGhpcyBpcyB1c2VkLCBmb3IgZXhhbXBsZSwgdG8gXCJyZXBlYXRcIiBldmVudHMgYXMgbG9uZyBhcyBhIGtleVxuICogaXMgaGVsZCBkb3duLCBidXQgaW5jbHVkZXMgYSBzbGlnaHQgZGVsYXkgYmVmb3JlIHRoZSByZXBlYXRpbmcgaGFwcGVucy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5pdGlhbERlbGF5IC0gQSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHVzZSBhcyBhbiBpbml0aWFsIGRlbGF5XG4gKiBAcGFyYW0ge251bWJlcn0gc3Vic2VxdWVudERlbGF5IC0gQSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHJlcGVhdCBldmVudHMgYWZ0ZXIgdGhlIGluaXRpYWwgZGVsYXlcbiAqL1xuZnVuY3Rpb24gRGVsYXllZEV2ZW50U2NoZWR1bGVyKGluaXRpYWxEZWxheSwgc3Vic2VxdWVudERlbGF5KSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVsYXllZEV2ZW50U2NoZWR1bGVyKSkge1xuICAgICAgICB0aHJvdyBDb25zdHJ1Y3RvckVycm9yO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdGlhbERlbGF5ID0gaW5pdGlhbERlbGF5O1xuICAgIHRoaXMuc3Vic2VxdWVudERlbGF5ID0gc3Vic2VxdWVudERlbGF5O1xuICAgIHRoaXMuZXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5uZXh0QWxsb3dhYmxlRXZlbnQgPSAwO1xuXG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGFuIGV2ZW50LCBleHBlY3RlZCB0byBoYXZlIHN0YXJ0ZWQgYXQgYSBwcm92aWRlZCBldmVudCB0aW1lLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBldmVudFRpbWUgLSBBIHRpbWVzdGFtcCBpbmRpY2F0aW5nIHRoZSBldmVudCB0aW1lXG4gKiBAcGFyYW0ge29iamVjdH0gZXZlbnQgLSBBbiBhcmJpdHJhcnkgb2JqZWN0IHJlcHJlc2VudGluZyBhbiBldmVudCB0byByZXRyaWV2ZVxuICogICAgIGxhdGVyIGF0IHNjaGVkdWxlZCBpbnRlcnZhbHMuXG4gKi9cbkRlbGF5ZWRFdmVudFNjaGVkdWxlci5wcm90b3R5cGUuc2NoZWR1bGVFdmVudCA9IGZ1bmN0aW9uIChldmVudFRpbWUsIGV2ZW50KSB7XG5cbiAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgIGlmIChub3cgPiB0aGlzLm5leHRBbGxvd2FibGVFdmVudCkge1xuXG4gICAgICAgIGlmIChldmVudFRpbWUgKyB0aGlzLmluaXRpYWxEZWxheSA8IG5vdykge1xuICAgICAgICAgICAgdGhpcy5uZXh0QWxsb3dhYmxlRXZlbnQgPSBub3cgKyB0aGlzLnN1YnNlcXVlbnREZWxheTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dEFsbG93YWJsZUV2ZW50ID0gbm93ICsgdGhpcy5pbml0aWFsRGVsYXk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmV2ZW50ID0gZXZlbnQ7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIENhbmNlbHMgdGhpcyBldmVudCBzY2hlZHVsZXIncyBzY2hlZHVsZWQgZXZlbnQuXG4gKi9cbkRlbGF5ZWRFdmVudFNjaGVkdWxlci5wcm90b3R5cGUuY2FuY2VsRXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5uZXh0QWxsb3dhYmxlRXZlbnQgPSAwO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIHNjaGVkdWxlZCBldmVudCBmcm9tIHRoaXMgZXZlbnQgc2NoZWR1bGVyLlxuICpcbiAqIEByZXR1cm4ge29iamVjdH0gLSBBIHNjaGVkdWxlZCBldmVudFxuICovXG5EZWxheWVkRXZlbnRTY2hlZHVsZXIucHJvdG90eXBlLnRha2VFdmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5ldmVudDtcbiAgICB0aGlzLmV2ZW50ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIE5vdGlmaWNhdGlvbkxpc3RlbmVyXG4gKi9cbmZ1bmN0aW9uIE5vdGlmaWNhdGlvbkxpc3RlbmVyKCkge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vdGlmaWNhdGlvbkxpc3RlbmVyKSkge1xuICAgICAgICB0aHJvdyBDb25zdHJ1Y3RvckVycm9yO1xuICAgIH1cblxuICAgIHRoaXMubm90aWZpY2F0aW9ucyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZHMgYSBwcm92aWRlZCBub3RpZmljYXRpb24gdG8gdGhpcyBub3RpZmljYXRpb24gbGlzdG5lci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIEEgbm90aWZpY2F0aW9uIHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gQSBub3RpZmljYXRpb24gbWVzc2FnZVxuICovXG5Ob3RpZmljYXRpb25MaXN0ZW5lci5wcm90b3R5cGUuYWRkTm90aWZpY2F0aW9uID0gZnVuY3Rpb24gKHR5cGUsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLm5vdGlmaWNhdGlvbnMucHVzaCh7dHlwZTogdHlwZSwgbWVzc2FnZTogbWVzc2FnZSwgdGltZXN0YW1wOiBEYXRlLm5vdygpfSk7XG59O1xuXG4vKipcbiAqIEFuIG9iamVjdCB0byBzdG9yZSB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqL1xudmFyIHV0aWxpdGllcyA9IHt9O1xuXG4vKipcbiAqIEFkZHMgYSBwcm9wZXJ0eSB0byBhIHByb3ZpZGVkIGRlc3RpbmF0aW9uIG9iamVjdCBhcyBhIGdpdmVuIG5hbWUgYW5kIHZhbHVlLFxuICogb25seSBpZiB0aGUgdmFsdWUgaXMgZG9lc24ndCBtYXRjaCBhIHByb3ZpZGVkIGRlZmF1bHQuXG4gKlxuICogQHBhcmFtIGRlc3RpbmF0aW9uIEEgZGVzdGluYXRpb24gb2JqZWN0XG4gKiBAcGFyYW0gbmFtZSBBIG5hbWUgb2YgYSBwcm9wZXJ0eVxuICogQHBhcmFtIHZhbHVlIEEgdmFsdWUgdG8gYmUgc3RvcmVkLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBBIGRlZmF1bHQgdmFsdWUuXG4gKi9cbnV0aWxpdGllcy5zdG9yZU9wdGlvbiA9IGZ1bmN0aW9uIChkZXN0aW5hdGlvbiwgbmFtZSwgdmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlmICh2YWx1ZSAhPT0gZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uW25hbWVdID0gdmFsdWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgbGluZSBkYXRhIGJldHdlZW4gdHdvIHBvaW50cy5cbiAqXG4gKiBAcGFyYW0gcG9pbnQxIEEgZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSBwb2ludDIgQSBzZWNvbmQgcG9pbnRcbiAqIEByZXR1cm4gTGluZSBkYXRhIHdpdGggYSBwb2ludHMgYXJyYXksIGNvbnRhaW5zIGZ1bmN0aW9uLCBhbmQgZm9yRWFjaCBmdW5jdGlvbi5cbiAqL1xudXRpbGl0aWVzLmdlbmVyYXRlTGluZURhdGEgPSBmdW5jdGlvbiAocG9pbnQxLCBwb2ludDIpIHtcblxuICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgICAgZHggPSBNYXRoLmFicyhwb2ludDIueCAtIHBvaW50MS54KSxcbiAgICAgICAgZHkgPSBNYXRoLmFicyhwb2ludDIueSAtIHBvaW50MS55KSxcbiAgICAgICAgc3ggPSAocG9pbnQxLnggPCBwb2ludDIueCkgPyAxIDogLTEsXG4gICAgICAgIHN5ID0gKHBvaW50MS55IDwgcG9pbnQyLnkpID8gMSA6IC0xLFxuICAgICAgICBlcnIgPSBkeCAtIGR5LFxuICAgICAgICBlMixcbiAgICAgICAgeCxcbiAgICAgICAgeTtcblxuICAgIHJlc3VsdC5wb2ludHMgPSBbXTtcblxuICAgIC8qXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGlzIGxpbmUgZGF0YSBjb250YWlucyBhIHByb3ZpZGVkIHBvaW50LlxuICAgICAqL1xuICAgIHJlc3VsdC5jb250YWlucyA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9pbnRzW2luZGV4XS5lcXVhbHMocG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKlxuICAgICAqIFBlcmZvcm1zIGEgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggcG9pbnQgaW4gdGhpcyBsaW5lIGRhdGEuXG4gICAgICovXG4gICAgcmVzdWx0LmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGluZGV4O1xuICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnBvaW50cy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0aGlzLnBvaW50c1tpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHggPSBwb2ludDEueDtcbiAgICB5ID0gcG9pbnQxLnk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgcmVzdWx0LnBvaW50cy5wdXNoKG5ldyBQb2ludCh4LCB5KSk7XG4gICAgICAgIGlmICgoeCA9PT0gcG9pbnQyLngpICYmICh5ID09PSBwb2ludDIueSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZTIgPSAyICogZXJyO1xuICAgICAgICBpZiAoZTIgPiAtZHkpIHtcbiAgICAgICAgICAgIGVyciAtPSBkeTtcbiAgICAgICAgICAgIHggKz0gc3g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUyIDwgZHgpIHtcbiAgICAgICAgICAgIGVyciArPSBkeDtcbiAgICAgICAgICAgIHkgKz0gc3k7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGNpcmNsZSBnaXZlbiBhIGNlbnRlciBwb2ludCBhbmQgYSByYWRpdXMgdG8gc3Vycm91bmQgaXQuXG4gKiBOb3RlIHRoYXQgc2luY2UgdGlsZXMgYXJlIHR3aWNlIGFzIGhpZ2ggYXMgdGhleSBhcmUgd2lkZSwgdGhlIGNpcmNsZVxuICogaXMgYWRqdXN0ZWQgdG8gaGF2ZSBkb3VibGUgdGhlIHdpZHRoIGFzIHRoZSBoZWlnaHQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHBvaW50IC0gQSBjZW50ZXIgcG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBBIHJhZGl1c1xuICogQHJldHVybiB7b2JqZWN0fSAtIEFuIGVsbGlwc2Ugb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgdGlsZXMgY292ZXJlZCBieSBhbiBlbGxpcHNlXG4gKi9cbnV0aWxpdGllcy5nZW5lcmF0ZUNpcmNsZURhdGEgPSBmdW5jdGlvbiAocG9pbnQsIHJhZGl1cykge1xuICAgIHJldHVybiB1dGlsaXRpZXMuZ2VuZXJhdGVFbGxpcHNlRGF0YShwb2ludCwgcmFkaXVzICogMiwgcmFkaXVzKTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIGVsbGlwc2UgZ2l2ZW4gYSBjZW50ZXIgcG9pbnQsIGFuIFggcmFkaXVzLCBhbmQgYSBZIHJhZGl1cy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcG9pbnQgLSBBIGNlbnRlciBwb2ludFxuICogQHBhcmFtIHtudW1iZXJ9IHJ4IC0gQW4gWCByYWRpdXNcbiAqIEBwYXJhbSB7bnVtYmVyfSByeSAtIEEgWSByYWRpdXNcbiAqIEByZXR1cm4ge29iamVjdH0gLSBBbiBlbGxpcHNlIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHRpbGVzIGNvdmVyZWQgYnkgYW4gZWxsaXBzZVxuICovXG51dGlsaXRpZXMuZ2VuZXJhdGVFbGxpcHNlRGF0YSA9IGZ1bmN0aW9uIChwb2ludCwgcngsIHJ5KSB7XG5cbiAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgIHJ4MiA9IHJ4ICogcngsXG4gICAgICAgIHJ5MiA9IHJ5ICogcnksXG4gICAgICAgIHR3b1J4MiA9IDIgKiByeDIsXG4gICAgICAgIHR3b1J5MiA9IDIgKiByeTIsXG4gICAgICAgIHAsXG4gICAgICAgIHggPSAwLFxuICAgICAgICB5ID0gcnksXG4gICAgICAgIHB4ID0gMCxcbiAgICAgICAgcHkgPSB0d29SeDIgKiB5LFxuICAgICAgICBtaW5NYXg7XG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgd2hldGhlciBvciBub3QgYSBwcm92aWRlZCBwb2ludCBpcyBjb3ZlcmVkIGJ5IHRoaXNcbiAgICAgKiBlbGxpcHNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBvaW50IC0gQSBwb2ludCB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBwcm92aWRlZCBwb2ludCBpcyBpbnNpZGUgdGhpcyBlbGxpcHNlLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICByZXN1bHQuY29udGFpbnMgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgaWYgKHRoaXNbcG9pbnQueV0pIHtcbiAgICAgICAgICAgIG1pbk1heCA9IHRoaXNbcG9pbnQueV07XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQueCA+PSBtaW5NYXhbMF0gJiYgcG9pbnQueCA8PSBtaW5NYXhbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyByYWRpdXMuLi5cbiAgICBpZiAocnggPT09IDAgJiYgcnkgPT09IDApIHtcblxuICAgICAgICAvLyBXZSBzaG91bGQgYWx3YXlzIGNvbnRhaW4gdGhlIGNlbnRlciBwb2ludFxuICAgICAgICByZXN1bHRbcG9pbnQueV0gPSBbcG9pbnQueCwgcG9pbnQueF07XG5cbiAgICAgICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9XG5cbiAgICAvLyBVcHBlciBSZWdpb25cbiAgICBwID0gTWF0aC5yb3VuZChyeTIgLSAocngyICogcnkpICsgKDAuMjUgKiByeDIpKTtcbiAgICB3aGlsZSAocHggPCBweSkge1xuICAgICAgICB4ICs9IDE7XG4gICAgICAgIHB4ICs9IHR3b1J5MjtcbiAgICAgICAgaWYgKHAgPCAwKSB7XG4gICAgICAgICAgICBwICs9IHJ5MiArIHB4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeSAtPSAxO1xuICAgICAgICAgICAgcHkgLT0gdHdvUngyO1xuICAgICAgICAgICAgcCArPSByeTIgKyBweCAtIHB5O1xuICAgICAgICB9XG4gICAgICAgIG1pbk1heCA9IFtwb2ludC54IC0geCwgcG9pbnQueCArIHhdO1xuICAgICAgICByZXN1bHRbcG9pbnQueSArIHldID0gbWluTWF4O1xuICAgICAgICByZXN1bHRbcG9pbnQueSAtIHldID0gbWluTWF4O1xuICAgIH1cblxuICAgIC8vIExvd2VyIFJlZ2lvblxuICAgIHAgPSBNYXRoLnJvdW5kKHJ5MiAqICh4ICsgMC41KSAqICh4ICsgMC41KSArIHJ4MiAqICh5IC0gMSkgKiAoeSAtIDEpIC0gcngyICogcnkyKTtcbiAgICB3aGlsZSAoeSA+IDApIHtcbiAgICAgICAgeSAtPSAxO1xuICAgICAgICBweSAtPSB0d29SeDI7XG4gICAgICAgIGlmIChwID4gMCkge1xuICAgICAgICAgICAgcCArPSByeDIgLSBweTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggKz0gMTtcbiAgICAgICAgICAgIHB4ICs9IHR3b1J5MjtcbiAgICAgICAgICAgIHAgKz0gcngyIC0gcHkgKyBweDtcbiAgICAgICAgfVxuICAgICAgICBtaW5NYXggPSBbcG9pbnQueCAtIHgsIHBvaW50LnggKyB4XTtcbiAgICAgICAgcmVzdWx0W3BvaW50LnkgKyB5XSA9IG1pbk1heDtcbiAgICAgICAgcmVzdWx0W3BvaW50LnkgLSB5XSA9IG1pbk1heDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhbiBhcnJheSBvZiBwb2ludHMgdGhhdCBmYWxsIHdpdGhpbiBhIGRlZmluZWQgY2lyY2xlIHdpdGhcbiAqIGEgcHJvdmlkZWQgY2VudGVyIHBvaW50IGFuZCByYWRpdXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHBvaW50IC0gQSBjZW50ZXIgcG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBBIHJhZGl1c1xuICogQHJldHVybiB7b2JqZWN0W119IC0gQW4gYXJyYXkgb2YgcG9pbnRzXG4gKi9cbnV0aWxpdGllcy5wb2ludHNJbkNpcmNsZSA9IGZ1bmN0aW9uIChwb2ludCwgcmFkaXVzKSB7XG4gICAgcmV0dXJuIHV0aWxpdGllcy5wb2ludHNJbkVsbGlwc2UocG9pbnQsIHJhZGl1cyAqIDIsIHJhZGl1cyk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhbiBhcnJheSBvZiBwb2ludHMgdGhhdCBmYWxsIHdpdGhpbiBhIGRlZmluZWQgZWxsaXBzZSB3aXRoXG4gKiBhIHByb3ZpZGVkIGNlbnRlciBwb2ludCBhbmQgcHJvdmlkZWQgeCBhbmQgeSByYWRpdXMuLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBwb2ludCAtIEEgY2VudGVyIHBvaW50XG4gKiBAcGFyYW0ge251bWJlcn0gcnggLSBBbiBYIHJhZGl1c1xuICogQHBhcmFtIHtudW1iZXJ9IHJ5IC0gQSBZIHJhZGl1c1xuICogQHJldHVybiB7b2JqZWN0W119IC0gQW4gYXJyYXkgb2YgcG9pbnRzXG4gKi9cbnV0aWxpdGllcy5wb2ludHNJbkVsbGlwc2UgPSBmdW5jdGlvbiAocG9pbnQsIHJ4LCByeSkge1xuXG4gICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgZWxsaXBzZVNlZ21lbnQsXG4gICAgICAgIG1pbk1heCxcbiAgICAgICAgbWluLFxuICAgICAgICBtYXgsXG4gICAgICAgIGVsbGlwc2VEYXRhID0gdXRpbGl0aWVzLmdlbmVyYXRlRWxsaXBzZURhdGEocG9pbnQsIHJ4LCByeSk7XG5cbiAgICBmb3IgKGVsbGlwc2VTZWdtZW50IGluIGVsbGlwc2VEYXRhKSB7XG4gICAgICAgIGlmIChlbGxpcHNlRGF0YS5oYXNPd25Qcm9wZXJ0eShlbGxpcHNlU2VnbWVudCkpIHtcblxuICAgICAgICAgICAgbWluTWF4ID0gZWxsaXBzZURhdGFbZWxsaXBzZVNlZ21lbnRdO1xuICAgICAgICAgICAgbWluID0gbWluTWF4WzBdO1xuICAgICAgICAgICAgbWF4ID0gbWluTWF4WzFdO1xuXG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gbWluOyBpbmRleCA8PSBtYXg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgUG9pbnQoaW5kZXgsIGVsbGlwc2VTZWdtZW50KSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG5cbn07XG5cbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbmV4cG9ydHMuRGlyZWN0aW9uID0gRGlyZWN0aW9uO1xuZXhwb3J0cy5EZWxheWVkRXZlbnRTY2hlZHVsZXIgPSBEZWxheWVkRXZlbnRTY2hlZHVsZXI7XG5leHBvcnRzLk5vdGlmaWNhdGlvbkxpc3RlbmVyID0gTm90aWZpY2F0aW9uTGlzdGVuZXI7XG5leHBvcnRzLnV0aWxpdGllcyA9IHV0aWxpdGllcztcbmV4cG9ydHMuQ29uc3RydWN0b3JFcnJvciA9IENvbnN0cnVjdG9yRXJyb3I7XG4iLCIvKipcbiAqIEpaVCBCb2FyZFxuICogQ29weXJpZ2h0IMKpIDIwMTQgT3JhbmdlbGluZSBJbnRlcmFjdGl2ZSwgSW5jLlxuICogQGF1dGhvciBNYXJrIE1jSW50eXJlXG4gKi9cblxuLypqc2xpbnQgbm9kZTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbnN0cnVjdG9yRXJyb3IgPSByZXF1aXJlKCcuL2Jhc2ljJykuQ29uc3RydWN0b3JFcnJvcixcbiAgICBQb2ludCA9IHJlcXVpcmUoJy4vYmFzaWMnKS5Qb2ludCxcbiAgICBDb2xvcnMgPSByZXF1aXJlKCcuL2dyYXBoaWNzJykuQ29sb3JzLFxuICAgIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4vYmFzaWMnKS51dGlsaXRpZXMsXG4gICAgSnp0U2NyaXB0ID0gcmVxdWlyZSgnLi9qenQtc2NyaXB0JykuSnp0U2NyaXB0LFxuICAgIHRoaW5ncyA9IHJlcXVpcmUoJy4vdGhpbmdzJykudGhpbmdzLFxuICAgIFRoaW5nRmFjdG9yeSA9IHJlcXVpcmUoJy4vdGhpbmdzJykuVGhpbmdGYWN0b3J5LFxuICAgIERpcmVjdGlvbiA9IHJlcXVpcmUoJy4vYmFzaWMnKS5EaXJlY3Rpb24sXG4gICAgaTE4biA9IHJlcXVpcmUoJy4vaTE4bicpO1xuXG4vKipcbiAqIEJvYXJkIHJlcHJlc2VudHMgYSBzaW5nbGUgZ2FtZSBib2FyZC5cbiAqXG4gKiBAcGFyYW0gYm9hcmREYXRhIFNlcmlhbGl6ZWQgYm9hcmQgZGF0YSB0byBsb2FkIGFuZCB1c2UgZm9yIHRoaXMgQm9hcmQuXG4gKiBAcGFyYW0gZ2FtZSBBIEdhbWUgaW5zdGFuY2UgdG8gc2VydmUgYXMgb3duZXIgb2YgdGhpcyBib2FyZFxuICovXG5mdW5jdGlvbiBCb2FyZChib2FyZERhdGEsIGdhbWUpIHtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCb2FyZCkpIHtcbiAgICAgICAgdGhyb3cgQ29uc3RydWN0b3JFcnJvcjtcbiAgICB9XG5cbiAgICB0aGlzLnZhbGlkYXRlRGF0YShib2FyZERhdGEpO1xuXG4gICAgdGhpcy5uYW1lID0gYm9hcmREYXRhLm5hbWU7XG4gICAgdGhpcy5nYW1lID0gZ2FtZTtcbiAgICB0aGlzLnRpbGVzID0gW107XG4gICAgdGhpcy5zY3JpcHRzID0gW107XG4gICAgdGhpcy5kYXJrID0gYm9hcmREYXRhLmRhcms7XG4gICAgdGhpcy5yZWVudGVyID0gYm9hcmREYXRhLnJlZW50ZXI7XG4gICAgdGhpcy5zbWFydFBhdGggPSBbXTtcbiAgICB0aGlzLmN1c3RvbVJlbmRlclNldCA9IFtdO1xuICAgIHRoaXMudG9yY2hlcyA9IFtdO1xuICAgIHRoaXMuZm9jdXNQb2ludCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICB0aGlzLm1heFBsYXllckJ1bGxldHMgPSBib2FyZERhdGEubWF4UGxheWVyQnVsbGV0cyAhPT0gdW5kZWZpbmVkID8gYm9hcmREYXRhLm1heFBsYXllckJ1bGxldHMgOiBJbmZpbml0eTtcbiAgICB0aGlzLnBsYXllckJ1bGxldHMgPSAwO1xuICAgIHRoaXMuaTE4biA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMubm9ydGggPSBib2FyZERhdGEubm9ydGg7XG4gICAgdGhpcy5lYXN0ID0gYm9hcmREYXRhLmVhc3Q7XG4gICAgdGhpcy5zb3V0aCA9IGJvYXJkRGF0YS5zb3V0aDtcbiAgICB0aGlzLndlc3QgPSBib2FyZERhdGEud2VzdDtcbiAgICB0aGlzLm5vcnRoT2Zmc2V0ID0gYm9hcmREYXRhLm5vcnRoT2Zmc2V0IHx8IDA7XG4gICAgdGhpcy5lYXN0T2Zmc2V0ID0gYm9hcmREYXRhLmVhc3RPZmZzZXQgfHwgMDtcbiAgICB0aGlzLnNvdXRoT2Zmc2V0ID0gYm9hcmREYXRhLnNvdXRoT2Zmc2V0IHx8IDA7XG4gICAgdGhpcy53ZXN0T2Zmc2V0ID0gYm9hcmREYXRhLndlc3RPZmZzZXQgfHwgMDtcblxuICAgIHRoaXMuZGVmYXVsdFBsYXllclggPSBib2FyZERhdGEucGxheWVyWDtcbiAgICB0aGlzLmRlZmF1bHRQbGF5ZXJZID0gYm9hcmREYXRhLnBsYXllclk7XG5cbiAgICBpZiAoYm9hcmREYXRhLmhhc093blByb3BlcnR5KCdlbnRyeVBvaW50WCcpICYmIGJvYXJkRGF0YS5oYXNPd25Qcm9wZXJ0eSgnZW50cnlQb2ludFknKSkge1xuICAgICAgICB0aGlzLmVudHJ5UG9pbnQgPSBuZXcgUG9pbnQoYm9hcmREYXRhLmVudHJ5UG9pbnRYLCBib2FyZERhdGEuZW50cnlQb2ludFkpO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGxheU1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kaXNwbGF5TWVzc2FnZVRpY2sgPSAwO1xuXG4gICAgdGhpcy5ESVNQTEFZX01FU1NBR0VfVFRMID0gZ2FtZS5GUFMgKiAzOyAvLyAzIHNlY29uZHNcbiAgICB0aGlzLkRBUktfU1BSSVRFID0gZ2FtZS5yZXNvdXJjZXMuZ3JhcGhpY3MuZ2V0U3ByaXRlKDE3Nik7XG4gICAgdGhpcy5EQVJLX1NQUklURV9DT0xPUiA9IENvbG9ycy5HcmV5O1xuXG4gICAgdGhpcy5oZWlnaHQgPSBib2FyZERhdGEuaGVpZ2h0O1xuICAgIHRoaXMud2lkdGggPSBib2FyZERhdGEud2lkdGg7XG5cbiAgICB0aGlzLmluaXRpYWxpemVJMThuKGJvYXJkRGF0YS5pMThuKTtcbiAgICB0aGlzLmluaXRpYWxpemVTY3JpcHRzKGJvYXJkRGF0YS5zY3JpcHRzKTtcbiAgICB0aGlzLmluaXRpYWxpemVUaWxlcyhib2FyZERhdGEudGlsZXMpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVdpbmRvdygpO1xuXG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHByb3ZpZGVkIGJvYXJkIGRhdGEgdG8gbWFrZSBzdXJlIGl0IGNvbnRhaW5zIHNvbWUgZXhwZWN0ZWRcbiAqIHByb3BlcnRpZXMgZm9yIGRlc2VyaWFsaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0gZGF0YSBEYXRhIHRvIGJlIHZhbGlkYXRlZFxuICovXG5Cb2FyZC5wcm90b3R5cGUudmFsaWRhdGVEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcblxuICAgIC8vIExldCdzIGhvcGUgZm9yIHRoZSBiZXN0Li4uXG4gICAgdmFyIHZhbGlkID0gdHJ1ZTtcblxuICAgIGlmICghZGF0YS5oZWlnaHQgfHwgIWRhdGEud2lkdGgpIHsgdmFsaWQgPSBmYWxzZTsgfVxuICAgIGlmICh0eXBlb2YgZGF0YS5oZWlnaHQgIT09ICdudW1iZXInKSB7IHZhbGlkID0gZmFsc2U7IH1cbiAgICBpZiAodHlwZW9mIGRhdGEud2lkdGggIT09ICdudW1iZXInKSB7IHZhbGlkID0gZmFsc2U7IH1cbiAgICBpZiAoZGF0YS5oZWlnaHQgPiAyNTYgfHwgZGF0YS5oZWlnaHQgPCAxMCkgeyB2YWxpZCA9IGZhbHNlOyB9XG4gICAgaWYgKGRhdGEud2lkdGggPiAyNTYgfHwgZGF0YS53aWR0aCA8IDEwKSB7IHZhbGlkID0gZmFsc2U7IH1cbiAgICBpZiAoIWRhdGEudGlsZXMgfHwgIShBcnJheS5pc0FycmF5KGRhdGEudGlsZXMpKSkgeyB2YWxpZCA9IGZhbHNlOyB9XG4gICAgaWYgKCFkYXRhLnNjcmlwdHMgfHwgIShBcnJheS5pc0FycmF5KGRhdGEuc2NyaXB0cykpKSB7IHZhbGlkID0gZmFsc2U7IH1cblxuICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgdGhyb3cgJ0ludmFsaWQgYm9hcmQgZGF0YS4nO1xuICAgIH1cblxufTtcblxuLyoqXG4gKiBTZXJpYWxpemVzIHRoaXMgQm9hcmQgaW5zdGFuY2UgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm4gQW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgYm9hcmQgZGF0YS5cbiAqL1xuQm9hcmQucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHNjcmlwdCxcbiAgICAgICAgbWVzc2FnZTtcblxuICAgIHJlc3VsdC5uYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgdXRpbGl0aWVzLnN0b3JlT3B0aW9uKHJlc3VsdCwgJ2RhcmsnLCB0aGlzLmRhcmspO1xuICAgIHV0aWxpdGllcy5zdG9yZU9wdGlvbihyZXN1bHQsICdkaXNwbGF5TWVzc2FnZScsIHRoaXMuZGlzcGxheU1lc3NhZ2UpO1xuICAgIHV0aWxpdGllcy5zdG9yZU9wdGlvbihyZXN1bHQsICdub3J0aCcsIHRoaXMubm9ydGgpO1xuICAgIHV0aWxpdGllcy5zdG9yZU9wdGlvbihyZXN1bHQsICdlYXN0JywgdGhpcy5lYXN0KTtcbiAgICB1dGlsaXRpZXMuc3RvcmVPcHRpb24ocmVzdWx0LCAnc291dGgnLCB0aGlzLnNvdXRoKTtcbiAgICB1dGlsaXRpZXMuc3RvcmVPcHRpb24ocmVzdWx0LCAnd2VzdCcsIHRoaXMud2VzdCk7XG4gICAgdXRpbGl0aWVzLnN0b3JlT3B0aW9uKHJlc3VsdCwgJ25vcnRoT2Zmc2V0JywgdGhpcy5ub3J0aE9mZnNldCk7XG4gICAgdXRpbGl0aWVzLnN0b3JlT3B0aW9uKHJlc3VsdCwgJ2Vhc3RPZmZzZXQnLCB0aGlzLmVhc3RPZmZzZXQpO1xuICAgIHV0aWxpdGllcy5zdG9yZU9wdGlvbihyZXN1bHQsICdzb3V0aE9mZnNldCcsIHRoaXMuc291dGhPZmZzZXQpO1xuICAgIHV0aWxpdGllcy5zdG9yZU9wdGlvbihyZXN1bHQsICd3ZXN0T2Zmc2V0JywgdGhpcy53ZXN0T2Zmc2V0KTtcbiAgICB1dGlsaXRpZXMuc3RvcmVPcHRpb24ocmVzdWx0LCAncmVlbnRlcicsIHRoaXMucmVlbnRlcik7XG5cbiAgICBpZiAodGhpcy5tYXhQbGF5ZXJCdWxsZXRzICE9PSBJbmZpbml0eSkge1xuICAgICAgICByZXN1bHQubWF4UGxheWVyQnVsbGV0cyA9IHRoaXMubWF4UGxheWVyQnVsbGV0cztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wbGF5ZXIpIHtcbiAgICAgICAgcmVzdWx0LnBsYXllclggPSB0aGlzLnBsYXllci5wb2ludC54O1xuICAgICAgICByZXN1bHQucGxheWVyWSA9IHRoaXMucGxheWVyLnBvaW50Lnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnBsYXllclggPSB0aGlzLmRlZmF1bHRQbGF5ZXJYO1xuICAgICAgICByZXN1bHQucGxheWVyWSA9IHRoaXMuZGVmYXVsdFBsYXllclk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZW50cnlQb2ludCkge1xuICAgICAgICByZXN1bHQuZW50cnlQb2ludFggPSB0aGlzLmVudHJ5UG9pbnQueDtcbiAgICAgICAgcmVzdWx0LmVudHJ5UG9pbnRZID0gdGhpcy5lbnRyeVBvaW50Lnk7XG4gICAgfVxuXG4gICAgcmVzdWx0LndpZHRoID0gdGhpcy53aWR0aDtcbiAgICByZXN1bHQuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgcmVzdWx0LnRpbGVzID0gW107XG4gICAgcmVzdWx0LnNjcmlwdHMgPSBbXTtcblxuICAgIC8vIFN0b3JlIHRpbGVzXG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uICh0aWxlKSB7XG4gICAgICAgIGlmICh0aWxlKSB7XG4gICAgICAgICAgICByZXN1bHQudGlsZXMucHVzaCh0aWxlLnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC50aWxlcy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTdG9yZSBzY3JpcHRzXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5zY3JpcHRzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICBzY3JpcHQgPSB0aGlzLnNjcmlwdHNbaW5kZXhdO1xuICAgICAgICBpZiAodGhpcy5nYW1lLmlzRWRpdG9yKSB7XG4gICAgICAgICAgICByZXN1bHQuc2NyaXB0cy5wdXNoKHsnbmFtZSc6IHNjcmlwdC5uYW1lLCAncmF3U2NyaXB0Jzogc2NyaXB0LnJhd1NjcmlwdCB8fCBzY3JpcHQuc2NyaXB0fSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuc2NyaXB0cy5wdXNoKHNjcmlwdC5zZXJpYWxpemUoKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdG9yZSBpMThuIGRhdGFcbiAgICBpZiAodGhpcy5pMThuKSB7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuIGkxOG4gY29udGFpbmVyIGZvciBvdXIgcmVzdWx0c1xuICAgICAgICByZXN1bHQuaTE4biA9IHt9O1xuXG4gICAgICAgIC8vIEZvciBlYWNoIG9mIG91ciBpMThuIHZhbHVlcy4uLlxuICAgICAgICBmb3IgKGluZGV4IGluIHRoaXMuaTE4bikge1xuICAgICAgICAgICAgaWYgKHRoaXMuaTE4bi5oYXNPd25Qcm9wZXJ0eShpbmRleCkpIHtcblxuICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBleHBlY3RpbmcgYSB0d28tbGV0dGVyIGxhbmd1YWdlIGNvZGVcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuaTE4bltpbmRleF0gPT09ICdzdHJpbmcnIHx8IGluZGV4Lmxlbmd0aCA9PT0gMikge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhbiBvYmplY3QgZm9yIG91ciBsYW5ndWFnZSBzdHJpbmdzXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5pMThuW2luZGV4XSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAobWVzc2FnZSBpbiB0aGlzLmkxOG5baW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pMThuW2luZGV4XS5oYXNPd25Qcm9wZXJ0eShtZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG91ciB2YWx1ZSBpcyBhIHN0cmluZywgc3RvcmUgaXQgaW4gb3VyIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5pMThuW2luZGV4XVttZXNzYWdlXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmkxOG5baW5kZXhdW21lc3NhZ2VdID0gdGhpcy5pMThuW2luZGV4XVttZXNzYWdlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG59O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIHNjcmlwdHMgdXNlZCBieSB0aGlzIEJvYXJkIGJhc2VkIG9uIHByb3ZpZGVkIHNjcmlwdFxuICogZGF0YS5cbiAqXG4gKiBAcGFyYW0gc2NyaXB0RGF0YSBTY3JpcHQgZGF0YSB0byBiZSBkZXNlcmlhbGl6ZWQgaW50byBTY3JpcHQgaW5zdGFuY2VzLlxuICovXG5Cb2FyZC5wcm90b3R5cGUuaW5pdGlhbGl6ZVNjcmlwdHMgPSBmdW5jdGlvbiAoc2NyaXB0RGF0YSkge1xuXG4gICAgdmFyIGluZGV4LCBzY3JpcHQ7XG5cbiAgICAvLyBJZiB3ZSdyZSBpbiBlZGl0b3IgbW9kZSwgdGhlcmUncyBubyBuZWVkIHRvIGNvbXBpbGVcbiAgICBpZiAodGhpcy5nYW1lLmlzRWRpdG9yKSB7XG4gICAgICAgIHRoaXMuc2NyaXB0cyA9IHNjcmlwdERhdGE7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBzY3JpcHREYXRhLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzY3JpcHQgPSBuZXcgSnp0U2NyaXB0KHNjcmlwdERhdGFbaW5kZXhdLm5hbWUsIHNjcmlwdERhdGFbaW5kZXhdLnJhd1NjcmlwdCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjcmlwdHMucHVzaChzY3JpcHQpO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZ2FtZS5ub3RpZnlMaXN0ZW5lcnMoJ3NjcmlwdC1lcnJvcicsIHtzY3JpcHROYW1lOiBzY3JpcHREYXRhW2luZGV4XS5uYW1lLCBlcnJvcjogZXhjZXB0aW9ufSk7XG4gICAgICAgIH1cblxuXG4gICAgfVxuXG59O1xuXG5Cb2FyZC5wcm90b3R5cGUuaW5pdGlhbGl6ZUkxOG4gPSBmdW5jdGlvbiAoaTE4bkRhdGEpIHtcblxuICAgIHZhciBsYW5ndWFnZSxcbiAgICAgICAgZW50cnk7XG5cbiAgICBpZiAoaTE4bkRhdGEpIHtcblxuICAgICAgICB0aGlzLmkxOG4gPSB7fTtcblxuICAgICAgICAvLyBGb3IgZWFjaCBvZiBvdXIgaTE4biB2YWx1ZXMuLi5cbiAgICAgICAgZm9yIChsYW5ndWFnZSBpbiBpMThuRGF0YSkge1xuICAgICAgICAgICAgaWYgKGkxOG5EYXRhLmhhc093blByb3BlcnR5KGxhbmd1YWdlKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYW5ndWFnZSA9PT0gJ3N0cmluZycgJiYgbGFuZ3VhZ2UubGVuZ3RoID09PSAyKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2VjdGlvbiBmb3Igb3VyIG1lc3NhZ2VzIGluIHRoaXMgbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pMThuW2xhbmd1YWdlXSA9IHt9O1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoZW50cnkgaW4gaTE4bkRhdGFbbGFuZ3VhZ2VdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaTE4bkRhdGFbbGFuZ3VhZ2VdLmhhc093blByb3BlcnR5KGVudHJ5KSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgb3VyIHZhbHVlIGlzIGEgc3RyaW5nLCBzdG9yZSBpdCBpbiBvdXIgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpMThuRGF0YVtsYW5ndWFnZV1bZW50cnldID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmkxOG5bbGFuZ3VhZ2VdW2VudHJ5XSA9IGkxOG5EYXRhW2xhbmd1YWdlXVtlbnRyeV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cbkJvYXJkLnByb3RvdHlwZS5nZXRTY3JpcHRhYmxlcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHRpbGUpIHtcbiAgICAgICAgaWYgKHRpbGUgJiYgdGlsZS50eXBlID09PSAnU2NyaXB0YWJsZScpIHtcblxuICAgICAgICAgICAgaWYgKCFuYW1lIHx8ICh0aWxlLm5hbWUgJiYgdGlsZS5uYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcblxufTtcblxuLyoqXG4gKiBUYWtlcyBhIHByb3ZpZGVkIHBsYXllciBhbiBpbml0aWFsaXplcyBpdCBmb3IgdXNlIG9uIHRoaXMgYm9hcmQuXG4gKlxuICogQHBhcmFtIEEgcGxheWVyIGluc3RhbmNlIHRvIHVzZSBvbiB0aGlzIGJvYXJkLlxuICovXG5Cb2FyZC5wcm90b3R5cGUuaW5pdGlhbGl6ZVBsYXllciA9IGZ1bmN0aW9uIChwbGF5ZXIpIHtcblxuICAgIHZhciBzY3JpcHRhYmxlcyxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHRpbGU7XG5cbiAgICAvLyBDaGVjayBpZiBvdXIgcGxheWVyIGlzIG91dHNpZGUgb3VyIHJhbmdlXG4gICAgaWYgKHRoaXMuaXNPdXRzaWRlKHBsYXllci5wb2ludCkpIHtcblxuICAgICAgICAvLyBJZiBzbywgdXNlIG91ciBkZWZhdWx0IGxvY2F0aW9uXG4gICAgICAgIHBsYXllci5wb2ludC54ID0gdGhpcy5kZWZhdWx0UGxheWVyWDtcbiAgICAgICAgcGxheWVyLnBvaW50LnkgPSB0aGlzLmRlZmF1bHRQbGF5ZXJZO1xuXG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBzb21ldGhpbmcgYXQgdGhlIHBsYXllcidzIHBvc2l0aW9uIGFscmVhZHkuXG4gICAgLy8gV2hhdGV2ZXIgaXQgaXMsIHRoZSBwbGF5ZXIgbmVlZHMgdG8gZ28gb24gdG9wIG9mIGl0LlxuICAgIHRpbGUgPSB0aGlzLmdldFRpbGUocGxheWVyLnBvaW50KTtcbiAgICBwbGF5ZXIudW5kZXIgPSB0aWxlO1xuXG4gICAgdGhpcy5wbGF5ZXIgPSBwbGF5ZXI7XG4gICAgdGhpcy5zZXRUaWxlKHBsYXllci5wb2ludCwgcGxheWVyKTtcbiAgICB0aGlzLnBsYXllci5ib2FyZCA9IHRoaXM7XG4gICAgdGhpcy5pbml0aWFsaXplVG9yY2godGhpcy5wbGF5ZXIpO1xuICAgIHRoaXMuZm9jdXNQb2ludCA9IHRoaXMucGxheWVyLnBvaW50O1xuXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbiBlbnRyeSBwb2ludCBmb3IgdGhpcyBib2FyZCwgc2V0IGl0IG5vd1xuICAgIGlmICghdGhpcy5lbnRyeVBvaW50KSB7XG4gICAgICAgIHRoaXMuZW50cnlQb2ludCA9IHBsYXllci5wb2ludC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIG5vdCBlZGl0aW5nLCBzZW5kIFNjcmlwdGFibGVzIHRoZSAnZW50ZXInIG1lc3NhZ2VcbiAgICBpZiAoIXRoaXMuZ2FtZS5pc0VkaXRvcikge1xuICAgICAgICBzY3JpcHRhYmxlcyA9IHRoaXMuZ2V0U2NyaXB0YWJsZXMoKTtcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgc2NyaXB0YWJsZXMubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgICBzY3JpcHRhYmxlc1tpbmRleF0uc2VuZE1lc3NhZ2UoJ0VOVEVSJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbi8qXG4gKiBJbnRpYWxpemVzIHRpbGUgZGF0YSBnaXZlbiBhIGNvbGxlY3Rpb24gb2Ygc2VyaWFsaXplZCB0aWxlcy5cbiAqXG4gKiBAcGFyYW0gdGlsZURhdGFDb2xsZWN0aW9uIGFuIGFycmF5IG9mIHNlcmlhbGl6ZWQgdGlsZSBkYXRhIHRvIGJlIGxvYWRlZFxuICogICAgICBpbnRvIHRoaXMgQm9hcmQuXG4gKi9cbkJvYXJkLnByb3RvdHlwZS5pbml0aWFsaXplVGlsZXMgPSBmdW5jdGlvbiAodGlsZURhdGFDb2xsZWN0aW9uKSB7XG5cbiAgICB2YXIgeCA9IDAsXG4gICAgICAgIHkgPSAwLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgdGlsZSxcbiAgICAgICAgdGhpbmc7XG5cbiAgICBmb3IgKGluZGV4IGluIHRpbGVEYXRhQ29sbGVjdGlvbikge1xuXG4gICAgICAgIGlmICh0aWxlRGF0YUNvbGxlY3Rpb24uaGFzT3duUHJvcGVydHkoaW5kZXgpKSB7XG5cbiAgICAgICAgICAgIHRpbGUgPSB0aWxlRGF0YUNvbGxlY3Rpb25baW5kZXhdO1xuICAgICAgICAgICAgdGhpbmcgPSBUaGluZ0ZhY3RvcnkuZGVzZXJpYWxpemUodGlsZSwgdGhpcyk7XG5cbiAgICAgICAgICAgIGlmICh0aGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUaWxlKG5ldyBQb2ludCh4LCB5KSwgdGhpbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZVRvcmNoKHRoaW5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeCArPSAxO1xuICAgICAgICAgICAgaWYgKHggPj0gdGhpcy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgICAgIHkgKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBUb3JjaCBmb3IgYSBwcm92aWRlZCB0aGluZ1xuICpcbiAqIEBwYXJhbSBBIHRoaW5nIGZvciB3aGljaCB0byBpbml0aWFsaXplIGEgdG9yY2hcbiAqL1xuQm9hcmQucHJvdG90eXBlLmluaXRpYWxpemVUb3JjaCA9IGZ1bmN0aW9uICh0aGluZykge1xuXG4gICAgdmFyIHRvcmNoO1xuXG4gICAgLy8gSWYgdGhlIGJvYXJkIGlzIGRhcmsgYW5kIHdlJ3ZlIGdvdCBhIHRvcmNoLCBhZGQgaXQgdG8gb3VyIGNvbGxlY3Rpb25cbiAgICBpZiAoISh0aGlzLmdhbWUuaXNFZGl0b3IpICYmIHRoaXMuZGFyayAmJiB0eXBlb2YgKHRoaW5nLmdldFRvcmNoKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0b3JjaCA9IHRoaW5nLmdldFRvcmNoKCk7XG4gICAgICAgIGlmICh0b3JjaCkge1xuICAgICAgICAgICAgdGhpcy50b3JjaGVzLnB1c2godG9yY2gpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQm9hcmQucHJvdG90eXBlLmluaXRpYWxpemVXaW5kb3cgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgY2FudmFzV2lkdGggPSB0aGlzLmdhbWUuY29udGV4dC5jYW52YXMud2lkdGgsXG4gICAgICAgIGNhbnZhc0hlaWdodCA9IHRoaXMuZ2FtZS5jb250ZXh0LmNhbnZhcy5oZWlnaHQ7XG5cbiAgICB0aGlzLndpbmRvd1NpemUgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgdGhpcy53aW5kb3dPcmlnaW4gPSBuZXcgUG9pbnQoMCwgMCk7XG5cbiAgICB0aGlzLndpbmRvd1NpemUueCA9IE1hdGguZmxvb3IoY2FudmFzV2lkdGggLyB0aGlzLmdhbWUucmVzb3VyY2VzLmdyYXBoaWNzLlRJTEVfU0laRS54KTtcbiAgICB0aGlzLndpbmRvd1NpemUueSA9IE1hdGguZmxvb3IoY2FudmFzSGVpZ2h0IC8gdGhpcy5nYW1lLnJlc291cmNlcy5ncmFwaGljcy5USUxFX1NJWkUueSk7XG5cbiAgICB0aGlzLndpbmRvd0xpbWl0ID0gbmV3IFBvaW50KHRoaXMud2lkdGggLSB0aGlzLndpbmRvd1NpemUueCwgdGhpcy5oZWlnaHQgLSB0aGlzLndpbmRvd1NpemUueSk7XG5cbiAgICB0aGlzLnVwZGF0ZVdpbmRvd1Bvc2l0aW9uKCk7XG5cbiAgICBpZiAodGhpcy53aW5kb3dTaXplLnggPiB0aGlzLndpZHRoKSB7XG4gICAgICAgIHRoaXMud2luZG93T3JpZ2luLnggPSAtTWF0aC5yb3VuZCgodGhpcy53aW5kb3dTaXplLnggLSB0aGlzLndpZHRoKSAvIDIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndpbmRvd1NpemUueSA+IHRoaXMuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMud2luZG93T3JpZ2luLnkgPSAtTWF0aC5yb3VuZCgodGhpcy53aW5kb3dTaXplLnkgLSB0aGlzLmhlaWdodCkgLyAyKTtcbiAgICB9XG5cblxufTtcblxuQm9hcmQucHJvdG90eXBlLnVwZGF0ZVdpbmRvd1Bvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKHRoaXMuZm9jdXNQb2ludCkge1xuXG4gICAgICAgIGlmICh0aGlzLndpZHRoID4gdGhpcy53aW5kb3dTaXplLngpIHtcbiAgICAgICAgICAgIHRoaXMud2luZG93T3JpZ2luLnggPSB0aGlzLmZvY3VzUG9pbnQueCAtIE1hdGgucm91bmQodGhpcy53aW5kb3dTaXplLnggLyAyKTtcbiAgICAgICAgICAgIHRoaXMud2luZG93T3JpZ2luLnggPSB0aGlzLndpbmRvd09yaWdpbi54IDwgMCA/IDAgOiB0aGlzLndpbmRvd09yaWdpbi54ID4gdGhpcy53aW5kb3dMaW1pdC54ID8gdGhpcy53aW5kb3dMaW1pdC54IDogdGhpcy53aW5kb3dPcmlnaW4ueDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhlaWdodCA+IHRoaXMud2luZG93U2l6ZS55KSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvd09yaWdpbi55ID0gdGhpcy5mb2N1c1BvaW50LnkgLSBNYXRoLnJvdW5kKHRoaXMud2luZG93U2l6ZS55IC8gMik7XG4gICAgICAgICAgICB0aGlzLndpbmRvd09yaWdpbi55ID0gdGhpcy53aW5kb3dPcmlnaW4ueSA8IDAgPyAwIDogdGhpcy53aW5kb3dPcmlnaW4ueSA+IHRoaXMud2luZG93TGltaXQueSA/IHRoaXMud2luZG93TGltaXQueSA6IHRoaXMud2luZG93T3JpZ2luLnk7XG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBTY3JpcHQgaW5zdGFuY2UgYnkgaXRzIG5hbWUgZm9yIHRoaXMgQm9hcmQuXG4gKlxuICogQHBhcmFtIHNjcmlwdE5hbWUgQSBuYW1lIG9mIGEgU2NyaXB0IGluc3RhbmNlXG4gKiBAcmV0dXJuIEEgU2NyaXB0IGluc3RhbmNlLlxuICovXG5Cb2FyZC5wcm90b3R5cGUuZ2V0U2NyaXB0ID0gZnVuY3Rpb24gKHNjcmlwdE5hbWUpIHtcblxuICAgIHZhciBpbmRleCwgc2NyaXB0O1xuXG4gICAgaWYgKHNjcmlwdE5hbWUgJiYgdGhpcy5zY3JpcHRzKSB7XG5cbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5zY3JpcHRzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgc2NyaXB0ID0gdGhpcy5zY3JpcHRzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzY3JpcHROYW1lID09PSBzY3JpcHQubmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzY3JpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbn07XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCB0aWxlIG9uIHRoaXMgQm9hcmQsXG4gKiBwcm92aWRpbmcgdGhlIGZ1bmN0aW9uIHdpdGggYSBUaGluZyBpbnN0YW5jZSBhbmQgdGhlIHBvaW50IGF0IHdoaWNoXG4gKiBpdCBvY2N1cnMuIElmIG5vIHRoaW5nIGluc3RhbmNlIGlzIGF0IGEgbG9jYXRpb24sIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBmb3IgZWFjaCB0aWxlXG4gKi9cbkJvYXJkLnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cbiAgICB2YXIgdmFsdWVzID0gdGhpcy50aWxlcy5zbGljZSgwKSxcbiAgICAgICAgcG9pbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG5cbiAgICBmb3IgKHBvaW50LnkgPSAwOyBwb2ludC55IDwgdGhpcy5oZWlnaHQ7IHBvaW50LnkgKz0gMSkge1xuICAgICAgICBmb3IgKHBvaW50LnggPSAwOyBwb2ludC54IDwgdGhpcy53aWR0aDsgcG9pbnQueCArPSAxKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh2YWx1ZXNbcG9pbnQueCArIHBvaW50LnkgKiB0aGlzLndpZHRoXSwgcG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGVhY2ggdGlsZSBvbiB0aGlzIEJvYXJkLFxuICogZGVsaXZlcmVkIGluIHJldmVyc2Ugb3JkZXIuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIHByb3ZpZGVkIHdpdGhcbiAqIGEgVGhpbmcgaW5zdGFuY2UgYW5kIHRoZSBwb2ludCBhdCB3aGljaCBpdCBvY2N1cnMuIElmIG5vIFRoaW5nIGluc3RhbmNlXG4gKiBpcyBhdmFpbGFibGUgYXQgYSBsb2NhdGlvbiwgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGZvciBlYWNoIHRpbGUsIGluIHJldmVyc2UuXG4gKi9cbkJvYXJkLnByb3RvdHlwZS5lYWNoQmFja3dhcmRzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cbiAgICB2YXIgdmFsdWVzID0gdGhpcy50aWxlcy5zbGljZSgwKSxcbiAgICAgICAgcG9pbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG5cbiAgICBmb3IgKHBvaW50LnkgPSB0aGlzLmhlaWdodCAtIDE7IHBvaW50LnkgPj0gMDsgcG9pbnQueSAtPSAxKSB7XG4gICAgICAgIGZvciAocG9pbnQueCA9IHRoaXMud2lkdGggLSAxOyBwb2ludC54ID49IDA7IHBvaW50LnggLT0gMSkge1xuICAgICAgICAgICAgY2FsbGJhY2sodmFsdWVzW3BvaW50LnggKyBwb2ludC55ICogdGhpcy53aWR0aF0sIHBvaW50KTtcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBlYWNoIHRpbGUgb24gdGhpcyBCb2FyZCB0aGF0IGZhbGxzIHdpdGhpblxuICogdGhpcyBib2FyZCdzIGRpc3BsYXlhYmxlIHdpbmRvdy4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgcHJvdmlkZWQgd2l0aCBhIFRoaW5nXG4gKiBpbnN0YW5jZSBhbmQgdGhlIHBvaW50IGF0IHdoaWNoIGl0IG9jY3Vycy4gSWYgbm8gVGhpbmcgaW5zdGFuY2UgaXMgYXZhaWxhYmxlIGF0IGEgbG9jYXRpb25cbiAqIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBmb3IgZWFjaCB0aWxlLlxuICovXG5Cb2FyZC5wcm90b3R5cGUuZWFjaERpc3BsYXlhYmxlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG5cbiAgICB2YXIgdmFsdWVzID0gdGhpcy50aWxlcy5zbGljZSgwKSxcbiAgICAgICAgcG9pbnQgPSBuZXcgUG9pbnQoMCwgMCksXG4gICAgICAgIHN0YXJ0WSA9IHRoaXMud2luZG93T3JpZ2luLnksXG4gICAgICAgIGVuZFkgPSBzdGFydFkgKyB0aGlzLndpbmRvd1NpemUueSxcbiAgICAgICAgc3RhcnRYID0gdGhpcy53aW5kb3dPcmlnaW4ueCxcbiAgICAgICAgZW5kWCA9IHN0YXJ0WCArIHRoaXMud2luZG93U2l6ZS54O1xuXG4gICAgc3RhcnRYID0gc3RhcnRYIDwgMCA/IDAgOiBzdGFydFg7XG4gICAgc3RhcnRZID0gc3RhcnRZIDwgMCA/IDAgOiBzdGFydFk7XG4gICAgZW5kWCA9IGVuZFggPiB0aGlzLndpZHRoID8gdGhpcy53aWR0aCA6IGVuZFg7XG4gICAgZW5kWSA9IGVuZFkgPiB0aGlzLmhlaWdodCA/IHRoaXMuaGVpZ2h0IDogZW5kWTtcblxuICAgIGZvciAocG9pbnQueSA9IHN0YXJ0WTsgcG9pbnQueSA8IGVuZFk7IHBvaW50LnkgKz0gMSkge1xuICAgICAgICBmb3IgKHBvaW50LnggPSBzdGFydFg7IHBvaW50LnggPCBlbmRYOyBwb2ludC54ICs9IDEpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHZhbHVlc1twb2ludC54ICsgcG9pbnQueSAqIHRoaXMud2lkdGhdLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHdoZXRoZXIgb3Igbm90IHRoaXMgQm9hcmQgaGFzIGEgcHJvdmlkZWQgbnVtYmVyIChvciBhbnkpIG9mIGFcbiAqIHNwZWNpZmljIHRpbGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdGVtcGxhdGUgLSBBIFRoaW5nIHRlbXBsYXRlIG9iamVjdFxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudF0gLSBBIG1pbmltdW0gbnVtYmVyIG9mIHRpbGVzIG9uIHRoZSBib2FyZCB0byB0ZXN0IGZvciwgb3IgdW5kZWZpbmVkIHRvIHRlc3QgZm9yIGFueSBudW1iZXJcbiAqL1xuQm9hcmQucHJvdG90eXBlLmhhc1RpbGUgPSBmdW5jdGlvbiAodGVtcGxhdGUsIGNvdW50KSB7XG5cbiAgICB2YXIgdGFsbHkgPSAwO1xuXG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uICh0aWxlKSB7XG5cbiAgICAgICAgaWYgKHRpbGUgJiYgdGlsZS5lcXVhbHModGVtcGxhdGUpKSB7XG4gICAgICAgICAgICB0YWxseSArPSAxO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIHJldHVybiBjb3VudCA9PT0gdW5kZWZpbmVkID8gdGFsbHkgPiAwIDogY291bnQgPD0gMCA/IHRhbGx5IDw9IDAgOiB0YWxseSA+PSBjb3VudDtcblxufTtcblxuLyoqXG4gKiBDaGFuZ2VzIGFsbCBpbnN0YW5jZXMgb2YgdGlsZXMgbWF0Y2hpbmcgYSBwcm92aWRlZCB0ZW1wbGF0ZSB3aXRoIGEgbmV3IGluc3RhbmNlIGJhc2VkXG4gKiBvbiBhbm90aGVyIHByb3ZpZGVkIHRlbXBsYXRlLlxuICpcbiAqIEBwYXJhbSBmcm9tVGVtcGxhdGUgQSB0ZW1wbGF0ZSB0byBtYXRjaCBleGlzdGluZyB0aGluZ3NcbiAqIEBwYXJhbSB0b1RlbXBsYXRlIEEgdGVtcGxhdGUgd2l0aCB3aGljaCB0byByZXBsYWNlIG1hdGNoZWQgdGhpbmdzXG4gKi9cbkJvYXJkLnByb3RvdHlwZS5jaGFuZ2VUaWxlcyA9IGZ1bmN0aW9uIChmcm9tVGVtcGxhdGUsIHRvVGVtcGxhdGUpIHtcblxuICAgIHZhciBtZSA9IHRoaXMsXG4gICAgICAgIG5ld1RoaW5nO1xuXG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uICh0aWxlKSB7XG5cbiAgICAgICAgaWYgKHRpbGUgJiYgdGlsZS5lcXVhbHMoZnJvbVRlbXBsYXRlKSkge1xuXG4gICAgICAgICAgICBuZXdUaGluZyA9IFRoaW5nRmFjdG9yeS5kZXNlcmlhbGl6ZSh0b1RlbXBsYXRlLCBtZSk7XG5cbiAgICAgICAgICAgIGlmIChuZXdUaGluZyAmJiB0b1RlbXBsYXRlLmNvbG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBuZXdUaGluZy5mb3JlZ3JvdW5kID0gdGlsZS5mb3JlZ3JvdW5kO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5yZXBsYWNlVGlsZSh0aWxlLnBvaW50LCBuZXdUaGluZyk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSB0aWxlIGZyb20gdGhpcyBCb2FyZCBhdCBhIHByb3ZpZGVkIFBvaW50LiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWxzb1xuICogdXBkYXRlIGl0cyBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiB0byByZW1vdmUgcmVmZXJlbmNlcyB0byBuby1sb25nZXItdXNlZFxuICogdGlsZXMuXG4gKlxuICogQHBhcmFtIHBvaW50IEEgcG9pbnQgb24gdGhpcyBCb2FyZCB0byBkZWxldGUuXG4gKi9cbkJvYXJkLnByb3RvdHlwZS5kZWxldGVUaWxlID0gZnVuY3Rpb24gKHBvaW50KSB7XG5cbiAgICB2YXIgdGhpbmcgPSB0aGlzLmdldFRpbGUocG9pbnQpO1xuXG4gICAgLy8gRGVsZXRlIHRoZSB0aWxlXG4gICAgaWYgKHRoaW5nKSB7XG4gICAgICAgIHRoaXMuc2V0VGlsZShwb2ludCwgdGhpbmcudW5kZXIpO1xuICAgIH1cblxufTtcblxuLyoqXG4gKiBNb3ZlcyBhIHRpbGUgb24gdGhpcyBCb2FyZCBmcm9tIGEgc3BlY2lmaWVkIFBvaW50IHRvIGFub3RoZXIgUG9pbnQuXG4gKiBJZiB0aGUgbW92ZSB3YXMgc3VjY2Vzc2Z1bCwgdHJ1ZSBpcyByZXR1cm5lZCwgb3RoZXJ3aXNlIGZhbHNlLiBXZSBjYW5cbiAqIG9wdGlvbmFsbHkgc3BlY2lmeSB3aGV0aGVyIHRoZSBtb3ZlIHNob3VsZCBiZSB3ZWFrLCBtZWFuaW5nIG1vdmVzIHNob3VsZFxuICogYmUgdHJlYXRlZCBhcyB1bnN1Y2Nlc3NmdWwgZXZlbiB3aGVuIGEgcHVzaGFibGUgVGhpbmcgaXMgaW4gdGhlIHdheS5cbiAqXG4gKiBAcGFyYW0gb2xkUG9pbnQgQSBwb2ludCBvbiB0aGlzIEJvYXJkIGNvbnRhaW5pbmcgYSB0aWxlIHRvIGJlIG1vdmVkXG4gKiBAcGFyYW0gbmV3UG9pbnQgQSBwb2ludCBvbiB0aGUgQm9hcmQgdG8gd2hpY2ggYSB0aWxlIGlzIHRvIGJlIG1vdmVkLlxuICogQHBhcmFtIHdlYWsgV2hldGhlciBvciBub3Qgd2Ugc2hvdWxkIHdlYWtseSBtb3ZlIHRoZSB0aWxlLlxuICogQHBhcmFtIGdob3N0IFdoZXRoZXIgb3Igbm90IHdlIHNob3VsZCBhY3R1YWxseSBtb3ZlIHRoZSB0aWxlLCBvciBiZWhhdmUgYXMgaWYgYSBnaG9zdCBtb3ZlZCAod2l0aG91dCBhY3R1YWxseSBtb3ZpbmcpXG4gKiBAcmV0dXJuIHRydWUgaWYgYSBtb3ZlIHdhcyBzdWNjZXNzZnVsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkJvYXJkLnByb3RvdHlwZS5tb3ZlVGlsZSA9IGZ1bmN0aW9uIChvbGRQb2ludCwgbmV3UG9pbnQsIHdlYWssIGdob3N0KSB7XG5cbiAgICB2YXIgdGhpbmcgPSB0aGlzLmdldFRpbGUob2xkUG9pbnQpLFxuICAgICAgICBvYnN0YWNsZSA9IHRoaXMuZ2V0VGlsZShuZXdQb2ludCksXG4gICAgICAgIHVuZGVyT2xkVGhpbmcsXG4gICAgICAgIHRlbGVwb3J0ZWQ7XG5cbiAgICAvLyBJZiB0aGUgY29hc3QgaXMgY2xlYXIuLi5cbiAgICBpZiAodGhpcy5pc0ZyZWUobmV3UG9pbnQpKSB7XG5cbiAgICAgICAgaWYgKCFnaG9zdCkge1xuXG4gICAgICAgICAgICB0aGlzLnNldFRpbGUobmV3UG9pbnQsIHRoaW5nKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VGlsZShvbGRQb2ludCwgdGhpbmcgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHRoaW5nLnVuZGVyKTtcblxuICAgICAgICAgICAgaWYgKHRoaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGluZy51bmRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGFyZSBibG9ja2VkLCBidXQgdGhlIHBhdGggaXMgc3VycmVuZGVyYWJsZS4uLlxuICAgIGlmICghdGhpcy5pc091dHNpZGUobmV3UG9pbnQpICYmIG9ic3RhY2xlLmlzU3VycmVuZGVyYWJsZSh0aGluZykpIHtcblxuICAgICAgICBpZiAoIWdob3N0KSB7XG4gICAgICAgICAgICAvLyBJZiBvdXIgdGhpbmcgaXNuJ3QgdW5kZWZpbmVkXG4gICAgICAgICAgICBpZiAodGhpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHVuZGVyT2xkVGhpbmcgPSB0aGluZy51bmRlcjtcbiAgICAgICAgICAgICAgICB0aGluZy51bmRlciA9IG9ic3RhY2xlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldFRpbGUobmV3UG9pbnQsIHRoaW5nKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VGlsZShvbGRQb2ludCwgdW5kZXJPbGRUaGluZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIH1cblxuICAgIC8vIElmIHdlIGNvdWxkbid0IG1vdmUgYW5kIHdlJ3JlIG5vdCB3ZWFrLCB0cnkgdG8gcHVzaCBhbmQgdHJ5IGFnYWluXG4gICAgaWYgKCF3ZWFrKSB7XG5cbiAgICAgICAgLy8gSWYgYW4gb2JzdGFjbGUgd2FzIGVuY291bnRlcmVkXG4gICAgICAgIGlmIChvYnN0YWNsZSkge1xuXG4gICAgICAgICAgICAvLyBUcnkgdG8gcHVzaCB0aGUgb2JzdGFjbGUgb3V0IG9mIHRoZSB3YXlcbiAgICAgICAgICAgIHRlbGVwb3J0ZWQgPSBvYnN0YWNsZS5wdXNoKG9sZFBvaW50LmRpcmVjdGlvblRvKG5ld1BvaW50KSwgdGhpbmcpO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSB3ZXJlIHRlbGVwb3J0ZWQsIHJldHVybiB0cnVlXG4gICAgICAgICAgICBpZiAodGVsZXBvcnRlZCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQSBzcGFjZSB3YXMgZnJlZWQgdXAgb3Igc3VycmVuZGVyYWJsZSwgc28gd2UgY2FuIG1vdmVcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRnJlZShuZXdQb2ludCkgfHwgdGhpcy5nZXRUaWxlKG5ld1BvaW50KS5pc1N1cnJlbmRlcmFibGUodGhpbmcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW92ZVRpbGUob2xkUG9pbnQsIG5ld1BvaW50LCB3ZWFrLCBnaG9zdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQXNzaWducyBhIHRpbGUgdG8gYSBzcGVjaWZpYyBQb2ludCBvbiB0aGlzIEJvYXJkLiBUaGlzIGZ1bmN0aW9uIGRvZXNcbiAqIG5vdCBjaGVjayBmb3Igc2FmdGV5IG9mIHRoaXMgb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSBwb2ludCBBIHBvaW50IHRvIGJlIHNldCB0byBhIHNwZWNpZmljIHRpbGVcbiAqIEBwYXJhbSB0aWxlIEEgdGlsZSB0byBiZSBzZXQuXG4gKi9cbkJvYXJkLnByb3RvdHlwZS5zZXRUaWxlID0gZnVuY3Rpb24gKHBvaW50LCB0aWxlKSB7XG5cbiAgICBpZiAoIXRoaXMuaXNPdXRzaWRlKHBvaW50KSkge1xuXG4gICAgICAgIGlmICh0aWxlKSB7XG5cbiAgICAgICAgICAgIHRpbGUucG9pbnQgPSBwb2ludC5jbG9uZSgpO1xuXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBhZGRpbmcgYSBwbGF5ZXIgd2hlbiB3ZSd2ZSBhbHJlYWR5IGdvdCBvbmUgb24gdGhlIGJvYXJkIGVsc2V3aGVyZS4uLlxuICAgICAgICAgICAgaWYgKHRpbGUudHlwZSA9PT0gJ1BsYXllcicgJiYgKCFwb2ludC5lcXVhbHModGhpcy5wbGF5ZXIucG9pbnQpKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvbGQgcGxheWVyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGVUaWxlKHRoaXMucGxheWVyLnBvaW50KTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBvdXIgbmV3IHBsYXllclxuICAgICAgICAgICAgICAgIHRpbGUgPSB0aGlzLnBsYXllcjtcbiAgICAgICAgICAgICAgICB0aWxlLnBvaW50ID0gcG9pbnQuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxpemVQbGF5ZXIodGhpcy5wbGF5ZXIpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGlsZXNbcG9pbnQueCArIHBvaW50LnkgKiB0aGlzLndpZHRoXSA9IHRpbGU7XG5cbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZHMgYSBUaGluZyB0byBhIHNwZWNpZmljIFBvaW50IG9uIHRoaXMgQm9hcmQuIFRoaXMgZnVuY3Rpb25cbiAqIHdpbGwgc2FmZWx5IGRlbGV0ZSBhbnkgZXhpc3RpbmcgVGhpbmcgaWYgcHJlc2VudCBhdCB0aGUgc3BlY2lmaWVkXG4gKiBsb2NhdGlvbiBhbmQgd2lsbCB1cGRhdGUgYW55IFVwZGF0ZWFibGVUaGluZyBsaXN0LCB1bmxlc3Mgd2Ugb3B0XG4gKiB0byByZXNwZWN0IHN1cnJlbmRlcmFiaWxpdHksIGluIHdoaWNoIGNhc2UgdGhlIHRoaW5nIHdpbGwgb25seSBiZSBkZWxldGVkXG4gKiBpZiBpdCByZWZ1c2VzIHRvIHN1cnJlbmRlci5cbiAqXG4gKiBAcGFyYW0gcG9pbnQgQSBwb2ludCBhdCB3aGljaCB0byBhZGQgYSBUaGluZ1xuICogQHBhcmFtIHRoaW5nIEEgVGhpbmcgdG8gYWRkIGF0IGEgZ2l2ZW4gcG9pbnRcbiAqIEBwYXJhbSByZXNwZWN0U3VycmVuZGVyYWJpbGl0eSBXaGV0aGVyIHRvIHJlc3BlY3QgdGhlIHN1cnJlbmRlcmFiaWxpdHkgb2YgYW4gaXRlbVxuICovXG5Cb2FyZC5wcm90b3R5cGUuYWRkVGhpbmcgPSBmdW5jdGlvbiAocG9pbnQsIHRoaW5nLCByZXNwZWN0U3VycmVuZGVyYWJpbHR5KSB7XG5cbiAgICB2YXIgb2xkVGhpbmcgPSB0aGlzLmdldFRpbGUocG9pbnQpO1xuXG4gICAgaWYgKG9sZFRoaW5nKSB7XG4gICAgICAgIGlmIChyZXNwZWN0U3VycmVuZGVyYWJpbHR5ICYmIG9sZFRoaW5nLmlzU3VycmVuZGVyYWJsZSh0aGluZykpIHtcbiAgICAgICAgICAgIHRoaW5nLnVuZGVyID0gb2xkVGhpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZVRpbGUocG9pbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRUaWxlKHBvaW50LCB0aGluZyk7XG5cbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBhIHNwZWNpZmljIHBvaW50IGlzIGZyZWUgb3Igc3VycmVuZGVyYWJsZSB0byBhIHByb3ZpZGVkIFRoaW5nLlxuICpcbiAqIEBwYXJhbSBwb2ludCBBIHBvaW50IHRvIHRlc3QgZm9yXG4gKiBAcGFyYW0gdGhpbmcgQSB0aGluZyB1c2VkIHRvIHRlc3QgZm9yIHN1cnJlbmRlcmFiaWxpdHkgaWYgYSBwb2ludCBpcyBub3QgZnJlZS5cbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgc3BvdCBpcyBlaXRoZXIgZnJlZSwgb3Igc3VycmVuZGVyYWJsZSB0byBhIHByb3ZpZGVkIHRoaW5nLlxuICovXG5Cb2FyZC5wcm90b3R5cGUuaXNGcmVlT3JTdXJyZW5kZXJhYmxlID0gZnVuY3Rpb24gKHBvaW50LCB0aGluZykge1xuXG4gICAgdmFyIG9ic3RhY2xlID0gdGhpcy5nZXRUaWxlKHBvaW50KTtcbiAgICByZXR1cm4gIXRoaXMuaXNPdXRzaWRlKHBvaW50KSAmJiAoKCFvYnN0YWNsZSkgfHwgKG9ic3RhY2xlLmlzU3VycmVuZGVyYWJsZSh0aGluZykpKTtcblxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSB0aWxlIGZyb20gdGhpcyBCb2FyZCBhdCBhIHByb3ZpZGVkIFBvaW50LlxuICpcbiAqIEBwYXJhbSBwb2ludCBBIHBvaW50IGZyb20gd2hpY2ggdG8gcmV0cmlldmUgYSB0aWxlLlxuICogQHJldHVybiBhIFRoaW5nIGxvY2F0ZWQgYXQgYSBwcm92aWRlZCBQb2ludCwgb3IgdW5kZWZpbmVkIGlmIG5vIHN1Y2hcbiAqICAgICAgICAgIHRoaXMgaXMgYXZhaWxhYmxlIGF0IGEgZ2l2ZW4gUG9pbnQuXG4gKi9cbkJvYXJkLnByb3RvdHlwZS5nZXRUaWxlID0gZnVuY3Rpb24gKHBvaW50KSB7XG5cbiAgICBpZiAocG9pbnQueCA+PSB0aGlzLndpZHRoIHx8IHBvaW50LnggPCAwIHx8IHBvaW50LnkgPj0gdGhpcy5oZWlnaHQgfHwgcG9pbnQueSA8IDApIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy50aWxlc1twb2ludC54ICsgcG9pbnQueSAqIHRoaXMud2lkdGhdO1xuXG59O1xuXG4vKipcbiAqIFJlcGxhY2VzIGFuIGV4aXN0aW5nIHRpbGUgYXQgYSBnaXZlbiBQb2ludCB3aXRoIGEgcHJvdmlkZWQgVGhpbmcuXG4gKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyBmb3Igc2FmdGV5LlxuICpcbiAqIEBwYXJhbSBwb2ludCBBIHBvaW50IG9uIHRoaXMgQm9hcmQgdG8gYmUgcmVwbGFjZWRcbiAqIEBwYXJhbSBBIFRoaW5nIHRvIGJlIGFkZGVkIHRvIGEgZ2l2ZW4gcG9pbnQuXG4gKi9cbkJvYXJkLnByb3RvdHlwZS5yZXBsYWNlVGlsZSA9IGZ1bmN0aW9uIChwb2ludCwgbmV3VGlsZSkge1xuICAgIHRoaXMuZGVsZXRlVGlsZShwb2ludCk7XG4gICAgdGhpcy5hZGRUaGluZyhwb2ludCwgbmV3VGlsZSwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIHByb3ZpZGVkIFBvaW50IGlzIGxvY2F0ZWQgb3V0c2lkZSBvZiB0aGlzIEJvYXJkJ3NcbiAqIGJvdW5kYXJpZXMuXG4gKlxuICogQHBhcmFtIHBvaW50IEEgcG9pbnQgdG8gY2hlY2tcbiAqIEByZXR1cm4gdHJ1ZSBpZiBhIHByb3ZpZGVkIFBvaW50IGlzIG91dGlzZGUgdGhpcyBCb2FyZCdzIGJvdW5kYXJpZXMsXG4gKiAgICAgICAgIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuQm9hcmQucHJvdG90eXBlLmlzT3V0c2lkZSA9IGZ1bmN0aW9uIChwb2ludCkge1xuXG4gICAgaWYgKHBvaW50LnkgPCAwIHx8IHBvaW50LnkgPj0gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHBvaW50LnggPCAwIHx8IHBvaW50LnggPj0gdGhpcy53aWR0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG5cbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgcHJvdmlkZWQgUG9pbnQgaXMgbG9jYXRlZCBvdXRzaWRlIG9mIHRoaXMgQm9hcmQncyB2aXNpYmxlXG4gKiB3aW5kb3cgYm91bmRhcnkuXG4gKlxuICogQHBhcmFtIHBvaW50IEEgcG9pbnQgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHRydWUgaWYgYSBwcm92aWRlZCBQb2ludCBpcyBvdXRzaWRlIHRoaXMgQm9hcmQncyBib3VuZGFyaWVzLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkJvYXJkLnByb3RvdHlwZS5pc091dHNpZGVXaW5kb3cgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICBpZiAocG9pbnQueCA8IHRoaXMud2luZG93T3JpZ2luLnggfHwgcG9pbnQueCA+PSAodGhpcy53aW5kb3dPcmlnaW4ueCArIHRoaXMud2luZG93U2l6ZS54KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHBvaW50LnkgPCB0aGlzLndpbmRvd09yaWdpbi55IHx8IHBvaW50LnkgPj0gKHRoaXMud2luZG93T3JpZ2luLnkgKyB0aGlzLndpbmRvd1NpemUueSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGEgcHJvdmlkZWQgUG9pbnQgaXMgdW5vY2N1cGllZC5cbiAqXG4gKiBAcGFyYW0gcG9pbnQgYSBQb2ludCB0byB0ZXN0LlxuICogQHJldHVybiB0cnVlIGlmIGEgcHJvdmlkZWQgUG9pbnQgaXMgZnJlZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5Cb2FyZC5wcm90b3R5cGUuaXNGcmVlID0gZnVuY3Rpb24gKHBvaW50KSB7XG5cbiAgICByZXR1cm4gIXRoaXMuaXNPdXRzaWRlKHBvaW50KSAmJiAoIXRoaXMuZ2V0VGlsZShwb2ludCkpO1xuXG59O1xuXG4vKipcbiAqIFJlcXVlc3RzIHRvIG1vdmUgdGhpcyBCb2FyZCdzIHBsYXllciB0byBhIEJvYXJkIGxvY2F0ZWRcbiAqIGluIGEgZ2l2ZW4gZGlyZWN0aW9uIHJlbGF0aXZlIHRvIHRoaXMgQm9hcmQuXG4gKlxuICogQHBhcmFtIGRpcmVjdGlvbiBBbiBhZGphY2VudCBib2FyZCBkaXJlY3Rpb24gdG8gd2hpY2ggdG9cbiAqICAgICAgICByZWxvY2F0ZSBhIHBsYXllci5cbiAqL1xuQm9hcmQucHJvdG90eXBlLm1vdmVQbGF5ZXJPZmZCb2FyZCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcblxuICAgIHZhciBib2FyZE5hbWUsXG4gICAgICAgIG9mZnNldDtcblxuICAgIC8vIEZpbmQgdGhlIGJvYXJkIHdlIGFyZSBzd2l0Y2hpbmcgdG9cbiAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgRGlyZWN0aW9uLk5vcnRoOlxuICAgICAgICBib2FyZE5hbWUgPSB0aGlzLm5vcnRoO1xuICAgICAgICBvZmZzZXQgPSB0aGlzLm5vcnRoT2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIERpcmVjdGlvbi5FYXN0OlxuICAgICAgICBib2FyZE5hbWUgPSB0aGlzLmVhc3Q7XG4gICAgICAgIG9mZnNldCA9IHRoaXMuZWFzdE9mZnNldDtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSBEaXJlY3Rpb24uU291dGg6XG4gICAgICAgIGJvYXJkTmFtZSA9IHRoaXMuc291dGg7XG4gICAgICAgIG9mZnNldCA9IHRoaXMuc291dGhPZmZzZXQ7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgRGlyZWN0aW9uLldlc3Q6XG4gICAgICAgIGJvYXJkTmFtZSA9IHRoaXMud2VzdDtcbiAgICAgICAgb2Zmc2V0ID0gdGhpcy53ZXN0T2Zmc2V0O1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTW92ZSBvdXIgcGxheWVyIHRvIHRoYXQgYm9hcmQgZWRnZVxuICAgIHRoaXMuZ2FtZS5tb3ZlUGxheWVyVG9Cb2FyZEVkZ2UoRGlyZWN0aW9uLm9wcG9zaXRlKGRpcmVjdGlvbiksIGJvYXJkTmFtZSwgb2Zmc2V0KTtcblxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBQYXNzYWdlIHdpdGggYSBwcm92aWRlZCBJRCBmcm9tIHRoaXMgYm9hcmQuXG4gKlxuICogQHBhcmFtIHBhc3NhZ2VJZCBhbiBJRCBvZiBhIHBhc3NhZ2UgdG8gcmV0cmlldmVcbiAqIEByZXR1cm4gQSBQYXNzYWdlIGluc3RhbmNlLlxuICovXG5Cb2FyZC5wcm90b3R5cGUuZ2V0UGFzc2FnZSA9IGZ1bmN0aW9uIChwYXNzYWdlSWQpIHtcblxuICAgIHZhciByb3csIGNvbHVtbiwgdGlsZTtcblxuICAgIGZvciAocm93ID0gMDsgcm93IDwgdGhpcy5oZWlnaHQ7IHJvdyArPSAxKSB7XG4gICAgICAgIGZvciAoY29sdW1uID0gMDsgY29sdW1uIDwgdGhpcy53aWR0aDsgY29sdW1uICs9IDEpIHtcbiAgICAgICAgICAgIHRpbGUgPSB0aGlzLmdldFRpbGUobmV3IFBvaW50KGNvbHVtbiwgcm93KSk7XG4gICAgICAgICAgICBpZiAodGlsZSAmJiB0aWxlLnR5cGUgPT09ICdQYXNzYWdlJyAmJiB0aWxlLnBhc3NhZ2VJZCA9PT0gcGFzc2FnZUlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbi8qKlxuICogQWRkcyBhIHByb3ZpZGVkIG1lc3NhZ2UgdG8gdGhpcyBCb2FyZCdzIHF1ZXVlIG9mIG1lc3NhZ2VzIHRvIGdsb2JhbGx5XG4gKiBzZW5kIHRvIGFsbCBVcGRhdGVhYmxlVGhpbmdzIHRyYWNrZWQgYnkgdGhpcyBCb2FyZC5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBBIG1lc3NhZ2UgdG8gYmUgZGVsaXZlcmVkIHRvIGFsbCBVcGRhdGVhYmxlVGhpbmdzLlxuICovXG5Cb2FyZC5wcm90b3R5cGUuYWRkTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlUXVldWUucHVzaChtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHdoZXRoZXIgb3Igbm90IGEgcHJvdmlkZWQgcG9pbnQgZmFsbHMgd2l0aGluIGFueSBvZiB0aGlzXG4gKiBCb2FyZCdzIHRvcmNoZXMuXG4gKlxuICogQHBhcmFtIHBvaW50IEEgUG9pbnQgdG8gdGVzdCBpZiBpdCdzIGluc2lkZSBhIHRvcmNoIGNpcmNsZVxuICogQHBhcmFtIHRoaW5nIEEgdGhpbmcgYXQgdGhlIHBvaW50IHRvIHRlc3QgaWYgaXQncyBnbG93aW5nIChvciBsaXQgYnkgdG9yY2hlcylcbiAqIEByZXR1cm4gdHJ1ZSBpZiBhIHByb3ZpZGVkIHBvaW50IGlzIHdpdGhpbiBhbnkgdG9yY2ggY2lyY2xlLCBmYWxzZSBvdGhlcndpc2VcbiAqL1xuQm9hcmQucHJvdG90eXBlLmlzTGl0ID0gZnVuY3Rpb24gKHBvaW50LCB0aGluZykge1xuXG4gICAgdmFyIGluZGV4LFxuICAgICAgICB0b3JjaDtcblxuICAgIGlmICh0aGluZyAmJiB0aGluZy5nbG93KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRoaXMudG9yY2hlcy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgdG9yY2ggPSB0aGlzLnRvcmNoZXNbaW5kZXhdO1xuICAgICAgICBpZiAodG9yY2guY29udGFpbnMocG9pbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGFub3RoZXIgcGxheWVyIGJ1bGxldCBpcyBwZXJtaXNzYWJsZSBvbiB0aGUgYm9hcmRcbiAqIGFmdGVyIHRoZSBtb3N0IHJlY2VudCB1cGRhdGUuXG4gKlxuICogQHBhcmFtIGRpc3BsYXlNZXNzYWdlIFdoZXRoZXIgb3Igbm90IHRvIGRpc3BsYXkgYSBtZXNzYWdlIGlmIG5vIHNob290aW5nIGlzIGFsbG93ZWQsIGV2ZXIuXG4gKiBAcmV0dXJuIHRydWUgaWYgYW5vdGhlciBwbGF5ZXIgYnVsbGV0IGlzIGFsbG93ZWQsIGZhbHNlIG90aGVyd2lzZVxuICovXG5Cb2FyZC5wcm90b3R5cGUuY2FuUGxheWVyU2hvb3QgPSBmdW5jdGlvbiAoZGlzcGxheU1lc3NhZ2UpIHtcblxuICAgIGlmIChkaXNwbGF5TWVzc2FnZSAmJiB0aGlzLm1heFBsYXllckJ1bGxldHMgPD0gMCkge1xuICAgICAgICB0aGlzLnNldERpc3BsYXlNZXNzYWdlKGkxOG4uZ2V0TWVzc2FnZSgnc3RhdHVzLm5vc2hvb3QnKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucGxheWVyQnVsbGV0cyA8IHRoaXMubWF4UGxheWVyQnVsbGV0cztcblxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoaXMgQm9hcmQgaW5zdGFuY2UgYnkgb25lIHRpY2sgaW4gYW4gZXhlY3V0aW9uIGN5Y2xlLiBUaGlzIHdpbGwgYWxzb1xuICogdXBkYXRlIGFsbCBVcGRhdGVhYmxlVGhpbmdzIHRyYWNrZWQgYnkgdGhpcyBCb2FyZC5cbiAqL1xuQm9hcmQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBtZSA9IHRoaXM7XG5cbiAgICAvLyBVcGRhdGUgdGhlIHNtYXJ0IHBhdGhcbiAgICB0aGlzLnVwZGF0ZVNtYXJ0UGF0aCh0aGlzLnBsYXllci5wb2ludCk7XG5cbiAgICAvLyBJbml0aWFsaXplIG91ciBjdXN0b20gcmVuZGVyYWJsZSBsaXN0XG4gICAgdGhpcy5jdXN0b21SZW5kZXJTZXQgPSBbXTtcblxuICAgIC8vIEluaXRpYWxpemUgb3VyIGJ1bGxldCBjb3VudFxuICAgIHRoaXMucGxheWVyQnVsbGV0cyA9IDA7XG5cbiAgICAvLyBJZiB0aGUgYm9hcmQgaXMgZGFyaywgaW5pdGlhbGl6ZSBvdXIgdG9yY2hlc1xuICAgIGlmICh0aGlzLmRhcmspIHtcbiAgICAgICAgdGhpcy50b3JjaGVzID0gW107XG4gICAgfVxuXG4gICAgLypcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdvcmtzIGFzIGZvbGxvd3M6IEVhY2ggdGlsZSBpcyBsb29wZWQgdGhyb3VnaCBpbiBzZXF1ZW50aWFsXG4gICAgICogb3JkZXIsIGFuZCBvbmNlIGFnYWluIGluIHJldmVyc2Ugb3JkZXIuIEEgdGlsZSBtYXkgb3B0IHRvIGJlIHNlbnQgaXRzXG4gICAgICogdXBkYXRlIG1lc3NhZ2UgaW4gZWl0aGVyIG9uZSBsb29wIG9yIHRoZSBvdGhlciB2aWEgaXRzIHVwZGF0ZU9uUmV2ZXJzZVxuICAgICAqIGZ1bmN0aW9uLiBUaWxlcyBtYXkgd2lzaCB0byB1cGRhdGUgaW4gcmV2ZXJzZSBiZWNhdXNlIHRoZXkgYXJlIGFib3V0IHRvXG4gICAgICogbW92ZSBpbiB0aGUgc2FtZSBkaXJlY3Rpb24gYXMgdGhlIHVwZGF0ZXMgKGZvciBleGFtcGxlLCBhIEJ1bGxldCB0cmF2ZWxsaW5nXG4gICAgICogU291dGgpLiBUaGlzIHJlc3VsdHMgaW4gc21vb3RoZXIgbW90aW9uIGZvciBzdWNoIG1vdmVtZW50cy5cbiAgICAgKi9cblxuICAgIC8vIEZvciBlYWNoIHRpbGUgb24gb3VyIGJvYXJkLi4uXG4gICAgdGhpcy5lYWNoKGZ1bmN0aW9uICh0aWxlKSB7XG5cbiAgICAgICAgaWYgKHRpbGUpIHtcblxuICAgICAgICAgICAgLy8gSWYgd2UgZ290IGEgcGxheWVyIGJ1bGxldCwgdXBkYXRlIG91ciBjb3VudFxuICAgICAgICAgICAgaWYgKHRpbGUudHlwZSA9PT0gJ0J1bGxldCcgJiYgdGlsZS5mcm9tUGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbWUucGxheWVyQnVsbGV0cyArPSAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB3ZSBnb3QgYW4gdXBkYXRlYWJsZSB0aWxlLi4uXG4gICAgICAgICAgICBpZiAoKHR5cGVvZiB0aWxlLnVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykgJiYgKHR5cGVvZiB0aWxlLnVwZGF0ZU9uUmV2ZXJzZSA9PT0gJ2Z1bmN0aW9uJykgJiYgdGlsZS50eXBlICE9PSAnUGxheWVyJykge1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgYXJlbid0IHVwZGF0aW5nIGJhY2t3YXJkcy4uLlxuICAgICAgICAgICAgICAgIGlmICghdGlsZS51cGRhdGVPblJldmVyc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aWxlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGUgdGlsZSB0aGUgdGhpbmcgaXMgb24gaXMgdXBkYXRlYWJsZSB3aGlsZSB1bmRlci4uLlxuICAgICAgICAgICAgaWYgKHRpbGUudW5kZXIgJiYgdGlsZS51bmRlci51cGRhdGVXaGlsZVVuZGVyKSB7XG4gICAgICAgICAgICAgICAgdGlsZS51bmRlci51cGRhdGVXaGlsZVVuZGVyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGdvdCBhIHRpbGUgd2l0aCBhIGN1c3RvbSByZW5kZXJlci4uLlxuICAgICAgICAgICAgaWYgKHRpbGUucmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgbWUuY3VzdG9tUmVuZGVyU2V0LnB1c2godGlsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBvdXIgdG9yY2gsIGlmIGFwcGxpY2FibGVcbiAgICAgICAgICAgIGlmICh0aWxlLnR5cGUgIT09ICdQbGF5ZXInKSB7XG4gICAgICAgICAgICAgICAgbWUuaW5pdGlhbGl6ZVRvcmNoKHRpbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLy8gRm9yIGVhY2ggdGlsZSBvbiBvdXIgYm9hcmQgaW4gcmV2ZXJzZS4uLlxuICAgIHRoaXMuZWFjaEJhY2t3YXJkcyhmdW5jdGlvbiAodGlsZSkge1xuXG4gICAgICAgIC8vIElmIGEgdGlsZSB3YW50cyB0byBiZSB1ZHBhdGVkIGJhY2t3YXJkcywgZG8gaXQgbm93XG4gICAgICAgIGlmICh0aWxlICYmICh0eXBlb2YgdGlsZS51cGRhdGUgPT09ICdmdW5jdGlvbicpICYmICh0eXBlb2YgdGlsZS51cGRhdGVPblJldmVyc2UgPT09ICdmdW5jdGlvbicpICYmIHRpbGUudXBkYXRlT25SZXZlcnNlKCkgJiYgKHRpbGUudHlwZSAhPT0gJ1BsYXllcicpKSB7XG4gICAgICAgICAgICB0aWxlLnVwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoaXMgQm9hcmQgaXMgdGhlIHNhbWUgYXMgYW5vdGhlciBib2FyZCwgZWl0aGVyIGJ5XG4gKiBuYW1lIG9yIHJlZmVyZW5jZS5cbiAqXG4gKiBAcGFyYW0gb3RoZXJCb2FyZCBhbm90aGVyIEJvYXJkIG9yIG5hbWUgb2YgYW5vdGhlciBib2FyZCB0byB0ZXN0IGZvciBlcXVhbGl0eS5cbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIEJvYXJkIGlzIHRoZSBzYW1lIGJ5IG5hbWUsIGZhbHNlIG90aGVyd2lzZVxuICovXG5Cb2FyZC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyQm9hcmQpIHtcblxuICAgIHZhciBvdGhlck5hbWUgPSAob3RoZXJCb2FyZCBpbnN0YW5jZW9mIEJvYXJkKSA/IG90aGVyQm9hcmQubmFtZSA6IG90aGVyQm9hcmQ7XG4gICAgcmV0dXJuIHRoaXMubmFtZSA9PT0gb3RoZXJOYW1lO1xuXG59O1xuXG4vKipcbiAqIEFzc2lnbnMgYSBtZXNzYWdlIHRvIGJlIHRlbXBvcmFyaWx5IGRpc3BsYXllZCBhdCB0aGUgYm90dG9tIG9mIHRoaXMgQm9hcmQuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgYSBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZC5cbiAqL1xuQm9hcmQucHJvdG90eXBlLnNldERpc3BsYXlNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGR1cmF0aW9uKSB7XG5cbiAgICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuZGlzcGxheU1lc3NhZ2UgPSAnICcgKyBtZXNzYWdlICsgJyAnO1xuICAgICAgICBpZiAodGhpcy5kaXNwbGF5TWVzc2FnZS5sZW5ndGggPiB0aGlzLndpbmRvd1NpemUueCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5TWVzc2FnZSA9IHRoaXMuZGlzcGxheU1lc3NhZ2Uuc3Vic3RyaW5nKDAsIHRoaXMud2luZG93U2l6ZS54KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BsYXlNZXNzYWdlVGljayA9IGR1cmF0aW9uID8gdGhpcy5nYW1lLkZQUyAqIGR1cmF0aW9uIDogdGhpcy5ESVNQTEFZX01FU1NBR0VfVFRMO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZGlzcGxheU1lc3NhZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZGlzcGxheU1lc3NhZ2VUaWNrID0gMDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbmRlcnMgYSB2aXN1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBCb2FyZCB0byBhIHByb3ZpZGVkIGdyYXBoaWNzXG4gKiBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSBjIEEgZ3JhcGhpY3MgY29udGV4dC5cbiAqL1xuQm9hcmQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjKSB7XG5cbiAgICB2YXIgbWUgPSB0aGlzLFxuICAgICAgICBjYW52YXNXaWR0aCA9IHRoaXMuZ2FtZS5jb250ZXh0LmNhbnZhcy53aWR0aCxcbiAgICAgICAgY2FudmFzSGVpZ2h0ID0gdGhpcy5nYW1lLmNvbnRleHQuY2FudmFzLmhlaWdodCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHN0YXJ0WCxcbiAgICAgICAgc3RhcnRZLFxuICAgICAgICBlbmRYLFxuICAgICAgICBlbmRZO1xuXG4gICAgLy8gVXBkYXRlIG91ciB3aW5kb3dcbiAgICB0aGlzLnVwZGF0ZVdpbmRvd1Bvc2l0aW9uKCk7XG5cbiAgICAvLyBEcmF3IG91ciBib3JkZXIsIGlmIGFwcGxpY2FibGVcbiAgICBpZiAodGhpcy53aW5kb3dPcmlnaW4ueCA8IDAgfHwgdGhpcy53aW5kb3dPcmlnaW4ueSA8IDApIHtcbiAgICAgICAgYy5maWxsU3R5bGUgPSBDb2xvcnMuR3JleS5yZ2JWYWx1ZTtcbiAgICAgICAgYy5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvLyBEcmF3IG91ciBib2FyZCBiYWNrZ3JvdW5kXG4gICAgYy5maWxsU3R5bGUgPSAhbWUuZ2FtZS5pc0VkaXRvciAmJiBtZS5kYXJrID8gdGhpcy5nYW1lLkRBUktfUEFUVEVSTiA6IENvbG9ycy5CbGFjay5yZ2JWYWx1ZTtcbiAgICBzdGFydFggPSBNYXRoLm1heCgtdGhpcy53aW5kb3dPcmlnaW4ueCAqIHRoaXMuZ2FtZS5yZXNvdXJjZXMuZ3JhcGhpY3MuVElMRV9TSVpFLngsIDApO1xuICAgIHN0YXJ0WSA9IE1hdGgubWF4KC10aGlzLndpbmRvd09yaWdpbi55ICogdGhpcy5nYW1lLnJlc291cmNlcy5ncmFwaGljcy5USUxFX1NJWkUueSwgMCk7XG4gICAgZW5kWCA9IE1hdGgubWluKHRoaXMud2lkdGggKiB0aGlzLmdhbWUucmVzb3VyY2VzLmdyYXBoaWNzLlRJTEVfU0laRS54LCB0aGlzLndpbmRvd1NpemUueCAqIHRoaXMuZ2FtZS5yZXNvdXJjZXMuZ3JhcGhpY3MuVElMRV9TSVpFLngpO1xuICAgIGVuZFkgPSBNYXRoLm1pbih0aGlzLmhlaWdodCAqIHRoaXMuZ2FtZS5yZXNvdXJjZXMuZ3JhcGhpY3MuVElMRV9TSVpFLnksIHRoaXMud2luZG93U2l6ZS55ICogdGhpcy5nYW1lLnJlc291cmNlcy5ncmFwaGljcy5USUxFX1NJWkUueSk7XG4gICAgYy5maWxsUmVjdChzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSk7XG5cbiAgICAvLyBGb3IgZWFjaCBkaXNwbGF5YWJsZSB0aWxlLi4uXG4gICAgdGhpcy5lYWNoRGlzcGxheWFibGUoZnVuY3Rpb24gKHRoaW5nLCBwb2ludCkge1xuXG4gICAgICAgIHZhciBzcHJpdGUsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kO1xuXG4gICAgICAgIC8vIElmIHRoaXMgYm9hcmQgaXMgZGFyaywgYW5kIHdlJ3JlIG5vdCB2aXNpYmxlLCBza2lwIHRoaXMgaXRlcmF0aW9uXG4gICAgICAgIGlmICghbWUuZ2FtZS5pc0VkaXRvciAmJiBtZS5kYXJrICYmICFtZS5pc0xpdChwb2ludCwgdGhpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgdGhpbmcgdG8gcmVuZGVyLi4uXG4gICAgICAgIGlmICh0aGluZyAmJiAhdGhpbmcuaGlkZGVuKSB7XG5cbiAgICAgICAgICAgIC8vIEdyYWIgb3VyIHNwcml0ZVxuICAgICAgICAgICAgc3ByaXRlID0gbWUuZ2FtZS5yZXNvdXJjZXMuZ3JhcGhpY3MuZ2V0U3ByaXRlKHRoaW5nLmdldFNwcml0ZUluZGV4KCkpO1xuXG4gICAgICAgICAgICAvLyBPdXIgYmFja2dyb3VuZCBjb2xvdXIgbWF5IGNvbWUgZnJvbSB0aGUgJ3VuZGVyJyB0aWxlIGlmIG5vIGJhY2tncm91bmQgaXMgZGVmaW5lZFxuICAgICAgICAgICAgYmFja2dyb3VuZCA9IHRoaW5nLmJhY2tncm91bmQ7XG5cbiAgICAgICAgICAgIGlmICghYmFja2dyb3VuZCAmJiB0aGluZy51bmRlciAmJiB0aGluZy51bmRlci5iYWNrZ3JvdW5kKSB7XG5cbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kID0gdGhpbmcudW5kZXIuYmFja2dyb3VuZC5pc0xpZ2h0KCkgPyB0aGluZy51bmRlci5iYWNrZ3JvdW5kLmRhcmtlbigpIDogdGhpbmcudW5kZXIuYmFja2dyb3VuZDtcblxuICAgICAgICAgICAgfSBlbHNlIGlmICghYmFja2dyb3VuZCAmJiBtZS5kYXJrKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgcm9vbSBpcyBkYXJrLCBzbyBvdXIgYmFja2dyb3VuZCBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICAvLyBibGFjayBpbnN0ZWFkIG9mIHRyYW5zcGFyZW50XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZCA9IENvbG9ycy5CbGFjaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBEcmF3IG91ciBzcHJpdGVcbiAgICAgICAgICAgIHNwcml0ZS5kcmF3KGMsIHBvaW50LnN1YnRyYWN0KG1lLndpbmRvd09yaWdpbiksIHRoaW5nLmZvcmVncm91bmQsIGJhY2tncm91bmQpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaW5nICYmIG1lLmRhcmspIHtcblxuICAgICAgICAgICAgLy8gVGhlcmUncyBub3RoaW5nIHRvIHJlbmRlciwgYnV0IHdlJ3JlIHdpdGhpbiB0aGUgdG9yY2hcbiAgICAgICAgICAgIC8vIHJhZGl1cywgc28gZHJhdyBhbiBlbXB0eSBzcGFjZSBvdmVyIHRoZSAnZGFya25lc3MnXG4gICAgICAgICAgICBtZS5nYW1lLnJlc291cmNlcy5ncmFwaGljcy5maWxsVGlsZShjLCBwb2ludC5zdWJ0cmFjdChtZS53aW5kb3dPcmlnaW4pLCBDb2xvcnMuQmxhY2spO1xuXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIERlYnVnIHJlbmRlcmluZy4uLlxuICAgICAgICAvL1xuICAgICAgICAvKlxuICAgICAgICB2YXIgcCA9IG1lLmdldFNtYXJ0VmFsdWUocG9pbnQpO1xuICAgICAgICBpZihwICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgYy5maWxsU3R5bGUgPSAnZ3JheSc7XG4gICAgICAgICAgICB2YXIgZHJhd3BvaW50ID0gcG9pbnQuc3VidHJhY3QobWUud2luZG93T3JpZ2luKTtcbiAgICAgICAgICAgIGMuZmlsbFRleHQobWUuZ2V0U21hcnRWYWx1ZShwb2ludCkudG9TdHJpbmcoKSwgZHJhd3BvaW50LnggKiAzMiArIDgsIGRyYXdwb2ludC55ICogNjQgKyAzMik7XG4gICAgICAgIH1cbiAgICAgICAgKi9cblxuXG4gICAgfSk7XG5cbiAgICAvLyBGb3IgZWFjaCBpdGVtIGluIG91ciBjdXN0b20gcmVuZGVyIHNldFxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuY3VzdG9tUmVuZGVyU2V0Lmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICB0aGlzLmN1c3RvbVJlbmRlclNldFtpbmRleF0ucmVuZGVyKGMpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgZGlzcGxheSBtZXNzYWdlLCByZW5kZXIgaXRcbiAgICBpZiAodGhpcy5kaXNwbGF5TWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMucmVuZGVyTWVzc2FnZShjKTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogU2V0cyBhIHBvaW50IG9uIHRoZSBcInNtYXJ0IHBhdGhcIiB0byBiZSB3ZWlnaHRlZCBkaWZmZXJlbnRseSwgY3JlYXRpbmcgZWl0aGVyIGFuIGF2ZXJzaW9uXG4gKiBwb2ludCBvciBhbiBhdHRyYWN0aW9uIHBvaW50LlxuICovXG5Cb2FyZC5wcm90b3R5cGUuYWRqdXN0U21hcnRQYXRoV2VpZ2h0ID0gZnVuY3Rpb24gKHBvaW50LCBzdHJlbmd0aERlbHRhKSB7XG5cbiAgICB2YXIgcGF0aEluZGV4ID0gcG9pbnQueCArIHBvaW50LnkgKiB0aGlzLndpZHRoO1xuICAgIGlmICghdGhpcy5pc091dHNpZGUocG9pbnQpICYmIHRoaXMuc21hcnRQYXRoW3BhdGhJbmRleF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNtYXJ0UGF0aFtwYXRoSW5kZXhdICs9IHN0cmVuZ3RoRGVsdGE7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIFByZWNvbXB1dGVzIGEgXCJzbWFydCBwYXRoXCIgdG93YXJkIGEgcHJvdmlkZWQgdGFyZ2V0IHBvaW50LiBUaGlzIHdpbGwgYWRkIHBhdGgtZmluZGluZyBpbmZvcm1hdGlvblxuICogdGhhdCBjYW4gYmUgcXVlcmllZCB0byBmaW5kIGEgbW9zdCBlZmZpY2llbnQgcGF0aCBmcm9tIGFueSBwb2ludCBvbiB0aGUgZ3JpZCB0b3dhcmQgdGhpcyB0YXJnZXQuXG4gKlxuICogQHBhcmFtIHRhcmdldFBvaW50IEEgdGFyZ2V0IHBvaW50IHRvIHdoaWNoIHRoZSBzbWFydCBwYXRoIHNob3VsZCBiZSBjb21wdXRlZC5cbiAqL1xuQm9hcmQucHJvdG90eXBlLnVwZGF0ZVNtYXJ0UGF0aCA9IGZ1bmN0aW9uICh0YXJnZXRQb2ludCkge1xuXG4gICAgdmFyIG1lID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVBhdGgoY3VycmVudFgsIGN1cnJlbnRZLCBjdXJyZW50RGlzdGFuY2UpIHtcblxuICAgICAgICB2YXIgaW5kZXgsXG4gICAgICAgICAgICB0aWxlLFxuICAgICAgICAgICAgcGF0aFZhbHVlLFxuICAgICAgICAgICAgdmFsaWRUaWxlO1xuXG4gICAgICAgIC8vIElmIG91ciB2YWx1ZXMgYXJlIHdpdGhpbiB0aGUgZ3JpZCByYW5nZS4uLlxuICAgICAgICBpZiAoY3VycmVudERpc3RhbmNlIDwgNTAgJiYgY3VycmVudFggPj0gMCAmJiBjdXJyZW50WCA8IG1lLndpZHRoICYmIGN1cnJlbnRZID49IDAgJiYgY3VycmVudFkgPCBtZS5oZWlnaHQpIHtcblxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIG91ciBpbmRleFxuICAgICAgICAgICAgaW5kZXggPSBjdXJyZW50WCArIGN1cnJlbnRZICogbWUud2lkdGg7XG5cbiAgICAgICAgICAgIC8vIEdldCBvdXIgdGlsZSBhbmQgZXhpc3RpbmcgcGF0aCB2YWx1ZVxuICAgICAgICAgICAgdGlsZSA9IG1lLnRpbGVzW2luZGV4XTtcbiAgICAgICAgICAgIHZhbGlkVGlsZSA9ICh0aWxlID09PSB1bmRlZmluZWQgfHwgKHRpbGUgJiYgdGlsZS50eXBlID09PSAnQnVsbGV0JykpO1xuICAgICAgICAgICAgcGF0aFZhbHVlID0gbWUuc21hcnRQYXRoW2luZGV4XTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbmVpdGhlciBhIHRpbGUsIG5vciBhbiBleGlzdGluZyB2YWx1ZSB0aGVuIHdlJ3JlIGdvb2QgdG8gZ29cbiAgICAgICAgICAgIGlmIChjdXJyZW50RGlzdGFuY2UgPD0gMCB8fCAodmFsaWRUaWxlICYmIChwYXRoVmFsdWUgPT09IHVuZGVmaW5lZCB8fCBwYXRoVmFsdWUgPiBjdXJyZW50RGlzdGFuY2UpKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQXNzaWduIG91ciBwYXRoIGRpc3RhbmNlIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICAgICAgICBtZS5zbWFydFBhdGhbY3VycmVudFggKyBjdXJyZW50WSAqIG1lLndpZHRoXSA9IGN1cnJlbnREaXN0YW5jZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGlzdGFuY2UgKz0gMTtcblxuICAgICAgICAgICAgICAgIC8vIERvIHRoZSBzYW1lIGZvciBlYWNoIG9mIHRoZSBmb3VyIHN1cnJvdW5kaW5nIGRpcmVjdGlvbnNcbiAgICAgICAgICAgICAgICB1cGRhdGVQYXRoKGN1cnJlbnRYICsgMSwgY3VycmVudFksIGN1cnJlbnREaXN0YW5jZSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlUGF0aChjdXJyZW50WCAtIDEsIGN1cnJlbnRZLCBjdXJyZW50RGlzdGFuY2UpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVBhdGgoY3VycmVudFgsIGN1cnJlbnRZICsgMSwgY3VycmVudERpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVQYXRoKGN1cnJlbnRYLCBjdXJyZW50WSAtIDEsIGN1cnJlbnREaXN0YW5jZSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBDbGVhciB0aGUgb2xkIHBhdGhcbiAgICB0aGlzLnNtYXJ0UGF0aCA9IFtdO1xuICAgIHVwZGF0ZVBhdGgodGFyZ2V0UG9pbnQueCwgdGFyZ2V0UG9pbnQueSwgMCk7XG4gICAgdGhpcy51cGRhdGVQYXRoV2VpZ2h0cygpO1xuXG59O1xuXG5Cb2FyZC5wcm90b3R5cGUudXBkYXRlUGF0aFdlaWdodHMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmVhY2goZnVuY3Rpb24gKHRpbGUpIHtcbiAgICAgICAgaWYgKHRpbGUgJiYgdGlsZS5pbmZsdWVuY2VTbWFydFBhdGgpIHtcbiAgICAgICAgICAgIHRpbGUuaW5mbHVlbmNlU21hcnRQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBwcmVjb21wdXRlZCB3ZWlnaHRlZCB2YWx1ZSBpbmRpY2F0aW5nIHRoZSBudW1iZXIgb2Ygc3RlcHMgdG93YXJkIGEgcHJlLXNwZWNpZmllZCB0YXJnZXRcbiAqIGluIG91ciBzbWFydCBwYXRoIGZvciBhIHNwZWNpZmllZCBQb2ludC5cbiAqXG4gKiBAcGFyYW0gcG9pbnQgQSBQb2ludCBmb3Igd2hpY2ggdG8gcmV0cmlldmUgYSBzbWFydCB2YWx1ZS5cbiAqIEByZXR1cm4gQSB3ZWlnaHRlZCB2YWx1ZSBpbmRpY2F0aW5nIHRoZSBudW1iZXIgb2Ygc3RlcHMgdG93YXJkIGEgdGFyZ2V0LlxuICovXG5Cb2FyZC5wcm90b3R5cGUuZ2V0U21hcnRWYWx1ZSA9IGZ1bmN0aW9uIChwb2ludCkge1xuXG4gICAgdmFyIHJlc3VsdDtcblxuICAgIGlmIChwb2ludC54ID49IHRoaXMud2lkdGggfHwgcG9pbnQueCA8IDAgfHwgcG9pbnQueSA+PSB0aGlzLmhlaWdodCB8fCBwb2ludC55IDwgMCkge1xuICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gdGhpcy5zbWFydFBhdGhbcG9pbnQueCArIHBvaW50LnkgKiB0aGlzLndpZHRoXTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHJlc3VsdDtcblxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBkaXJlY3Rpb24gdG93YXJkIHRoZSBjdXJyZW50bHkgY29tcHV0ZWQgc21hcnQgcGF0aCB0YXJnZXQgZnJvbSBhIHNwZWNpZmllZFxuICogUG9pbnQuXG4gKlxuICogQHBhcmFtIHBvaW50IEEgcG9pbnQgZnJvbSB3aGljaCB0byBkZXRlcm1pbmUgYSBkaXJlY3Rpb24gdG93YXJkIG91ciBjdXJyZW50IHNtYXJ0IHRhcmdldC5cbiAqIEByZXR1cm4gQSBEaXJlY3Rpb24gUG9pbnQuXG4gKi9cbkJvYXJkLnByb3RvdHlwZS5nZXRTbWFydERpcmVjdGlvbiA9IGZ1bmN0aW9uIChwb2ludCkge1xuXG4gICAgdmFyIGRpcmVjdGlvbnMgPSBbXSxcbiAgICAgICAgbWUgPSB0aGlzLFxuICAgICAgICBjdXJyZW50TWluID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlO1xuXG4gICAgLy8gRm9yIGVhY2ggZGlyZWN0aW9uLi4uXG4gICAgRGlyZWN0aW9uLmVhY2goZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuXG4gICAgICAgIC8vIEdldCBvdXIgc21hcnQgcGF0aCB2YWx1ZVxuICAgICAgICB2YWx1ZSA9IG1lLmdldFNtYXJ0VmFsdWUocG9pbnQuYWRkKGRpcmVjdGlvbikpO1xuXG4gICAgICAgIC8vIElmIGl0J3MgdGhlIGJlc3Qgb25lIHdlJ3ZlIGVuY291bnRlcmVkLi4uXG4gICAgICAgIGlmICh2YWx1ZSA8IGN1cnJlbnRNaW4pIHtcblxuICAgICAgICAgICAgLy8gRm9yZ2V0IG91ciBwcmV2aW91cyBkaXJlY3Rpb25zXG4gICAgICAgICAgICBkaXJlY3Rpb25zID0gW107XG5cbiAgICAgICAgICAgIC8vIEFkZCB0aGlzIGRpcmVjdGlvbiBhcyBvdXIgbmV3IGZhdm91cml0ZVxuICAgICAgICAgICAgZGlyZWN0aW9ucy5wdXNoKGRpcmVjdGlvbik7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBvdXIgY3VycmVudCBtaW5pbXVtIHZhbHVlXG4gICAgICAgICAgICBjdXJyZW50TWluID0gdmFsdWU7XG5cbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gY3VycmVudE1pbikge1xuXG4gICAgICAgICAgICAvLyBPdXIgdmFsdWUgaXMgdGhlIHNhbWUsIHNvIGFkZCB0aGlzIGRpcmVjdGlvbiB0b29cbiAgICAgICAgICAgIGRpcmVjdGlvbnMucHVzaChkaXJlY3Rpb24pO1xuXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLy8gSWYgbm8gZ29vZCBkaXJlY3Rpb25zIHdlcmUgZm91bmQsIHJldHVybiB1bmRlZmluZWRcbiAgICBpZiAoY3VycmVudE1pbiA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBvbmx5IGZvdW5kIG9uZSBkaXJlY3Rpb24sIHJldHVybiBpdCBpbW1lZGlhdGVseVxuICAgIGlmIChkaXJlY3Rpb25zLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiBkaXJlY3Rpb25zWzBdO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSBwaWNrIG9uZSBvZiBvdXIgZXF1YWwgdmFsdWVzIHJhbmRvbWx5XG4gICAgcmV0dXJuIERpcmVjdGlvbi5yYW5kb20oZGlyZWN0aW9ucyk7XG5cbn07XG5cbkJvYXJkLnByb3RvdHlwZS5nZXRNZXNzYWdlID0gZnVuY3Rpb24gKGtleSkge1xuXG4gICAgdmFyIHJlc3VsdCxcbiAgICAgICAgbGFuZ3VhZ2UgPSBpMThuLmdldExhbmd1YWdlKCk7XG5cbiAgICByZXN1bHQgPSB0aGlzLmdldE1lc3NhZ2VGb3JMYW5ndWFnZShsYW5ndWFnZSwga2V5KTtcblxuICAgIC8vIElmIG5vIG1lc3NhZ2Ugd2FzIGZvdW5kIGFuZCB3ZSBoYXZlbid0IHRyaWVkIHRoZSBkZWZhdWx0IGxhbmd1YWdlLi4uXG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIGxhbmd1YWdlICE9PSBpMThuLkRlZmF1bHRMYW5ndWFnZSkge1xuICAgICAgICByZXN1bHQgPSB0aGlzLmdldE1lc3NhZ2VGb3JMYW5ndWFnZShpMThuLkRlZmF1bHRMYW5ndWFnZSwga2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0ICE9PSB1bmRlZmluZWQgPyByZXN1bHQgOiAnPz8/ICcgKyBrZXkgKyAnID8/Pyc7XG5cbn07XG5cbkJvYXJkLnByb3RvdHlwZS5nZXRNZXNzYWdlRm9yTGFuZ3VhZ2UgPSBmdW5jdGlvbiAobGFuZ3VhZ2UsIGtleSkge1xuXG4gICAgaWYgKHRoaXMuaTE4biAmJiB0aGlzLmkxOG4uaGFzT3duUHJvcGVydHkobGFuZ3VhZ2UpICYmIHRoaXMuaTE4bltsYW5ndWFnZV0uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pMThuW2xhbmd1YWdlXVtrZXldO1xuICAgIH1cblxufTtcblxuLyoqXG4gKiBJbmRpY2F0ZXMgdG8gdGhpcyBib2FyZCB0aGF0IHRoZSBwbGF5ZXIgaGFzIGJlZW4gaHVydC4gVGhpcyB3aWxsIGRpc3BsYXlcbiAqIGEgbWVzc2FnZSBvbiB0aGUgc2NyZWVuIGFuZCByZS1lbnRlciBpZiBhcHBsaWNhYmxlLlxuICovXG5Cb2FyZC5wcm90b3R5cGUucGxheWVySHVydCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHRoaXMuc2V0RGlzcGxheU1lc3NhZ2UoaTE4bi5nZXRNZXNzYWdlKCdzdGF0dXMuaHVydCcpKTtcblxuICAgIGlmICh0aGlzLnJlZW50ZXIpIHtcbiAgICAgICAgdGhpcy5tb3ZlVGlsZSh0aGlzLnBsYXllci5wb2ludCwgdGhpcy5lbnRyeVBvaW50KTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogUmVuZGVycyBhIHZpc3VhbCBtZXNzYWdlIHRvIGEgcHJvdmlkZWQgZ3JhcGhpY3MgY29udGV4dCByZXByZXNlbnRpbmcgdGhpcyBCb2FyZCdzIGN1cnJlbnRcbiAqIGRpc3BsYXkgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gYyBBIGdyYXBoaWNzIGNvbnRleHQuXG4gKi9cbkJvYXJkLnByb3RvdHlwZS5yZW5kZXJNZXNzYWdlID0gZnVuY3Rpb24gKGMpIHtcblxuICAgIHZhciBtZXNzYWdlUG9pbnQgPSBuZXcgUG9pbnQoKTtcblxuICAgIG1lc3NhZ2VQb2ludC54ID0gTWF0aC5mbG9vcigodGhpcy53aW5kb3dTaXplLnggLSB0aGlzLmRpc3BsYXlNZXNzYWdlLmxlbmd0aCkgLyAyKTtcbiAgICBtZXNzYWdlUG9pbnQueSA9IHRoaXMud2luZG93U2l6ZS55IC0gMTtcblxuICAgIHRoaXMuZ2FtZS5yZXNvdXJjZXMuZ3JhcGhpY3MuZHJhd1N0cmluZyhjLCBtZXNzYWdlUG9pbnQsIHRoaXMuZGlzcGxheU1lc3NhZ2UsIENvbG9ycy5DeWNsZSwgQ29sb3JzLkJsYWNrKTtcblxuICAgIHRoaXMuZGlzcGxheU1lc3NhZ2VUaWNrIC09IDE7XG5cbiAgICBpZiAodGhpcy5kaXNwbGF5TWVzc2FnZVRpY2sgPD0gMCkge1xuICAgICAgICB0aGlzLmRpc3BsYXlNZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgIH1cblxufTtcblxuZXhwb3J0cy5Cb2FyZCA9IEJvYXJkO1xuIiwiLyoqXG4gKiBKWlQgRWRpdG9yXG4gKiBDb3B5cmlnaHQgwqkgMjAxNCBPcmFuZ2VsaW5lIEludGVyYWN0aXZlLCBJbmMuXG4gKiBAYXV0aG9yIE1hcmsgTWNJbnR5cmVcbiAqL1xuXG4vKmpzbGludCBub2RlOiB0cnVlICovXG4vKmdsb2JhbCBMWlN0cmluZyAqL1xuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGRhcmtDb2xvcnMgPSBbJzAnLCAnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNyddLFxuICAgIGFsbENvbG9yc05vQmxhY2sgPSBbJzknLCAnQScsICdCJywgJ0MnLCAnRCcsICdFJywgJ0YnLCAnNycsICcxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc4J10sXG4gICAgcGxheWVyU3ByaXRlLFxuICAgIFBvaW50ID0gcmVxdWlyZSgnLi9iYXNpYycpLlBvaW50LFxuICAgIEdyYXBoaWNzID0gcmVxdWlyZSgnLi9ncmFwaGljcycpLkdyYXBoaWNzLFxuICAgIGkxOG4gPSByZXF1aXJlKCcuL2kxOG4nKS5pMThuLFxuICAgIENvbG9ycyA9IHJlcXVpcmUoJy4vZ3JhcGhpY3MnKS5Db2xvcnMsXG4gICAgdGhpbmdzID0gcmVxdWlyZSgnLi90aGluZ3MnKS50aGluZ3MsXG4gICAgRGlyZWN0aW9uID0gcmVxdWlyZSgnLi9iYXNpYycpLkRpcmVjdGlvbixcbiAgICBCb2FyZCA9IHJlcXVpcmUoJy4vYm9hcmQnKS5Cb2FyZCxcbiAgICBzZXJpYWxpemVDb2xvciA9IHJlcXVpcmUoJy4vZ3JhcGhpY3MnKS5zZXJpYWxpemUsXG4gICAgZGVzZXJpYWxpemVCYWNrZ3JvdW5kID0gcmVxdWlyZSgnLi9ncmFwaGljcycpLmRlc2VyaWFsaXplQmFja2dyb3VuZCxcbiAgICBkZXNlcmlhbGl6ZUZvcmVncm91bmQgPSByZXF1aXJlKCcuL2dyYXBoaWNzJykuZGVzZXJpYWxpemVGb3JlZ3JvdW5kLFxuICAgIGdldENvbG9yID0gcmVxdWlyZSgnLi9ncmFwaGljcycpLmdldENvbG9yLFxuICAgIFRoaW5nRmFjdG9yeSA9IHJlcXVpcmUoJy4vdGhpbmdzJykuVGhpbmdGYWN0b3J5O1xuXG4vKipcbiAqIEVkaXRvciByZXByZXNlbnRzIGEgSlpUIGdhbWUgZWRpdG9yLCBjYXBhYmxlIG9mIGNyZWF0aW5nIGFuZCB0ZXN0aW5nIEpaVCBnYW1lIHdvcmxkcyxcbiAqIGFuZCBwcm92aWRpbmcgZGVmaW5pdGlvbnMgYW5kIFVJIGVsZW1lbnRzIHRvIGRyaXZlIHRoZSBlZGl0b3IuXG4gKlxuICogQHBhcmFtIGVkaXRvckVsZW1lbnQge29iamVjdH0gLSBBIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgZWRpdG9yXG4gKiBAcGFyYW0gY29uZmlndXJhdGlvbiB7b2JqZWN0fSAtIENvbmZpZ3VyYXRpb24gdmFsdWVzLlxuICovXG5mdW5jdGlvbiBFZGl0b3IoZWRpdG9yRWxlbWVudCwgY29uZmlndXJhdGlvbikge1xuXG4gICAgdmFyIG1vY2tHYW1lLFxuICAgICAgICBtZSA9IHRoaXM7XG5cbiAgICB0aGlzLmZvcm1hdFZlcnNpb24gPSAnMS4wLjAnO1xuXG4gICAgdGhpcy5lZGl0b3JFbGVtZW50ID0gZWRpdG9yRWxlbWVudDtcbiAgICB0aGlzLnRlbXBsYXRlQ3VzdG9taXplciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZW1wbGF0ZS1jdXN0b21pemVyJyk7XG5cbiAgICB0aGlzLmFkZEJvYXJkQ2FsbGJhY2sgPSBjb25maWd1cmF0aW9uLmFkZEJvYXJkO1xuICAgIHRoaXMucmVtb3ZlQm9hcmRDYWxsYmFjayA9IGNvbmZpZ3VyYXRpb24ucmVtb3ZlQm9hcmQ7XG4gICAgdGhpcy5jaGFuZ2VCb2FyZENhbGxiYWNrID0gY29uZmlndXJhdGlvbi5jaGFuZ2VCb2FyZDtcbiAgICB0aGlzLmNoYW5nZVRlbXBsYXRlQ2FsbGJhY2sgPSBjb25maWd1cmF0aW9uLmNoYW5nZVRlbXBsYXRlO1xuICAgIHRoaXMuY2hhbmdlTW9kZUNhbGxiYWNrID0gY29uZmlndXJhdGlvbi5jaGFuZ2VNb2RlO1xuICAgIHRoaXMuY2hhbmdlQm9hcmRPcHRpb25zQ2FsbGJhY2sgPSBjb25maWd1cmF0aW9uLmNoYW5nZUJvYXJkT3B0aW9ucztcbiAgICB0aGlzLmNoYW5nZUdhbWVPcHRpb25zQ2FsbGJhY2sgPSBjb25maWd1cmF0aW9uLmNoYW5nZUdhbWVPcHRpb25zO1xuXG4gICAgdGhpcy5tb2RlID0gRWRpdG9yLk1vZGUuRFJBVztcblxuICAgIHRoaXMuYm9hcmRzID0gW107XG4gICAgdGhpcy5jdXJzb3IgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgdGhpcy5wbGF5ZXJQb3NpdGlvbiA9IG5ldyBQb2ludCgwLCAwKTtcblxuICAgIC8qIFdlIGRvbid0IG5lZWQgYSBcInJlYWxcIiBnYW1lIGluc3RhbmNlLCBzaW5jZSB3ZSdyZSBub3QgYWN0dWFsbHlcbiAgICAgKiBleGVjdXRpbmcgYSBwbGF5YWJsZSBpbnN0YW5jZSwgc28gd2UgbW9jayBvdXIgZ2FtZSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIG1vY2tHYW1lID0ge1xuICAgICAgICByZXNvdXJjZXM6IHt9LFxuICAgICAgICBpc0VkaXRvcjogdHJ1ZSxcbiAgICAgICAgdmVyc2lvbjogdGhpcy5mb3JtYXRWZXJzaW9uLFxuICAgICAgICBub3RpZnlMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSxcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgY2FudmFzOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5nYW1lID0gbW9ja0dhbWU7XG5cbiAgICAvLyBBc3NpZ24gYSBHcmFwaGljcyBpbnN0YW5jZSB0byBkcml2ZSB0aGUgcmVuZGVyaW5nIGVuZ2luZVxuICAgIG1vY2tHYW1lLnJlc291cmNlcy5ncmFwaGljcyA9IG5ldyBHcmFwaGljcyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIG1lLm5ld0dhbWUoKTtcbiAgICAgICAgcGxheWVyU3ByaXRlID0gbWUuZ3JhcGhpY3MuZ2V0U3ByaXRlKDIpO1xuICAgIH0pO1xuXG4gICAgLy8gTGV0J3Mga2VlcCBhIGxvY2FsIGNvcHkgZm9yIGNvbnZlbmllbmNlLCB0b28uXG4gICAgdGhpcy5ncmFwaGljcyA9IG1vY2tHYW1lLnJlc291cmNlcy5ncmFwaGljcztcblxuICAgIC8vIFRoZSBwbGF5ZXIgaXNuJ3QgcmVhbGx5IGFuIGl0ZW0gb24gdGhlIGJvYXJkIHdoZW4gZWRpdGluZywgYnV0IHJhdGhlciBqdXN0IGEgY29uY2VwdCBvZiBhIHBvc2l0aW9uLlxuICAgIHRoaXMucGxheWVyUG9zaXRpb24gPSBuZXcgUG9pbnQoMCwgMCk7XG5cbiAgICAvLyBGaW5hbGx5LCB3ZSBuZWVkIHRvIGxpc3RlbiBmb3Iga2V5Ym9hcmQgcHJlc3Nlc1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5vbktleURvd24uYmluZCh0aGlzKSwgZmFsc2UpO1xuXG59XG5cbi8qKlxuICogRWRpdG9yLk1vZGUgaXMgYW4gZW51bWVyYXRlZCB0eXBlIHJlcHJlc2VudGluZyBhIFwibW9kZVwiIGZvciBkcmF3aW5nIGFjdGlvbnMuXG4gKi9cbkVkaXRvci5Nb2RlID0ge1xuICAgIERSQVc6IDAsXG4gICAgU0VMRUNUOiAxLFxuICAgIEZJTEw6IDJcbn07XG5cbi8qKlxuICogVGhlIEVkaXRvciBrbm93cyBhYm91dCBzZXZlcmFsIFRoaW5ncyB1c2VkIGJ5IEpaVCwgYW5kIGRlZmluZXMgdGhlaXIgY29uZmlndXJhYmxlIHByb3BlcnRpZXMuXG4gKiBUaGlzIGVudW1lcmF0ZWQgdHlwZSBzdHJ1Y3R1cmUgZGVmaW5lcyB0aGVzZSBzbyB0aGF0IFVJIGVsZW1lbnRzIGNhbiBiZSBnZW5lcmF0ZWQgYW5kIHVzZWRcbiAqIHRvIGNvbmZpZ3VyZSB0aGVtLlxuICovXG5FZGl0b3IuVGhpbmcgPSB7XG5cbiAgICBCZWFyOiB7XG4gICAgICAgIHNlbnNpdGl2aXR5OiB7dHlwZTogJ251bWJlcicsIG1pbjogMSwgbWF4OiAxMCwgZGVmYXVsdFZhbHVlOiAxLCBsYWJlbDogJ1NlbnNpdGl2aXR5J31cbiAgICB9LFxuXG4gICAgQmxpbmtlcjoge1xuICAgICAgICBkaXJlY3Rpb246IHt0eXBlOiAnZGlyZWN0aW9uJywgZGVmYXVsdFZhbHVlOiAnTicsIGxhYmVsOiAnRGlyZWN0aW9uJ30sXG4gICAgICAgIHBlcmlvZDoge3R5cGU6ICdudW1iZXInLCBtaW46IDEsIG1heDogNTAsIGRlZmF1bHRWYWx1ZTogMywgbGFiZWw6ICdQZXJpb2QnfSxcbiAgICAgICAgZGVsYXk6IHt0eXBlOiAnbnVtYmVyJywgbWluOiAwLCBtYXg6IDUwLCBkZWZhdWx0VmFsdWU6IDAsIGxhYmVsOiAnRGVsYXknfSxcbiAgICAgICAgY29sb3I6IHt0eXBlOiAnY29sb3InLCBkZWZhdWx0VmFsdWU6ICcqRScsIG9wdGlvbnM6IGFsbENvbG9yc05vQmxhY2ssIGZvcmVncm91bmQ6IHRydWUsIGxhYmVsOiAnQ29sb3InfVxuICAgIH0sXG5cbiAgICBCb21iOiB7XG4gICAgICAgIHJhZGl1czoge3R5cGU6ICdudW1iZXInLCBkZWZhdWx0VmFsdWU6IDQsIG1pbjogMiwgbWF4OiAyMCwgbGFiZWw6ICdSYWRpdXMnLCBhZHZhbmNlZDogdHJ1ZX0sXG4gICAgICAgIGNvbG9yOiB7dHlwZTogJ2NvbG9yJywgZGVmYXVsdFZhbHVlOiAnKkUnLCBvcHRpb25zOiBhbGxDb2xvcnNOb0JsYWNrLCBmb3JlZ3JvdW5kOiB0cnVlLCBsYWJlbDogJ0NvbG9yJ31cbiAgICB9LFxuXG4gICAgQm91bGRlcjoge1xuICAgICAgICBjb2xvcjoge3R5cGU6ICdjb2xvcicsIGRlZmF1bHRWYWx1ZTogJypFJywgb3B0aW9uczogYWxsQ29sb3JzTm9CbGFjaywgZm9yZWdyb3VuZDogdHJ1ZSwgbGFiZWw6ICdDb2xvcid9XG4gICAgfSxcblxuICAgIEJyZWFrYWJsZVdhbGw6IHtcbiAgICAgICAgY29sb3I6IHt0eXBlOiAnY29sb3InLCBkZWZhdWx0VmFsdWU6ICcwQicsIG9wdGlvbnM6IGFsbENvbG9yc05vQmxhY2ssIGZvcmVncm91bmQ6IHRydWUsIGxhYmVsOiAnQ29sb3InfVxuICAgIH0sXG5cbiAgICBDZW50aXBlZGU6IHtcbiAgICAgICAgaGVhZDoge3R5cGU6ICdib29sZWFuJywgZGVmYXVsdFZhbHVlOiBmYWxzZSwgbGFiZWw6ICdIZWFkJ30sXG4gICAgICAgIGRldmlhbmNlOiB7dHlwZTogJ251bWJlcicsIG1pbjogMCwgbWF4OiAxMCwgZGVmYXVsdFZhbHVlOiAwLCBsYWJlbDogJ0RldmlhbmNlJ30sXG4gICAgICAgIGludGVsbGlnZW5jZToge3R5cGU6ICdudW1iZXInLCBtaW46IDAsIG1heDogMTAsIGRlZmF1bHRWYWx1ZTogMCwgbGFiZWw6ICdJbnRlbGxpZ2VuY2UnfSxcbiAgICAgICAgY29sb3I6IHt0eXBlOiAnY29sb3InLCBkZWZhdWx0VmFsdWU6ICcqOScsIG9wdGlvbnM6IGFsbENvbG9yc05vQmxhY2ssIGZvcmVncm91bmQ6IHRydWUsIGxhYmVsOiAnQ29sb3InfVxuICAgIH0sXG5cbiAgICBDb252ZXlvcjoge1xuICAgICAgICBjb2xvcjoge3R5cGU6ICdjb2xvcicsIGRlZmF1bHRWYWx1ZTogJypFJywgb3B0aW9uczogYWxsQ29sb3JzTm9CbGFjaywgZm9yZWdyb3VuZDogdHJ1ZSwgbGFiZWw6ICdDb2xvcid9LFxuICAgICAgICBjbG9ja3dpc2U6IHt0eXBlOiAnYm9vbGVhbicsIGRlZmF1bHRWYWx1ZTogdHJ1ZSwgbGFiZWw6ICdDbG9ja3dpc2UnfVxuICAgIH0sXG5cblxuXG4gICAgRG9vcjoge1xuICAgICAgICBjb2xvcjoge3R5cGU6ICdjb2xvcicsIGRlZmF1bHRWYWx1ZTogJzFGJywgb3B0aW9uczogWycxJywgJzInLCAnMycsICc0JywgJzUnLCAnNicsICc3J10sIGZvcmVncm91bmQ6IGZhbHNlLCBsYWJlbDogJ0NvbG9yJ31cbiAgICB9LFxuXG4gICAgRHVwbGljYXRvcjoge1xuICAgICAgICBjb3B5RGlyZWN0aW9uOiB7dHlwZTogJ2RpcmVjdGlvbicsIGRlZmF1bHRWYWx1ZTogJ0UnLCBsYWJlbDogJ0Nsb25lIERpcmVjdGlvbid9LFxuICAgICAgICBzcGVlZDoge3R5cGU6ICdudW1iZXInLCBtaW46IDEsIG1heDogMTAsIGRlZmF1bHRWYWx1ZTogNSwgbGFiZWw6ICdTcGVlZCd9XG4gICAgfSxcblxuICAgIEZha2VXYWxsOiB7XG4gICAgICAgIGNvbG9yOiB7dHlwZTogJ2NvbG9yJywgZGVmYXVsdFZhbHVlOiAnMEUnLCBvcHRpb25zOiBhbGxDb2xvcnNOb0JsYWNrLCBmb3JlZ3JvdW5kOiB0cnVlLCBsYWJlbDogJ0NvbG9yJ31cbiAgICB9LFxuXG4gICAgR2VtOiB7XG4gICAgICAgIGNvbG9yOiB7dHlwZTogJ2NvbG9yJywgZGVmYXVsdFZhbHVlOiAnMEQnLCBvcHRpb25zOiBhbGxDb2xvcnNOb0JsYWNrLCBmb3JlZ3JvdW5kOiB0cnVlLCBsYWJlbDogJ0NvbG9yJ31cbiAgICB9LFxuXG4gICAgSW52aXNpYmxlV2FsbDoge1xuICAgICAgICBjb2xvcjoge3R5cGU6ICdjb2xvcicsIGRlZmF1bHRWYWx1ZTogJzBBJywgb3B0aW9uczogYWxsQ29sb3JzTm9CbGFjaywgZm9yZWdyb3VuZDogdHJ1ZSwgbGFiZWw6ICdDb2xvcid9XG4gICAgfSxcblxuICAgIEtleToge1xuICAgICAgICBjb2xvcjoge3R5cGU6ICdjb2xvcicsIGRlZmF1bHRWYWx1ZTogJyo5Jywgb3B0aW9uczogWyc5JywgJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJ10sIGZvcmVncm91bmQ6IHRydWUsIGxhYmVsOiAnQ29sb3InfVxuICAgIH0sXG5cbiAgICBMaW5lV2FsbDoge1xuICAgICAgICBjb2xvcjoge3R5cGU6ICdjb2xvcicsIGRlZmF1bHRWYWx1ZTogJzA5Jywgb3B0aW9uczogYWxsQ29sb3JzTm9CbGFjaywgZm9yZWdyb3VuZDogdHJ1ZSwgbGFiZWw6ICdDb2xvcid9XG4gICAgfSxcblxuICAgIExpb246IHtcbiAgICAgICAgaW50ZWxsaWdlbmNlOiB7dHlwZTogJ251bWJlcicsIG1pbjogMSwgbWF4OiAxMCwgZGVmYXVsdFZhbHVlOiAzLCBsYWJlbDogJ0ludGVsbGlnZW5jZSd9XG4gICAgfSxcblxuICAgIFBhc3NhZ2U6IHtcbiAgICAgICAgY29sb3I6IHt0eXBlOiAnY29sb3InLCBkZWZhdWx0VmFsdWU6ICcxRicsIG9wdGlvbnM6IFsnMScsICcyJywgJzMnLCAnNCcsICc1JywgJzYnLCAnNyddLCBmb3JlZ3JvdW5kOiBmYWxzZSwgbGFiZWw6ICdDb2xvcid9LFxuICAgICAgICBwYXNzYWdlSWQ6IHt0eXBlOiAndGV4dCcsIGRlZmF1bHRWYWx1ZTogJ0Rvb3IgMScsIGxhYmVsOiAnSUQnfSxcbiAgICAgICAgdGFyZ2V0Qm9hcmQ6IHt0eXBlOiAnYm9hcmQnLCBsYWJlbDogJ1RhcmdldCBCb2FyZCd9XG4gICAgfSxcblxuICAgIFB1c2hlcjoge1xuICAgICAgICBzcGVlZDoge3R5cGU6ICdudW1iZXInLCBkZWZhdWx0VmFsdWU6IDMsIG1pbjogJzEnLCBtYXg6ICcxMCcsIGxhYmVsOiAnU3BlZWQnLCBhZHZhbmNlZDogdHJ1ZX0sXG4gICAgICAgIG9yaWVudGF0aW9uOiB7dHlwZTogJ2RpcmVjdGlvbicsIGRlZmF1bHRWYWx1ZTogJ1MnLCBsYWJlbDogJ0RpcmVjdGlvbid9LFxuICAgICAgICBjb2xvcjoge3R5cGU6ICdjb2xvcicsIGRlZmF1bHRWYWx1ZTogJypFJywgb3B0aW9uczogYWxsQ29sb3JzTm9CbGFjaywgZm9yZWdyb3VuZDogdHJ1ZSwgbGFiZWw6ICdDb2xvcid9XG4gICAgfSxcblxuICAgIFJpdmVyOiB7XG4gICAgICAgIGRpcmVjdGlvbjoge3R5cGU6ICdkaXJlY3Rpb24nLCBkZWZhdWx0VmFsdWU6ICdOJywgbGFiZWw6ICdEaXJlY3Rpb24nfVxuICAgIH0sXG5cbiAgICBSdWZmaWFuOiB7XG4gICAgICAgIGludGVsbGlnZW5jZToge3R5cGU6ICdudW1iZXInLCBkZWZhdWx0VmFsdWU6IDUsIG1pbjogJzEnLCBtYXg6ICcxMCcsIGxhYmVsOiAnSW50ZWxsaWdlbmNlJ30sXG4gICAgICAgIHJlc3RpbmdUaW1lOiB7dHlwZTogJ251bWJlcicsIGRlZmF1bHRWYWx1ZTogNSwgbWluOiAnMScsIG1heDogJzIwJywgbGFiZWw6ICdSZXN0aW5nIHRpbWUnfVxuICAgIH0sXG5cbiAgICBTY3JpcHRhYmxlOiB7XG4gICAgICAgIHNwcml0ZUluZGV4OiB7dHlwZTogJ3Nwcml0ZScsIGRlZmF1bHRWYWx1ZTogMSwgbGFiZWw6ICdDaGFyYWN0ZXInfSxcbiAgICAgICAgY29sb3I6IHt0eXBlOiAnY29sb3InLCBkZWZhdWx0VmFsdWU6ICcqRScsIG9wdGlvbnM6IGFsbENvbG9yc05vQmxhY2ssIGZvcmVncm91bmQ6IHRydWUsIGxhYmVsOiAnQ29sb3InfSxcbiAgICAgICAgbmFtZToge3R5cGU6ICd0ZXh0JywgZGVmYXVsdFZhbHVlOiAnVW5rbm93bicsIGxhYmVsOiAnTmFtZSd9LFxuICAgICAgICBzY3JpcHQ6IHt0eXBlOiAnc2NyaXB0JywgbGFiZWw6ICdTY3JpcHQnfSxcbiAgICAgICAgc3BlZWQ6IHt0eXBlOiAnbnVtYmVyJywgbWluOiAxLCBtYXg6IDEwLCBkZWZhdWx0VmFsdWU6IDMsIGxhYmVsOiAnU3BlZWQnfVxuICAgIH0sXG5cbiAgICBTaWducG9zdDoge1xuICAgICAgICB0ZXh0OiB7dHlwZTogJ3RleHQnLCBsYWJlbDogJ1NpZ25wb3N0IFRleHQnfVxuICAgIH0sXG5cbiAgICBTbGlkZXJFdzoge1xuICAgICAgICBjb2xvcjoge3R5cGU6ICdjb2xvcicsIGRlZmF1bHRWYWx1ZTogJypGJywgb3B0aW9uczogYWxsQ29sb3JzTm9CbGFjaywgZm9yZWdyb3VuZDogdHJ1ZSwgbGFiZWw6ICdDb2xvcid9XG4gICAgfSxcblxuICAgIFNsaWRlck5zOiB7XG4gICAgICAgIGNvbG9yOiB7dHlwZTogJ2NvbG9yJywgZGVmYXVsdFZhbHVlOiAnKkYnLCBvcHRpb25zOiBhbGxDb2xvcnNOb0JsYWNrLCBmb3JlZ3JvdW5kOiB0cnVlLCBsYWJlbDogJ0NvbG9yJ31cbiAgICB9LFxuXG4gICAgU25ha2U6IHtcbiAgICAgICAgc3BlZWQ6IHt0eXBlOiAnbnVtYmVyJywgZGVmYXVsdFZhbHVlOiAzLCBtaW46IDEsIG1heDogMTAsIGxhYmVsOiAnU3BlZWQnfVxuICAgIH0sXG5cbiAgICBTb2xpZFdhbGw6IHtcbiAgICAgICAgY29sb3I6IHt0eXBlOiAnY29sb3InLCBkZWZhdWx0VmFsdWU6ICcwRScsIG9wdGlvbnM6IGFsbENvbG9yc05vQmxhY2ssIGZvcmVncm91bmQ6IHRydWUsIGxhYmVsOiAnQ29sb3InfVxuICAgIH0sXG5cbiAgICBTcGlkZXI6IHtcbiAgICAgICAgaW50ZWxsaWdlbmNlOiB7dHlwZTogJ251bWJlcicsIGRlZmF1bHRWYWx1ZTogNSwgbWluOiAxLCBtYXg6IDUsIGxhYmVsOiAnSW50ZWxsaWdlbmNlJ30sXG4gICAgICAgIGNvbG9yOiB7dHlwZTogJ2NvbG9yJywgZGVmYXVsdFZhbHVlOiAnKkMnLCBvcHRpb25zOiBhbGxDb2xvcnNOb0JsYWNrLCBmb3JlZ3JvdW5kOiB0cnVlLCBsYWJlbDogJ0NvbG9yJ31cbiAgICB9LFxuXG4gICAgU3Bpbm5pbmdHdW46IHtcbiAgICAgICAgaW50ZWxsaWdlbmNlOiB7dHlwZTogJ251bWJlcicsIGRlZmF1bHRWYWx1ZTogNSwgbWluOiAxLCBtYXg6IDUsIGxhYmVsOiAnSW50ZWxsaWdlbmNlJ30sXG4gICAgICAgIGZpcmluZ1JhdGU6IHt0eXBlOiAnbnVtYmVyJywgZGVmYXVsdFZhbHVlOiA1LCBtaW46IDEsIG1heDogMTAsIGxhYmVsOiAnRmlyaW5nIHJhdGUnfSxcbiAgICAgICAgY29sb3I6IHt0eXBlOiAnY29sb3InLCBkZWZhdWx0VmFsdWU6ICcqRScsIG9wdGlvbnM6IGFsbENvbG9yc05vQmxhY2ssIGZvcmVncm91bmQ6IHRydWUsIGxhYmVsOiAnQ29sb3InfVxuICAgIH0sXG5cbiAgICBUZWxlcG9ydGVyOiB7XG4gICAgICAgIG9yaWVudGF0aW9uOiB7dHlwZTogJ2RpcmVjdGlvbicsIGRlZmF1bHRWYWx1ZTogJ0UnLCBsYWJlbDogJ0RpcmVjdGlvbid9LFxuICAgICAgICBjb2xvcjoge3R5cGU6ICdjb2xvcicsIGRlZmF1bHRWYWx1ZTogJypFJywgb3B0aW9uczogYWxsQ29sb3JzTm9CbGFjaywgZm9yZWdyb3VuZDogdHJ1ZSwgbGFiZWw6ICdDb2xvcid9XG4gICAgfSxcblxuICAgIFRleHQ6IHtcbiAgICAgICAgY29sb3I6IHt0eXBlOiAnY29sb3InLCBkZWZhdWx0VmFsdWU6ICcwRicsIG9wdGlvbnM6IGRhcmtDb2xvcnMsIGZvcmVncm91bmQ6IGZhbHNlLCBsYWJlbDogJ0NvbG9yJ30sXG4gICAgICAgIHRleHQ6IHt0eXBlOiAndGV4dCcsIGRlZmF1bHRWYWx1ZTogJycsIGxhYmVsOiAnVGV4dCd9XG4gICAgfSxcblxuICAgIFRpZ2VyOiB7XG4gICAgICAgIGludGVsbGlnZW5jZToge3R5cGU6ICdudW1iZXInLCBtaW46IDEsIG1heDogMTAsIGRlZmF1bHRWYWx1ZTogMywgbGFiZWw6ICdJbnRlbGxpZ2VuY2UnfSxcbiAgICAgICAgZmlyaW5nUmF0ZToge3R5cGU6ICdudW1iZXInLCBtaW46IDEsIG1heDogMjAsIGRlZmF1bHRWYWx1ZTogNSwgbGFiZWw6ICdGaXJpbmcgcmF0ZSd9XG4gICAgfSxcblxuICAgIFdhbGw6IHtcbiAgICAgICAgY29sb3I6IHt0eXBlOiAnY29sb3InLCBkZWZhdWx0VmFsdWU6ICcwRScsIG9wdGlvbnM6IGFsbENvbG9yc05vQmxhY2ssIGZvcmVncm91bmQ6IHRydWUsIGxhYmVsOiAnQ29sb3InfVxuICAgIH1cblxufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGlzIEVkaXRvcidzIHByaW1hcnkgQm9hcmQgRE9NIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIGJvYXJkIHtvYmplY3R9IC0gQSBET00gZWxlbWVudCB0byBiZSBpbml0aWFsaXplZC5cbiAqL1xuRWRpdG9yLnByb3RvdHlwZS5pbml0aWFsaXplQm9hcmRFbGVtZW50ID0gZnVuY3Rpb24gKGJvYXJkKSB7XG5cbiAgICAvLyBSZW1vdmUgdGhlIG9sZCBjYW52YXNcbiAgICBpZiAodGhpcy5jYW52YXNFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuZWRpdG9yRWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLmNhbnZhc0VsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIG5ldyBjYW52YXNcbiAgICB0aGlzLmNhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0aGlzLmNhbnZhc0VsZW1lbnQud2lkdGggPSA4MDA7XG4gICAgdGhpcy5jYW52YXNFbGVtZW50LmhlaWdodCA9IDY0MDtcblxuICAgIC8vIEFkZCBvdXIgY2FudmFzXG4gICAgdGhpcy5lZGl0b3JFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuY2FudmFzRWxlbWVudCk7XG5cbiAgICAvLyBBZGQgb3VyIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMuY2FudmFzRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uQ2FudmFzTW91c2VNb3ZlZC5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgdGhpcy5jYW52YXNFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25DYW52YXNNb3VzZURvd24uYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgIHRoaXMuY2FudmFzRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbkNhbnZhc01vdXNlVXAuYmluZCh0aGlzKSwgZmFsc2UpO1xuICAgIHRoaXMuY2FudmFzRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5vbkNhbnZhc1Njcm9sbC5iaW5kKHRoaXMpLCBmYWxzZSk7XG5cbiAgICAvLyBBc3NpZ24gb3VyIGNvbnRleHRcbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmdhbWUuY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLmNvbnRleHQuaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5jb250ZXh0LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY29udGV4dC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcblxuICAgIC8vIEFzc2lnbiBvdXIgZm9jdXNcbiAgICB0aGlzLmZvY3VzUG9pbnQgPSBuZXcgUG9pbnQoYm9hcmQuZGVmYXVsdFBsYXllclgsIGJvYXJkLmRlZmF1bHRQbGF5ZXJZKTtcbiAgICB0aGlzLmN1cnNvciA9IHRoaXMuZm9jdXNQb2ludDtcblxufTtcblxuLyoqXG4gKiBTZXRzIHRoaXMgRWRpdG9yJ3MgY3Vyc29yIHBvc2l0aW9uIHRvIGEgcHJvdmlkZWQgcG9pbnQsIGVuc3VyaW5nIHRoYXQgdGhlXG4gKiBwb3NpdGlvbiBpcyB3aXRoaW4gdGhlIHJlc3RyaWN0ZWQgcmFuZ2UsIGFuZCB0aGF0IFwiZHJhd2luZyBtb2RlXCIgYmVpbmcgZW5hYmxlZFxuICogd2lsbCBjb250aW5lIHRvIHBsb3QgdGlsZXMuXG4gKi9cbkVkaXRvci5wcm90b3R5cGUuc2V0Q3Vyc29yUG9zaXRpb24gPSBmdW5jdGlvbiAocG9pbnQpIHtcblxuICAgIHRoaXMuY3Vyc29yID0gcG9pbnQ7XG5cbiAgICBpZiAodGhpcy5jdXJzb3IueCA8IDApIHtcbiAgICAgICAgdGhpcy5jdXJzb3IueCA9IDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmN1cnNvci55IDwgMCkge1xuICAgICAgICB0aGlzLmN1cnNvci55ID0gMDtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3Vyc29yLnggPj0gdGhpcy5jdXJyZW50Qm9hcmQud2lkdGgpIHtcbiAgICAgICAgdGhpcy5jdXJzb3IueCA9IHRoaXMuY3VycmVudEJvYXJkLndpZHRoIC0gMTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY3Vyc29yLnkgPj0gdGhpcy5jdXJyZW50Qm9hcmQuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY3Vyc29yLnkgPSB0aGlzLmN1cnJlbnRCb2FyZC5oZWlnaHQgLSAxO1xuICAgIH1cblxuICAgIC8vIElmIGRyYXdpbmcgbW9kZSBpcyBlbmFibGVkLCBwbG90IGEgdGlsZSBpbW1lZGlhdGVseS5cbiAgICBpZiAodGhpcy5kcmF3aW5nKSB7XG4gICAgICAgIHRoaXMucGxvdCgpO1xuICAgIH1cblxuICAgIHRoaXMucmVuZGVyKHRoaXMuY29udGV4dCk7XG5cbn07XG5cbi8qKlxuICogVG9nZ2xlcyB0aGUgZXhpc3RlbmNlIG9mIGEgVGhpbmcgYXQgdGhlIGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uLlxuICovXG5FZGl0b3IucHJvdG90eXBlLnRvZ2dsZVBsb3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdGhpbmcgPSB0aGlzLmN1cnJlbnRCb2FyZC5nZXRUaWxlKHRoaXMuY3Vyc29yKTtcblxuICAgIGlmICh0aGluZykge1xuICAgICAgICB0aGlzLmN1cnJlbnRCb2FyZC5hZGRUaGluZyh0aGlzLmN1cnNvciwgdW5kZWZpbmVkKTtcbiAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5jb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBsb3QoKTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogUGxvdHMgYSBUaGluZywgYmFzZWQgb24gdGhpcyBFZGl0b3IncyBhY3RpdmUgdGVtcGxhdGUsIGF0IHRoaXMgRWRpdG9yJ3NcbiAqIGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uLlxuICovXG5FZGl0b3IucHJvdG90eXBlLnBsb3QgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdGhpbmcsXG4gICAgICAgIGluZGV4LFxuICAgICAgICBjO1xuXG4gICAgLy8gTm8gbmVlZCB0byBwbG90IHRoZSBzYW1lIHRpbGUgdHdpY2VcbiAgICBpZiAoIXRoaXMucHJldmlvdXNQbG90IHx8ICF0aGlzLnByZXZpb3VzUGxvdC5lcXVhbHModGhpcy5jdXJzb3IpKSB7XG5cbiAgICAgICAgdGhpcy5wcmV2aW91c1Bsb3QgPSB0aGlzLmN1cnNvcjtcblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHRlbXBsYXRlIGF2YWlsYWJsZS4uLlxuICAgICAgICBpZiAodGhpcy5hY3RpdmVUZW1wbGF0ZSkge1xuXG4gICAgICAgICAgICAvLyBXaGljaCB0ZW1wbGF0ZSBoYXZlIHdlIGdvdD9cblxuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVGVtcGxhdGUudHlwZSA9PT0gJ1BsYXllcicpIHtcblxuICAgICAgICAgICAgICAgIC8vIEl0J3MgYSBwbGF5ZXJcblxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEJvYXJkLmRlZmF1bHRQbGF5ZXJYID0gdGhpcy5jdXJzb3IueDtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRCb2FyZC5kZWZhdWx0UGxheWVyWSA9IHRoaXMuY3Vyc29yLnk7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5ZXJQb3NpdGlvbi54ID0gdGhpcy5jdXJyZW50Qm9hcmQuZGVmYXVsdFBsYXllclg7XG4gICAgICAgICAgICAgICAgdGhpcy5wbGF5ZXJQb3NpdGlvbi55ID0gdGhpcy5jdXJyZW50Qm9hcmQuZGVmYXVsdFBsYXllclk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5hY3RpdmVUZW1wbGF0ZS50eXBlID09PSAnVGV4dCcpIHtcblxuICAgICAgICAgICAgICAgIC8vIEl0J3MgVGV4dFxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlVGVtcGxhdGUudGV4dCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE91dHB1dCBhIHRleHQgY2hhcmFjdGVyIGZvciBlYWNoIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYWN0aXZlVGVtcGxhdGUudGV4dC5sZW5ndGg7IGluZGV4ICs9IDEpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMuYWN0aXZlVGVtcGxhdGUudGV4dC5jaGFyQXQoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMuZ3JhcGhpY3MuY29udmVydFNwZWNpYWxDaGFyYWN0ZXIoYyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaW5nID0gdGhpcy5jdXJyZW50Qm9hcmQuZ2V0VGlsZSh0aGlzLmN1cnNvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIElmIHRoZXJlJ3MgYWxyZWFkeSBhIFRleHQgdGhpbmcgaW4gb3VyIHBvc2l0aW9uLCBzZXQgaXQncyBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGRlcGVuZGluZyBvbiB0aGUgYWN0aXZlIGxhbmd1YWdlLCBhbmQgY2hhbmdlIGl0cyBjb2xvciBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBPdGhlcndpc2UsIHdlIGNhbiBnbyBhaGVhZCBhbmQgYWRkIGEgYnJhbmQgbmV3IFRleHQgVGhpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGluZyAmJiB0aGluZy50eXBlID09PSAnVGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGluZy5pMThuW2kxOG4uZ2V0TGFuZ3VhZ2UoKV0gPSBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaW5nLmZvcmVncm91bmQgPSBkZXNlcmlhbGl6ZUZvcmVncm91bmQodGhpcy5hY3RpdmVUZW1wbGF0ZS5jb2xvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpbmcuYmFja2dyb3VuZCA9IGRlc2VyaWFsaXplQmFja2dyb3VuZCh0aGlzLmFjdGl2ZVRlbXBsYXRlLmNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpbmcgPSB7dHlwZTogJ1RleHQnLCBpMThuOiB7fSwgY29sb3I6IHRoaXMuYWN0aXZlVGVtcGxhdGUuY29sb3J9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaW5nLmkxOG5baTE4bi5nZXRMYW5ndWFnZSgpXSA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Qm9hcmQuYWRkVGhpbmcodGhpcy5jdXJzb3IsIHRoaW5ncy5UaGluZ0ZhY3RvcnkuZGVzZXJpYWxpemUodGhpbmcsIHRoaXMuY3VycmVudEJvYXJkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMuY3Vyc29yLmFkZChEaXJlY3Rpb24uRWFzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gdGhpcy5wcmV2aW91c1Bsb3Q7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIHNvbWV0aGluZyBlbHNlXG5cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRCb2FyZC5hZGRUaGluZyh0aGlzLmN1cnNvciwgVGhpbmdGYWN0b3J5LmRlc2VyaWFsaXplKHRoaXMuYWN0aXZlVGVtcGxhdGUsIHRoaXMuY3VycmVudEJvYXJkKSk7XG5cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIE5vIGFjdGl2ZSB0ZW1wbGF0ZSwgbWVhbnMgd2Ugc2hvdWxkIHBsb3QgYW4gZW1wdHkgc3BhY2VcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJvYXJkLmFkZFRoaW5nKHRoaXMuY3Vyc29yLCB1bmRlZmluZWQpO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyKHRoaXMuY29udGV4dCk7XG5cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBnYW1lIHdvcmxkLlxuICovXG5FZGl0b3IucHJvdG90eXBlLm5ld0dhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZXNlcmlhbGl6ZSh7XG4gICAgICAgIG5hbWU6ICdVbnRpdGxlZCBXb3JsZCcsXG4gICAgICAgIHZlcnNpb246IHRoaXMuZ2FtZS52ZXJzaW9uLFxuICAgICAgICBhdXRob3I6ICdBbm9ueW1vdXMnLFxuICAgICAgICB0aXRsZUJvYXJkOiAnVW50aXRsZWQgQm9hcmQnLFxuICAgICAgICBzdGFydGluZ0JvYXJkOiAnVW50aXRsZWQgQm9hcmQnLFxuICAgICAgICBib2FyZHM6IFt0aGlzLmNyZWF0ZUJvYXJkKCdVbnRpdGxlZCBCb2FyZCcsIDUwLCAyMCldXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIE1vdmVzIHRoaXMgRWRpdG9yJ3MgY3Vyc29yIGluIGEgZ2l2ZW4gZGlyZWN0aW9uLlxuICovXG5FZGl0b3IucHJvdG90eXBlLm1vdmVDdXJzb3IgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG5cbiAgICB2YXIgc3RhcnRYLFxuICAgICAgICBlbmRYO1xuXG4gICAgdGhpcy5zZXRDdXJzb3JQb3NpdGlvbih0aGlzLmN1cnNvci5hZGQoZGlyZWN0aW9uKSk7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50Qm9hcmQuaXNPdXRzaWRlV2luZG93KHRoaXMuY3Vyc29yKSkge1xuXG4gICAgICAgIHN0YXJ0WCA9IHRoaXMuY3VycmVudEJvYXJkLndpbmRvd09yaWdpbi54O1xuICAgICAgICBlbmRYID0gc3RhcnRYICsgdGhpcy5jdXJyZW50Qm9hcmQud2luZG93U2l6ZS54O1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnNvci54IDwgc3RhcnRYIHx8IHRoaXMuY3Vyc29yLnggPj0gZW5kWCkge1xuICAgICAgICAgICAgdGhpcy5mb2N1c1BvaW50LnggPSB0aGlzLmN1cnNvci54O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mb2N1c1BvaW50LnkgPSB0aGlzLmN1cnNvci55O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5jb250ZXh0KTtcblxuICAgIH1cblxufTtcblxuLyoqXG4gKiBTZXRzIHRoaXMgRWRpdG9yJ3MgY3VycmVudGx5IGFjdGl2ZSBib2FyZCB0byBhIHByb3ZpZGVkIHNldCBvZiBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9IC0gQSBzZXQgb2Ygb3B0aW9ucyB0byBhcHBseSB0byB0aGUgY3VycmVudCBib2FyZC5cbiAqL1xuRWRpdG9yLnByb3RvdHlwZS5zZXRCb2FyZE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMuY3VycmVudEJvYXJkLmRhcmsgPSBvcHRpb25zLmRhcms7XG4gICAgdGhpcy5jdXJyZW50Qm9hcmQubm9ydGggPSBvcHRpb25zLm5vcnRoICE9PSAnJyA/IG9wdGlvbnMubm9ydGggOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdXJyZW50Qm9hcmQuc291dGggPSBvcHRpb25zLnNvdXRoICE9PSAnJyA/IG9wdGlvbnMuc291dGggOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdXJyZW50Qm9hcmQuZWFzdCA9IG9wdGlvbnMuZWFzdCAhPT0gJycgPyBvcHRpb25zLmVhc3QgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdXJyZW50Qm9hcmQud2VzdCA9IG9wdGlvbnMud2VzdCAhPT0gJycgPyBvcHRpb25zLndlc3QgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdXJyZW50Qm9hcmQubm9ydGhPZmZzZXQgPSBvcHRpb25zLm5vcnRoT2Zmc2V0ICE9PSAnJyA/IG9wdGlvbnMubm9ydGhPZmZzZXQgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdXJyZW50Qm9hcmQuc291dGhPZmZzZXQgPSBvcHRpb25zLnNvdXRoT2Zmc2V0ICE9PSAnJyA/IG9wdGlvbnMuc291dGhPZmZzZXQgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdXJyZW50Qm9hcmQuZWFzdE9mZnNldCA9IG9wdGlvbnMuZWFzdE9mZnNldCAhPT0gJycgPyBvcHRpb25zLmVhc3RPZmZzZXQgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdXJyZW50Qm9hcmQud2VzdE9mZnNldCA9IG9wdGlvbnMud2VzdE9mZnNldCAhPT0gJycgPyBvcHRpb25zLndlc3RPZmZzZXQgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdXJyZW50Qm9hcmQucmVlbnRlciA9IG9wdGlvbnMucmVlbnRlcjtcbiAgICB0aGlzLmN1cnJlbnRCb2FyZC5tYXhQbGF5ZXJCdWxsZXRzID0gb3B0aW9ucy5tYXhQbGF5ZXJCdWxsZXRzIDwgMCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMubWF4UGxheWVyQnVsbGV0cztcbiAgICB0aGlzLmNoYW5nZUJvYXJkT3B0aW9uc0NhbGxiYWNrKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoaXMgRWRpdG9yJ3MgY3VycmVudCBnYW1lIHdvcmxkJ3Mgb3B0aW9ucyB0byBhIHByb3ZpZGVkIHNldC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7b2JqZWN0fSAtIEEgc2V0IG9mIG9wdGlvbnMgdG8gYXBwbHkgdG8gdGhpcyBFZGl0b3IncyBjdXJyZW50IGdhbWUgd29ybGQuXG4gKi9cbkVkaXRvci5wcm90b3R5cGUuc2V0R2FtZU9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMuZ2FtZS5uYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgIHRoaXMuZ2FtZS5pZCA9IG9wdGlvbnMuaWQ7XG4gICAgdGhpcy5nYW1lLmF1dGhvciA9IG9wdGlvbnMuYXV0aG9yO1xuICAgIHRoaXMuZ2FtZS50aXRsZUJvYXJkID0gb3B0aW9ucy50aXRsZUJvYXJkO1xuICAgIHRoaXMuZ2FtZS5zdGFydGluZ0JvYXJkID0gb3B0aW9ucy5zdGFydGluZ0JvYXJkO1xuICAgIHRoaXMuZ2FtZS52aWN0b3J5Qm9hcmQgPSBvcHRpb25zLnZpY3RvcnlCb2FyZDtcbiAgICB0aGlzLmNoYW5nZUdhbWVPcHRpb25zQ2FsbGJhY2sob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBib2FyZCBuYW1lIGdpdmVuIGEgY2FuZGlkYXRlIG5hbWUuIFRoaXMgZW5zdXJlcyB0aGF0IG5vXG4gKiB0d28gYm9hcmRzIGhhdmUgdGhlIHNhbWUgbmFtZSB3aGVuIHJ1biB0aHJvdWdoIHRoaXMgZ2VuZXJhdG9yLlxuICpcbiAqIEBwYXJhbSBjYW5kaWRhdGUge3N0cmluZ30gLSBBIG5hbWUgdG8gdHVybiB1bmlxdWUsIGlmIGl0J3Mgbm90IGFscmVhZHlcbiAqIEByZXR1cm4ge3N0cmluZ30gLSBBIHVuaXF1ZSBib2FyZCBuYW1lIGJhc2VkIG9uIGEgZ2l2ZW4gY2FuZGlkYXRlXG4gKi9cbkVkaXRvci5wcm90b3R5cGUuZ2V0VW5pcXVlQm9hcmROYW1lID0gZnVuY3Rpb24gKGNhbmRpZGF0ZSkge1xuXG4gICAgdmFyIGluZGV4ID0gMixcbiAgICAgICAgY3VycmVudFRyeSA9IGNhbmRpZGF0ZTtcblxuICAgIHdoaWxlICh0aGlzLmdldEJvYXJkKGN1cnJlbnRUcnkpKSB7XG4gICAgICAgIGN1cnJlbnRUcnkgPSBjYW5kaWRhdGUgKyBpbmRleDtcbiAgICAgICAgaW5kZXggKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudFRyeTtcblxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB1bmlxdWUgc2NyaXB0IG5hbWUgZ2l2ZW4gYSBjYW5kaWRhdGUgbmFtZS4gVGhpcyBlbnN1cmVzIHRoYXQgbm8gdHdvIHNjcmlwdHNcbiAqIG9uIHRoaXMgRWRpdG9yJ3MgY3VycmVudCBib2FyZCBoYXZlIHRoZSBzYW1lIG5hbWUgd2hlbiBydW4gdGhyb3VnaCB0aGlzIGdlbmVyYXRvci5cbiAqXG4gKiBAcGFyYW0gY2FuZGlkYXRlIHtzdHJpbmd9IC0gQSBuYW1lIHRvIHR1cm4gdW5pcXVlLCBpZiBpdCdzIG5vdCBhbHJlYWR5XG4gKiBAcmV0dXJuIHtzdHJpbmd9IC0gQSB1bmlxdWUgc2NyaXB0IG5hbWUgYmFzZWQgb24gYSBnaXZlbiBjYW5kaWRhdGUsIGZvciB0aGlzIEVkaXRvcidzIGN1cnJlbnQgYm9hcmQuXG4gKi9cbkVkaXRvci5wcm90b3R5cGUuZ2V0VW5pcXVlU2NyaXB0TmFtZSA9IGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcblxuICAgIHZhciBpbmRleCA9IDIsXG4gICAgICAgIGN1cnJlbnRUcnkgPSBjYW5kaWRhdGU7XG5cbiAgICB3aGlsZSAodGhpcy5jdXJyZW50Qm9hcmQuZ2V0U2NyaXB0KGN1cnJlbnRUcnkpKSB7XG4gICAgICAgIGN1cnJlbnRUcnkgPSBjYW5kaWRhdGUgKyBpbmRleDtcbiAgICAgICAgaW5kZXggKz0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudFRyeTtcblxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBib2FyZCBmcm9tIHRoaXMgRWRpdG9yJ3MgY3VycmVudCBnYW1lIHdvcmxkLlxuICpcbiAqIEBwYXJhbSBib2FyZE5hbWUge3N0cmluZ30gLSBBIG5hbWUgb2YgYSBib2FyZCB0byByZXRyaWV2ZVxuICogQHJldHVybiB7b2JqZWN0fSAtIEEgZ2FtZSBib2FyZCB3aXRoIGEgcHJvdmlkZWQgbmFtZS5cbiAqL1xuRWRpdG9yLnByb3RvdHlwZS5nZXRCb2FyZCA9IGZ1bmN0aW9uIChib2FyZE5hbWUpIHtcbiAgICB2YXIgaW5kZXg7XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmJvYXJkcy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMuYm9hcmRzW2luZGV4XS5uYW1lID09PSBib2FyZE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvYXJkc1tpbmRleF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBTd2l0Y2hlcyB0aGlzIEVkaXRvcidzIGN1cnJlbnQgYm9hcmQgdG8gYSBib2FyZCB3aXRoIGEgcHJvdmlkZWQgbmFtZS5cbiAqXG4gKiBAcGFyYW0gYm9hcmROYW1lIHtzdHJpbmd9IC0gQSBuYW1lIG9mIGEgYm9hcmQgdG8gc3dpdGNoIHRvXG4gKi9cbkVkaXRvci5wcm90b3R5cGUuc3dpdGNoQm9hcmQgPSBmdW5jdGlvbiAoYm9hcmROYW1lKSB7XG5cbiAgICB2YXIgYm9hcmQgPSB0aGlzLmdldEJvYXJkKGJvYXJkTmFtZSksXG4gICAgICAgIGJvYXJkT3B0aW9ucztcblxuICAgIHRoaXMuY3VycmVudEJvYXJkID0gYm9hcmQ7XG5cbiAgICB0aGlzLnBsYXllclBvc2l0aW9uLnggPSBib2FyZC5kZWZhdWx0UGxheWVyWDtcbiAgICB0aGlzLnBsYXllclBvc2l0aW9uLnkgPSBib2FyZC5kZWZhdWx0UGxheWVyWTtcblxuICAgIHRoaXMuaW5pdGlhbGl6ZUJvYXJkRWxlbWVudChib2FyZCk7XG5cbiAgICB0aGlzLmN1cnJlbnRCb2FyZC5pbml0aWFsaXplV2luZG93KCk7XG4gICAgdGhpcy5yZW5kZXIodGhpcy5jb250ZXh0KTtcblxuICAgIHRoaXMuY2hhbmdlQm9hcmRDYWxsYmFjayhib2FyZE5hbWUpO1xuICAgIGJvYXJkT3B0aW9ucyA9IHtcbiAgICAgICAgbm9ydGg6IGJvYXJkLm5vcnRoLFxuICAgICAgICBlYXN0OiBib2FyZC5lYXN0LFxuICAgICAgICBzb3V0aDogYm9hcmQuc291dGgsXG4gICAgICAgIHdlc3Q6IGJvYXJkLndlc3QsXG4gICAgICAgIG5vcnRoT2Zmc2V0OiBib2FyZC5ub3J0aE9mZnNldCxcbiAgICAgICAgZWFzdE9mZnNldDogYm9hcmQuZWFzdE9mZnNldCxcbiAgICAgICAgc291dGhPZmZzZXQ6IGJvYXJkLnNvdXRoT2Zmc2V0LFxuICAgICAgICB3ZXN0T2Zmc2V0OiBib2FyZC53ZXN0T2Zmc2V0LFxuICAgICAgICBkYXJrOiBib2FyZC5kYXJrLFxuICAgICAgICByZWVudGVyOiBib2FyZC5yZWVudGVyXG4gICAgfTtcbiAgICB0aGlzLmNoYW5nZUJvYXJkT3B0aW9uc0NhbGxiYWNrKGJvYXJkT3B0aW9ucyk7XG5cbn07XG5cbkVkaXRvci5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgdmFyIGluZGV4LFxuICAgICAgICBib2FyZCxcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuXG4gICAgaWYgKCFkYXRhLnZlcnNpb24gfHwgZGF0YS52ZXJzaW9uICE9PSB0aGlzLmZvcm1hdFZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgJ0luY29tcGF0aWJsZSB2ZXJzaW9uJztcbiAgICB9XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLmJvYXJkcy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVCb2FyZENhbGxiYWNrKHRoaXMuYm9hcmRzW2luZGV4XS5uYW1lKTtcbiAgICB9XG5cblxuXG4gICAgdGhpcy5ib2FyZHMgPSBbXTtcblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGRhdGEuYm9hcmRzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICBib2FyZCA9IG5ldyBCb2FyZChkYXRhLmJvYXJkc1tpbmRleF0sIHRoaXMuZ2FtZSk7XG4gICAgICAgIHRoaXMuYm9hcmRzLnB1c2goYm9hcmQpO1xuICAgICAgICB0aGlzLmFkZEJvYXJkQ2FsbGJhY2soYm9hcmQubmFtZSk7XG4gICAgfVxuXG5cbiAgICBvcHRpb25zLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgb3B0aW9ucy5pZCA9IGRhdGEuaWQ7XG4gICAgb3B0aW9ucy5hdXRob3IgPSBkYXRhLmF1dGhvcjtcbiAgICBvcHRpb25zLnRpdGxlQm9hcmQgPSBkYXRhLnRpdGxlQm9hcmQ7XG4gICAgb3B0aW9ucy5zdGFydGluZ0JvYXJkID0gZGF0YS5zdGFydGluZ0JvYXJkO1xuICAgIG9wdGlvbnMudmljdG9yeUJvYXJkID0gZGF0YS52aWN0b3J5Qm9hcmQ7XG5cbiAgICB0aGlzLnNldEdhbWVPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgdGhpcy5zd2l0Y2hCb2FyZChkYXRhLnN0YXJ0aW5nQm9hcmQpO1xuXG59O1xuXG5FZGl0b3IucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwbGF5VGVzdCkge1xuICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgICAgaW5kZXg7XG4gICAgcmVzdWx0Lm5hbWUgPSB0aGlzLmdhbWUubmFtZTtcbiAgICByZXN1bHQudmVyc2lvbiA9IHRoaXMuZ2FtZS52ZXJzaW9uO1xuICAgIHJlc3VsdC5pZCA9IHRoaXMuZ2FtZS5pZDtcbiAgICByZXN1bHQudGl0bGVCb2FyZCA9IHRoaXMuZ2FtZS50aXRsZUJvYXJkO1xuICAgIHJlc3VsdC5zdGFydGluZ0JvYXJkID0gcGxheVRlc3QgPyB0aGlzLmN1cnJlbnRCb2FyZC5uYW1lIDogdGhpcy5nYW1lLnN0YXJ0aW5nQm9hcmQ7XG4gICAgcmVzdWx0LnZpY3RvcnlCb2FyZCA9IHRoaXMuZ2FtZS52aWN0b3J5Qm9hcmQ7XG4gICAgcmVzdWx0LnNhdmVkR2FtZSA9IHRydWU7XG4gICAgcmVzdWx0LmF1dGhvciA9IHRoaXMuZ2FtZS5hdXRob3I7XG4gICAgcmVzdWx0LmJvYXJkcyA9IFtdO1xuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYm9hcmRzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICByZXN1bHQuYm9hcmRzLnB1c2godGhpcy5ib2FyZHNbaW5kZXhdLnNlcmlhbGl6ZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkVkaXRvci5wcm90b3R5cGUuc2V0TW9kZSA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICB0aGlzLmNoYW5nZU1vZGVDYWxsYmFjayhtb2RlKTtcbn07XG5cbkVkaXRvci5wcm90b3R5cGUucmVtb3ZlQm9hcmQgPSBmdW5jdGlvbiAoYm9hcmROYW1lKSB7XG4gICAgdmFyIGluZGV4LFxuICAgICAgICBmb3VuZCA9IC0xO1xuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuYm9hcmRzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICBpZiAodGhpcy5ib2FyZHNbaW5kZXhdLm5hbWUgPT09IGJvYXJkTmFtZSkge1xuICAgICAgICAgICAgZm91bmQgPSBpbmRleDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmb3VuZCA+PSAwKSB7XG4gICAgICAgIHRoaXMuYm9hcmRzLnNwbGljZShmb3VuZCwgMSk7XG4gICAgICAgIHRoaXMucmVtb3ZlQm9hcmRDYWxsYmFjayhib2FyZE5hbWUpO1xuXG4gICAgICAgIGlmICh0aGlzLmJvYXJkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnN3aXRjaEJvYXJkKHRoaXMuYm9hcmRzWzBdLm5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG5FZGl0b3IucHJvdG90eXBlLmNyZWF0ZUJvYXJkID0gZnVuY3Rpb24gKGJvYXJkTmFtZSwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgdmFyIHRlbXBsYXRlID0ge1xuICAgICAgICAgICAgbmFtZTogYm9hcmROYW1lLFxuICAgICAgICAgICAgcGxheWVyWDogTWF0aC5mbG9vcih3aWR0aCAvIDIpLFxuICAgICAgICAgICAgcGxheWVyWTogTWF0aC5mbG9vcihoZWlnaHQgLyAyKSxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgdGlsZXM6IFtdLFxuICAgICAgICAgICAgc2NyaXB0czogW11cbiAgICAgICAgfSxcbiAgICAgICAgcm93LFxuICAgICAgICBjb2x1bW47XG5cbiAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IGhlaWdodDsgcm93ICs9IDEpIHtcbiAgICAgICAgZm9yIChjb2x1bW4gPSAwOyBjb2x1bW4gPCB3aWR0aDsgY29sdW1uICs9IDEpIHtcblxuICAgICAgICAgICAgc3dpdGNoIChyb3cpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhc2UgaGVpZ2h0IC0gMTpcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZS50aWxlc1tjb2x1bW4gKyByb3cgKiB3aWR0aF0gPSB7dHlwZTogJ1dhbGwnfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKGNvbHVtbiA9PT0gMCB8fCBjb2x1bW4gPT09IHdpZHRoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS50aWxlc1tjb2x1bW4gKyByb3cgKiB3aWR0aF0gPSB7dHlwZTogJ1dhbGwnfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS50aWxlc1tjb2x1bW4gKyByb3cgKiB3aWR0aF0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG5cbn07XG5cbkVkaXRvci5wcm90b3R5cGUuYWRkQm9hcmQgPSBmdW5jdGlvbiAoYm9hcmROYW1lLCB3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICB2YXIgbmV3Qm9hcmQsXG4gICAgICAgIHRlbXBsYXRlID0gdGhpcy5jcmVhdGVCb2FyZChib2FyZE5hbWUsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgbmV3Qm9hcmQgPSBuZXcgQm9hcmQodGVtcGxhdGUsIHRoaXMuZ2FtZSk7XG4gICAgdGhpcy5wbGF5ZXJQb3NpdGlvbi54ID0gbmV3Qm9hcmQuZGVmYXVsdFBsYXllclg7XG4gICAgdGhpcy5wbGF5ZXJQb3NpdGlvbi55ID0gbmV3Qm9hcmQuZGVmYXVsdFBsYXllclk7XG5cbiAgICB0aGlzLmJvYXJkcy5wdXNoKG5ld0JvYXJkKTtcblxuICAgIGlmICh0aGlzLmFkZEJvYXJkQ2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5hZGRCb2FyZENhbGxiYWNrKG5ld0JvYXJkLm5hbWUpO1xuICAgIH1cblxuICAgIHRoaXMuc3dpdGNoQm9hcmQobmV3Qm9hcmQubmFtZSk7XG5cbn07XG5cbkVkaXRvci5wcm90b3R5cGUuZ2V0VGVtcGxhdGVUaGluZyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuXG4gICAgdmFyIHRoaW5nO1xuXG4gICAgaWYgKHRlbXBsYXRlICYmIHRlbXBsYXRlLnR5cGUpIHtcblxuICAgICAgICBmb3IgKHRoaW5nIGluIEVkaXRvci5UaGluZykge1xuICAgICAgICAgICAgaWYgKEVkaXRvci5UaGluZy5oYXNPd25Qcm9wZXJ0eSh0aGluZykpIHtcblxuICAgICAgICAgICAgICAgIGlmICh0aGluZyA9PT0gdGVtcGxhdGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRWRpdG9yLlRoaW5nW3RoaW5nXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG5FZGl0b3IucHJvdG90eXBlLmNyZWF0ZUZpZWxkID0gZnVuY3Rpb24gKGZpZWxkTmFtZSwgZmllbGQsIHRlbXBsYXRlKSB7XG5cbiAgICB2YXIgbGFiZWwsXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIG1lID0gdGhpcyxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHNwcml0ZSxcbiAgICAgICAgZWxlbWVudFRlbXBsYXRlLFxuICAgICAgICBpbm5lckVsZW1lbnQsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBub25TdGFuZGFyZCA9IGZhbHNlO1xuXG4gICAgZnVuY3Rpb24gZ2V0RnJpZW5kbHlOYW1lKG5hbWUpIHtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIGNhc2UgJ0JyaWdodEJsdWUnOlxuICAgICAgICAgICAgcmV0dXJuICdCcmlnaHQgQmx1ZSc7XG4gICAgICAgIGNhc2UgJ0JyaWdodEdyZWVuJzpcbiAgICAgICAgICAgIHJldHVybiAnQnJpZ2h0IEdyZWVuJztcbiAgICAgICAgY2FzZSAnQnJpZ2h0Q3lhbic6XG4gICAgICAgICAgICByZXR1cm4gJ0JyaWdodCBDeWFuJztcbiAgICAgICAgY2FzZSAnQnJpZ2h0UmVkJzpcbiAgICAgICAgICAgIHJldHVybiAnQnJpZ2h0IFJlZCc7XG4gICAgICAgIGNhc2UgJ0JyaWdodE1hZ2VudGEnOlxuICAgICAgICAgICAgcmV0dXJuICdCcmlnaHQgTWFnZW50YSc7XG4gICAgICAgIGNhc2UgJ0JyaWdodFdoaXRlJzpcbiAgICAgICAgICAgIHJldHVybiAnQnJpZ2h0IFdoaXRlJztcbiAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICByZXR1cm4gJ1RyYW5zcGFyZW50JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5pdGlhbGl6ZVNwcml0ZVBvc2l0aW9uKGRvbUVsZW1lbnQpIHtcblxuICAgICAgICB2YXIgcm93LCBjb2x1bW4sIHNwcml0ZUluZGV4O1xuXG4gICAgICAgIHNwcml0ZUluZGV4ID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3ByaXRlLWluZGV4Jyk7XG5cbiAgICAgICAgY29sdW1uID0gc3ByaXRlSW5kZXggJSAxNjtcbiAgICAgICAgcm93ID0gTWF0aC5mbG9vcihzcHJpdGVJbmRleCAvIDE2KTtcblxuICAgICAgICBkb21FbGVtZW50LnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9IChjb2x1bW4gKiAtMTYpICsgJ3B4ICcgKyAocm93ICogLTMyKSArICdweCc7XG5cblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uU3ByaXRlQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgdmFyIHNwcml0ZUluZGV4ID0gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1zcHJpdGUtaW5kZXgnKSxcbiAgICAgICAgICAgIHNwcml0ZUZpZWxkTmFtZSA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtZmllbGQtbmFtZScpLFxuICAgICAgICAgICAgbWFpbkVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIHNwcml0ZUZpZWxkTmFtZSArICctc3ByaXRlcGlja2VyJyksXG4gICAgICAgICAgICBzcHJpdGVEaXNwbGF5ID0gbWFpbkVsZW1lbnQucXVlcnlTZWxlY3RvcignYnV0dG9uIC5zcHJpdGUnKTtcblxuICAgICAgICB0ZW1wbGF0ZVtzcHJpdGVGaWVsZE5hbWVdID0gc3ByaXRlSW5kZXg7XG4gICAgICAgIHNwcml0ZURpc3BsYXkuc2V0QXR0cmlidXRlKCdkYXRhLXNwcml0ZS1pbmRleCcsIHNwcml0ZUluZGV4KTtcbiAgICAgICAgaW5pdGlhbGl6ZVNwcml0ZVBvc2l0aW9uKHNwcml0ZURpc3BsYXkpO1xuICAgICAgICBtZS5jaGFuZ2VUZW1wbGF0ZUNhbGxiYWNrKHRlbXBsYXRlKTtcblxuICAgIH1cblxuICAgIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICBsYWJlbC5pbm5lckhUTUwgPSBmaWVsZC5sYWJlbDtcblxuICAgIGlmIChmaWVsZC50eXBlID09PSAnbnVtYmVyJykge1xuXG4gICAgICAgIC8vIE91ciBmaWVsZCB0eXBlIGlzIGEgbnVtYmVyLCBzbyBjcmVhdGUgYSBudW1iZXIgaW5wdXRcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGVsZW1lbnQudHlwZSA9ICdudW1iZXInO1xuICAgICAgICBlbGVtZW50Lm1pbiA9IGZpZWxkLm1pbjtcbiAgICAgICAgZWxlbWVudC5tYXggPSBmaWVsZC5tYXg7XG5cbiAgICB9IGVsc2UgaWYgKGZpZWxkLnR5cGUgPT09ICdkaXJlY3Rpb24nKSB7XG5cbiAgICAgICAgLy8gT3VyIGZpZWxkIHR5cGUgaXMgYSBkaXJlY3Rpb24sIHNvIGNyZWF0ZSBhIGRpcmVjdGlvbiBzZWxlY3RvclxuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgICAgIGVsZW1lbnQub3B0aW9uc1tlbGVtZW50Lm9wdGlvbnMubGVuZ3RoXSA9IG5ldyBPcHRpb24oJ05vcnRoJywgJ04nKTtcbiAgICAgICAgZWxlbWVudC5vcHRpb25zW2VsZW1lbnQub3B0aW9ucy5sZW5ndGhdID0gbmV3IE9wdGlvbignRWFzdCcsICdFJyk7XG4gICAgICAgIGVsZW1lbnQub3B0aW9uc1tlbGVtZW50Lm9wdGlvbnMubGVuZ3RoXSA9IG5ldyBPcHRpb24oJ1NvdXRoJywgJ1MnKTtcbiAgICAgICAgZWxlbWVudC5vcHRpb25zW2VsZW1lbnQub3B0aW9ucy5sZW5ndGhdID0gbmV3IE9wdGlvbignV2VzdCcsICdXJyk7XG5cbiAgICB9IGVsc2UgaWYgKGZpZWxkLnR5cGUgPT09ICdib29sZWFuJykge1xuXG4gICAgICAgIC8vIE91ciBmaWVsZCB0eXBlIGlzIGEgYm9vbGVhbiwgc28gY3JlYXRlIGEgc2xpZGluZyB0b2dnbGVcblxuICAgICAgICAvLyBFc3RhYmxpc2ggb3VyIHRlbXBsYXRlIChiYXNlZCBvbiBGb3VuZGF0aW9uIGZyYW1ld29yaydzIHRvZ2dsZSBtYXJrdXApXG4gICAgICAgIGVsZW1lbnRUZW1wbGF0ZSA9ICc8aW5wdXQgaWQ9XCJ7e2ZpZWxkSWR9fVwiIHR5cGU9XCJjaGVja2JveFwiPjxsYWJlbCBmb3I9XCJ7e2ZpZWxkSWR9fVwiPjwvbGFiZWw+JztcbiAgICAgICAgZWxlbWVudFRlbXBsYXRlID0gZWxlbWVudFRlbXBsYXRlLnJlcGxhY2UoL1xce1xce2ZpZWxkSWRcXH1cXH0vZywgZmllbGROYW1lICsgJy1jaGVja2JveCcpO1xuXG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBlbGVtZW50VGVtcGxhdGU7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc3dpdGNoJyk7XG4gICAgICAgIG5vblN0YW5kYXJkID0gdHJ1ZTtcbiAgICAgICAgaW5uZXJFbGVtZW50ID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcjJyArIGZpZWxkTmFtZSArICctY2hlY2tib3gnKTtcblxuICAgICAgICAvLyBBZGQgYW4gZXZlbnQgbGlzdG5lciB0byBvdXIgY2hlY2tib3guLi5cbiAgICAgICAgaW5uZXJFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGVtcGxhdGVbZmllbGROYW1lXSA9IGlubmVyRWxlbWVudC5jaGVja2VkO1xuICAgICAgICAgICAgbWUuY2hhbmdlVGVtcGxhdGVDYWxsYmFjayhtZS5hY3RpdmVUZW1wbGF0ZSk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICAvLyBTZXQgb3VyIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBlbGVtZW50Li4uXG4gICAgICAgIGlmICh0ZW1wbGF0ZS5oYXNPd25Qcm9wZXJ0eShmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBpbm5lckVsZW1lbnQuY2hlY2tlZCA9IHRlbXBsYXRlW2ZpZWxkTmFtZV07XG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICBpbm5lckVsZW1lbnQuY2hlY2tlZCA9IGZpZWxkLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChmaWVsZC50eXBlID09PSAnc3ByaXRlJykge1xuXG4gICAgICAgIC8vIE91ciBmaWVsZCB0eXBlIGlzIGEgc3ByaXRlXG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIG5vbi1zdGFuZGFyZCBmb3JtIGVsZW1lbnQsIG5hdHVyYWxseVxuICAgICAgICBub25TdGFuZGFyZCA9IHRydWU7XG5cbiAgICAgICAgZWxlbWVudFRlbXBsYXRlID0gJzxidXR0b24gY2xhc3M9XCJsYXJnZSBzZWNvbmRhcnkgYnV0dG9uIGRyb3Bkb3duIGV4cGFuZCBzcHJpdGVwaWNrZXJcIiBkYXRhLWRyb3Bkb3duPVwie3tmaWVsZElkfX1cIiBkYXRhLW9wdGlvbnM9XCJhbGlnbjogcmlnaHRcIj48ZGl2IGNsYXNzPVwic3ByaXRlXCI+PC9kaXY+PC9idXR0b24+PGRpdiBpZD1cInt7ZmllbGRJZH19XCIgZGF0YS1kcm9wZG93bi1jb250ZW50IGNsYXNzPVwiZi1kcm9wZG93biBtZWRpdW0gY29udGVudFwiPjxkaXYgY2xhc3M9XCJzcHJpdGVzXCIgLz48L2Rpdj48aW5wdXQgdHlwZT1cImhpZGRlblwiPic7XG4gICAgICAgIGVsZW1lbnRUZW1wbGF0ZSA9IGVsZW1lbnRUZW1wbGF0ZS5yZXBsYWNlKC9cXHtcXHtmaWVsZElkXFx9XFx9L2csIGZpZWxkTmFtZSArICctc3ByaXRlcGlja2VyJyk7XG5cbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGZpZWxkTmFtZSArICctc3ByaXRlcGlja2VyJztcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBlbGVtZW50VGVtcGxhdGU7XG5cbiAgICAgICAgaW5uZXJFbGVtZW50ID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuc3ByaXRlJyk7XG4gICAgICAgIGlubmVyRWxlbWVudC5zdHlsZS5tYXJnaW4gPSAnMCAwIDAgMWVtJztcblxuICAgICAgICBpZiAodGVtcGxhdGUuaGFzT3duUHJvcGVydHkoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgaW5uZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1zcHJpdGUtaW5kZXgnLCB0ZW1wbGF0ZVtmaWVsZE5hbWVdKTtcbiAgICAgICAgICAgIGluaXRpYWxpemVTcHJpdGVQb3NpdGlvbihpbm5lckVsZW1lbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICAgICAgaW5uZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1zcHJpdGUtaW5kZXgnLCBmaWVsZC5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZVNwcml0ZVBvc2l0aW9uKGlubmVyRWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbm5lckVsZW1lbnQgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zcHJpdGVzJyk7XG5cbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgMjU2OyBpbmRleCArPSAxKSB7XG5cbiAgICAgICAgICAgIHNwcml0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgc3ByaXRlLmNsYXNzTmFtZSA9ICdzcHJpdGUnO1xuICAgICAgICAgICAgc3ByaXRlLnNldEF0dHJpYnV0ZSgnZGF0YS1zcHJpdGUtaW5kZXgnLCBpbmRleCk7XG4gICAgICAgICAgICBzcHJpdGUuc2V0QXR0cmlidXRlKCdkYXRhLWZpZWxkLW5hbWUnLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgc3ByaXRlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25TcHJpdGVDbGljaywgZmFsc2UpO1xuICAgICAgICAgICAgaW5pdGlhbGl6ZVNwcml0ZVBvc2l0aW9uKHNwcml0ZSk7XG4gICAgICAgICAgICBpbm5lckVsZW1lbnQuYXBwZW5kQ2hpbGQoc3ByaXRlKTtcblxuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGZpZWxkLnR5cGUgPT09ICdjb2xvcicpIHtcblxuICAgICAgICAvLyBPdXIgZmllbGQgdHlwZSBpcyBhIGNvbG9yLi4uXG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgZmllbGQub3B0aW9ucy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIGVsZW1lbnQub3B0aW9uc1tlbGVtZW50Lm9wdGlvbnMubGVuZ3RoXSA9IG5ldyBPcHRpb24oZ2V0RnJpZW5kbHlOYW1lKGdldENvbG9yKGZpZWxkLm9wdGlvbnNbaW5kZXhdKS5uYW1lKSwgZmllbGQub3B0aW9uc1tpbmRleF0pO1xuICAgICAgICB9XG4gICAgICAgIG5vblN0YW5kYXJkID0gdHJ1ZTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSB0ZW1wbGF0ZVtmaWVsZE5hbWVdLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQsXG4gICAgICAgICAgICAgICAgZm9yZWdyb3VuZDtcblxuICAgICAgICAgICAgb2xkVmFsdWUgPSBvbGRWYWx1ZSB8fCBmaWVsZC5kZWZhdWx0VmFsdWUgPyBmaWVsZC5kZWZhdWx0VmFsdWUgOiAnKionO1xuICAgICAgICAgICAgYmFja2dyb3VuZCA9IGRlc2VyaWFsaXplQmFja2dyb3VuZChvbGRWYWx1ZSk7XG4gICAgICAgICAgICBmb3JlZ3JvdW5kID0gZGVzZXJpYWxpemVGb3JlZ3JvdW5kKG9sZFZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKGZpZWxkLmZvcmVncm91bmQpIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVtmaWVsZE5hbWVdID0gc2VyaWFsaXplQ29sb3IoYmFja2dyb3VuZCwgZ2V0Q29sb3IoZWxlbWVudC52YWx1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZVtmaWVsZE5hbWVdID0gc2VyaWFsaXplQ29sb3IoZ2V0Q29sb3IoZWxlbWVudC52YWx1ZSksIGZvcmVncm91bmQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtZS5jaGFuZ2VUZW1wbGF0ZUNhbGxiYWNrKG1lLmFjdGl2ZVRlbXBsYXRlKTtcblxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIGlmICh0ZW1wbGF0ZS5oYXNPd25Qcm9wZXJ0eShmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoZmllbGQuZm9yZWdyb3VuZCkge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gZGVzZXJpYWxpemVGb3JlZ3JvdW5kKHRlbXBsYXRlW2ZpZWxkTmFtZV0pO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQudmFsdWUgPSBjb2xvciA/IGNvbG9yLmNvZGUgOiBDb2xvcnMuWWVsbG93O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IGRlc2VyaWFsaXplQmFja2dyb3VuZCh0ZW1wbGF0ZVtmaWVsZE5hbWVdKTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnZhbHVlID0gY29sb3IgPyBjb2xvci5jb2RlIDogQ29sb3JzLkJsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZmllbGQuZm9yZWdyb3VuZCkge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gZGVzZXJpYWxpemVGb3JlZ3JvdW5kKGZpZWxkLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IGNvbG9yID8gY29sb3IuY29kZSA6IENvbG9ycy5ZZWxsb3c7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbG9yID0gZGVzZXJpYWxpemVCYWNrZ3JvdW5kKGZpZWxkLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IGNvbG9yID8gY29sb3IuY29kZSA6IENvbG9ycy5CbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIE91ciBmaWVsZCB0eXBlIGlzIGFueXRoaW5nIGVsc2UuLi5cbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGVsZW1lbnQudHlwZSA9ICd0ZXh0JztcblxuICAgIH1cblxuICAgIC8vIElmIG91ciBlbGVtZW50IGlzIGF2YWlsYWJsZSBhbmQgaXQncyBzdGFuZGFyZCBiZWhhdmlvdXIuLi5cbiAgICBpZiAoIW5vblN0YW5kYXJkICYmIGVsZW1lbnQpIHtcblxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlW2ZpZWxkTmFtZV0gPSBlbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgbWUuY2hhbmdlVGVtcGxhdGVDYWxsYmFjayhtZS5hY3RpdmVUZW1wbGF0ZSk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICBpZiAodGVtcGxhdGUuaGFzT3duUHJvcGVydHkoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgZWxlbWVudC52YWx1ZSA9IHRlbXBsYXRlW2ZpZWxkTmFtZV07XG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgICBlbGVtZW50LnZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBsYWJlbC5hcHBlbmRDaGlsZChlbGVtZW50KTtcblxuICAgIGlmIChmaWVsZC5hZHZhbmNlZCkge1xuICAgICAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKCdhZHZhbmNlZCcpO1xuICAgIH1cblxuICAgIHJldHVybiBsYWJlbDtcblxuXG59O1xuXG5FZGl0b3IucHJvdG90eXBlLnNldEFjdGl2ZVRlbXBsYXRlID0gZnVuY3Rpb24gKHRlbXBsYXRlKSB7XG5cbiAgICB2YXIgdGhpbmcsXG4gICAgICAgIGZpZWxkO1xuXG4gICAgdGhpcy5hY3RpdmVUZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIHRoaXMudGVtcGxhdGVDdXN0b21pemVyLmlubmVySFRNTCA9ICcnO1xuXG4gICAgdGhpbmcgPSB0aGlzLmdldFRlbXBsYXRlVGhpbmcodGVtcGxhdGUpO1xuICAgIGlmICh0aGluZykge1xuXG4gICAgICAgIGZvciAoZmllbGQgaW4gdGhpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGluZy5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBsYXRlQ3VzdG9taXplci5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUZpZWxkKGZpZWxkLCB0aGluZ1tmaWVsZF0sIHRlbXBsYXRlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuXG4gICAgdGhpcy5jaGFuZ2VUZW1wbGF0ZUNhbGxiYWNrKHRoaXMuYWN0aXZlVGVtcGxhdGUpO1xufTtcblxuRWRpdG9yLnByb3RvdHlwZS5zZXRUZW1wbGF0ZUZvcmVncm91bmQgPSBmdW5jdGlvbiAoZm9yZWdyb3VuZCkge1xuICAgIHZhciBiYWNrZ3JvdW5kO1xuICAgIGlmICghdGhpcy5hY3RpdmVUZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmFjdGl2ZVRlbXBsYXRlLmNvbG9yKSB7XG4gICAgICAgIGJhY2tncm91bmQgPSBkZXNlcmlhbGl6ZUJhY2tncm91bmQodGhpcy5hY3RpdmVUZW1wbGF0ZS5jb2xvcik7XG4gICAgICAgIHRoaXMuYWN0aXZlVGVtcGxhdGUuY29sb3IgPSBzZXJpYWxpemVDb2xvcihiYWNrZ3JvdW5kLCBmb3JlZ3JvdW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFjdGl2ZVRlbXBsYXRlLmNvbG9yID0gc2VyaWFsaXplQ29sb3IoQ29sb3JzLkJsYWNrLCBmb3JlZ3JvdW5kKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VUZW1wbGF0ZUNhbGxiYWNrKHRoaXMuYWN0aXZlVGVtcGxhdGUpO1xufTtcblxuRWRpdG9yLnByb3RvdHlwZS5zZXRUZW1wbGF0ZUJhY2tncm91bmQgPSBmdW5jdGlvbiAoYmFja2dyb3VuZCkge1xuICAgIHZhciBmb3JlZ3JvdW5kO1xuICAgIGlmICghdGhpcy5hY3RpdmVUZW1wbGF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmFjdGl2ZVRlbXBsYXRlLmNvbG9yKSB7XG4gICAgICAgIGZvcmVncm91bmQgPSBkZXNlcmlhbGl6ZUZvcmVncm91bmQodGhpcy5hY3RpdmVUZW1wbGF0ZS5jb2xvcik7XG4gICAgICAgIHRoaXMuYWN0aXZlVGVtcGxhdGUuY29sb3IgPSBzZXJpYWxpemVDb2xvcihiYWNrZ3JvdW5kLCBmb3JlZ3JvdW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFjdGl2ZVRlbXBsYXRlLmNvbG9yID0gc2VyaWFsaXplQ29sb3IoYmFja2dyb3VuZCwgQ29sb3JzLlllbGxvdyk7XG4gICAgfVxuICAgIHRoaXMuY2hhbmdlVGVtcGxhdGVDYWxsYmFjayh0aGlzLmFjdGl2ZVRlbXBsYXRlKTtcbn07XG5cbkVkaXRvci5wcm90b3R5cGUuZXZlbnRUb0JvYXJkUG9pbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgIHZhciBzY2FsZVggPSB0aGlzLmNhbnZhc0VsZW1lbnQud2lkdGggLyB0aGlzLmNhbnZhc0VsZW1lbnQub2Zmc2V0V2lkdGgsXG4gICAgICAgIHNjYWxlWSA9IHRoaXMuY2FudmFzRWxlbWVudC5oZWlnaHQgLyB0aGlzLmNhbnZhc0VsZW1lbnQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICB4ID0gTWF0aC5mbG9vcigoZXZlbnQub2Zmc2V0WCAqIHNjYWxlWCkgLyB0aGlzLmdhbWUucmVzb3VyY2VzLmdyYXBoaWNzLlRJTEVfU0laRS54KSxcbiAgICAgICAgeSA9IE1hdGguZmxvb3IoKGV2ZW50Lm9mZnNldFkgKiBzY2FsZVkpIC8gdGhpcy5nYW1lLnJlc291cmNlcy5ncmFwaGljcy5USUxFX1NJWkUueSk7XG4gICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KS5hZGQodGhpcy5jdXJyZW50Qm9hcmQud2luZG93T3JpZ2luKTtcbn07XG5cbkVkaXRvci5wcm90b3R5cGUub25LZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cbiAgICB2YXIgb2xkTW9kZSxcbiAgICAgICAgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA6ICcnO1xuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgIT09ICdpbnB1dCcgJiYgYWN0aXZlRWxlbWVudCAhPT0gJ3RleHRhcmVhJyAmJiBhY3RpdmVFbGVtZW50ICE9PSAnc2VsZWN0JyAmJiBhY3RpdmVFbGVtZW50ICE9PSAnYnV0dG9uJykge1xuXG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlID09PSAzNykge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yKERpcmVjdGlvbi5XZXN0KTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMzgpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvcihEaXJlY3Rpb24uTm9ydGgpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSAzOSkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlQ3Vyc29yKERpcmVjdGlvbi5FYXN0KTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gNDApIHtcbiAgICAgICAgICAgIHRoaXMubW92ZUN1cnNvcihEaXJlY3Rpb24uU291dGgpO1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXlDb2RlID09PSA4Mykge1xuICAgICAgICAgICAgdGhpcy5zZXRNb2RlKEVkaXRvci5Nb2RlLlNFTEVDVCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IDY4KSB7XG4gICAgICAgICAgICB0aGlzLnNldE1vZGUoRWRpdG9yLk1vZGUuRFJBVyk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IDcwKSB7XG4gICAgICAgICAgICB0aGlzLnNldE1vZGUoRWRpdG9yLk1vZGUuRklMTCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IDMyKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGUgPT09IEVkaXRvci5Nb2RlLkRSQVcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZVBsb3QoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnZva2VUb29sKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgIG9sZE1vZGUgPSB0aGlzLm1vZGU7XG4gICAgICAgICAgICB0aGlzLm1vZGUgPSBFZGl0b3IuTW9kZS5TRUxFQ1Q7XG4gICAgICAgICAgICB0aGlzLmludm9rZVRvb2woKTtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IG9sZE1vZGU7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleUNvZGUgPT09IDg4KSB7XG4gICAgICAgICAgICBvbGRNb2RlID0gdGhpcy5tb2RlO1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gRWRpdG9yLk1vZGUuRklMTDtcbiAgICAgICAgICAgIHRoaXMuaW52b2tlVG9vbCgpO1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gb2xkTW9kZTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5Q29kZSA9PT0gOSkge1xuXG4gICAgICAgICAgICB0aGlzLmRyYXdpbmcgPSAhdGhpcy5kcmF3aW5nO1xuICAgICAgICAgICAgdGhpcy5wbG90KCk7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cbkVkaXRvci5wcm90b3R5cGUuaW52b2tlVG9vbCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0aGluZztcblxuICAgIGlmICh0aGlzLm1vZGUgPT09IEVkaXRvci5Nb2RlLlNFTEVDVCkge1xuXG4gICAgICAgIHRoaW5nID0gdGhpcy5jdXJyZW50Qm9hcmQuZ2V0VGlsZSh0aGlzLmN1cnNvcik7XG4gICAgICAgIGlmICh0aGluZykge1xuICAgICAgICAgICAgdGhpcy5zZXRBY3RpdmVUZW1wbGF0ZSh0aGluZy5zZXJpYWxpemUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEFjdGl2ZVRlbXBsYXRlKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSBFZGl0b3IuTW9kZS5GSUxMKSB7XG5cbiAgICAgICAgdGhpcy5maWxsKHRoaXMuY3Vyc29yKTtcblxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyKHRoaXMuY29udGV4dCk7XG5cbn07XG5cbkVkaXRvci5wcm90b3R5cGUub25DYW52YXNNb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgIGlmICh0aGlzLm1vZGUgPT09IEVkaXRvci5Nb2RlLkRSQVcpIHtcbiAgICAgICAgdGhpcy5kcmF3aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wcmV2aW91c1Bsb3QgPSBuZXcgUG9pbnQoLTEsIC0xKTtcbiAgICB9XG5cbiAgICB0aGlzLnNldEN1cnNvclBvc2l0aW9uKHRoaXMuZXZlbnRUb0JvYXJkUG9pbnQoZXZlbnQpKTtcblxufTtcblxuRWRpdG9yLnByb3RvdHlwZS5vbkNhbnZhc01vdXNlTW92ZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgIHRoaXMuc2V0Q3Vyc29yUG9zaXRpb24odGhpcy5ldmVudFRvQm9hcmRQb2ludChldmVudCkpO1xuICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuXG59O1xuXG5FZGl0b3IucHJvdG90eXBlLm9uQ2FudmFzTW91c2VVcCA9IGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgdGhpcy5kcmF3aW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLnNldEN1cnNvclBvc2l0aW9uKHRoaXMuZXZlbnRUb0JvYXJkUG9pbnQoZXZlbnQpKTtcbiAgICB0aGlzLmludm9rZVRvb2woKTtcblxufTtcblxuRWRpdG9yLnByb3RvdHlwZS5vbkNhbnZhc1Njcm9sbCA9IGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgdmFyIGRlbHRhWCA9IE1hdGgucm91bmQoZXZlbnQuZGVsdGFYIC8gMTApLFxuICAgICAgICBkZWx0YVkgPSBNYXRoLnJvdW5kKGV2ZW50LmRlbHRhWSAvIDEwKTtcbiAgICBkZWx0YVggPSBkZWx0YVggPiAyID8gMiA6IGRlbHRhWCA8IC0yID8gLTIgOiBkZWx0YVg7XG4gICAgZGVsdGFZID0gZGVsdGFZID4gMiA/IDIgOiBkZWx0YVkgPCAtMiA/IC0yIDogZGVsdGFZO1xuXG4gICAgdGhpcy5mb2N1c1BvaW50ID0gdGhpcy5mb2N1c1BvaW50LmFkZChuZXcgUG9pbnQoZGVsdGFYLCBkZWx0YVkpKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMucmVuZGVyKHRoaXMuY29udGV4dCk7XG5cbn07XG5cbkVkaXRvci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIChwb2ludCkge1xuXG4gICAgdmFyIHRoaW5nLFxuICAgICAgICB0YXJnZXREZXRhaWxzLFxuICAgICAgICBtZSA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBnZXREZXRhaWxzKHRoaW5nKSB7XG5cbiAgICAgICAgdmFyIHR5cGUsXG4gICAgICAgICAgICBjb2xvcjtcblxuICAgICAgICBpZiAodGhpbmcgJiYgdGhpbmcuY29uc3RydWN0b3IgJiYgdGhpbmcuY29uc3RydWN0b3IudHlwZSkge1xuICAgICAgICAgICAgdHlwZSA9IHRoaW5nLmNvbnN0cnVjdG9yLnR5cGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpbmcpIHtcbiAgICAgICAgICAgIGNvbG9yID0gc2VyaWFsaXplQ29sb3IodGhpbmcuZm9yZWdyb3VuZCwgdGhpbmcuYmFja2dyb3VuZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3RyaW5nKHR5cGUpICsgU3RyaW5nKGNvbG9yKTtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbGxOZWlnaGJvdXIocG9pbnQsIHRhcmdldERldGFpbHMpIHtcblxuICAgICAgICB2YXIgZGV0YWlscyA9IGdldERldGFpbHMobWUuY3VycmVudEJvYXJkLmdldFRpbGUocG9pbnQpKTtcbiAgICAgICAgaWYgKGRldGFpbHMgPT09IHRhcmdldERldGFpbHMpIHtcbiAgICAgICAgICAgIG1lLmZpbGwocG9pbnQpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jdXJyZW50Qm9hcmQuaXNPdXRzaWRlKHBvaW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpbmcgPSB0aGlzLmN1cnJlbnRCb2FyZC5nZXRUaWxlKHBvaW50KTtcbiAgICB0YXJnZXREZXRhaWxzID0gZ2V0RGV0YWlscyh0aGluZyk7XG5cbiAgICAvLyBEb24ndCBmaWxsIGlmIHdlJ3JlIGFscmVhZHkgdGhlIGNvcnJlY3QgdHlwZVxuICAgIGlmIChnZXREZXRhaWxzKHRoaW5ncy5UaGluZ0ZhY3RvcnkuZGVzZXJpYWxpemUodGhpcy5hY3RpdmVUZW1wbGF0ZSwgdGhpcy5jdXJyZW50Qm9hcmQpKSA9PT0gdGFyZ2V0RGV0YWlscykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBhY3RpdmUgdGVtcGxhdGUsIGFkZCBvdXIgdGhpbmdcbiAgICBpZiAodGhpcy5hY3RpdmVUZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnRCb2FyZC5hZGRUaGluZyhwb2ludCwgdGhpbmdzLlRoaW5nRmFjdG9yeS5kZXNlcmlhbGl6ZSh0aGlzLmFjdGl2ZVRlbXBsYXRlLCB0aGlzLmN1cnJlbnRCb2FyZCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJvYXJkLmFkZFRoaW5nKHBvaW50LCB1bmRlZmluZWQpO1xuICAgIH1cblxuICAgIGZpbGxOZWlnaGJvdXIocG9pbnQuYWRkKERpcmVjdGlvbi5Ob3J0aCksIHRhcmdldERldGFpbHMpO1xuICAgIGZpbGxOZWlnaGJvdXIocG9pbnQuYWRkKERpcmVjdGlvbi5FYXN0KSwgdGFyZ2V0RGV0YWlscyk7XG4gICAgZmlsbE5laWdoYm91cihwb2ludC5hZGQoRGlyZWN0aW9uLlNvdXRoKSwgdGFyZ2V0RGV0YWlscyk7XG4gICAgZmlsbE5laWdoYm91cihwb2ludC5hZGQoRGlyZWN0aW9uLldlc3QpLCB0YXJnZXREZXRhaWxzKTtcblxufTtcblxuRWRpdG9yLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuXG4gICAgLy8gSWYgd2UgYXJlbid0IGZ1bGx5IGxvYWRlZCwgZG9uJ3QgcmVuZGVyIGFueXRoaW5nIHlldFxuICAgIGlmICghdGhpcy5jdXJyZW50Qm9hcmQgfHwgIXBsYXllclNwcml0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50Qm9hcmQuZm9jdXNQb2ludCA9IHRoaXMuZm9jdXNQb2ludDtcbiAgICB0aGlzLmN1cnJlbnRCb2FyZC5yZW5kZXIoY29udGV4dCk7XG4gICAgcGxheWVyU3ByaXRlLmRyYXcoY29udGV4dCwgdGhpcy5wbGF5ZXJQb3NpdGlvbi5zdWJ0cmFjdCh0aGlzLmN1cnJlbnRCb2FyZC53aW5kb3dPcmlnaW4pLCBDb2xvcnMuQnJpZ2h0V2hpdGUsIENvbG9ycy5CbHVlKTtcbiAgICB0aGlzLmRyYXdDdXJzb3IoY29udGV4dCk7XG59O1xuXG5FZGl0b3IucHJvdG90eXBlLmRyYXdDdXJzb3IgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuXG4gICAgdmFyIHhTaXplID0gdGhpcy5ncmFwaGljcy5USUxFX1NJWkUueCxcbiAgICAgICAgeVNpemUgPSB0aGlzLmdyYXBoaWNzLlRJTEVfU0laRS55LFxuICAgICAgICB4UG9zID0gdGhpcy5jdXJzb3Iuc3VidHJhY3QodGhpcy5jdXJyZW50Qm9hcmQud2luZG93T3JpZ2luKS54ICogdGhpcy5ncmFwaGljcy5USUxFX1NJWkUueCxcbiAgICAgICAgeVBvcyA9IHRoaXMuY3Vyc29yLnN1YnRyYWN0KHRoaXMuY3VycmVudEJvYXJkLndpbmRvd09yaWdpbikueSAqIHRoaXMuZ3JhcGhpY3MuVElMRV9TSVpFLnk7XG5cbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICdyZ2JhKDIyMiwgMjIyLCAyNTUsIDAuMjUpJztcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJyNERERERkYnO1xuICAgIGNvbnRleHQubGluZVdpZHRoID0gdGhpcy5kcmF3aW5nID8gNCA6IDI7XG5cbiAgICBjb250ZXh0LmZpbGxSZWN0KHhQb3MsIHlQb3MsICB4U2l6ZSwgeVNpemUpO1xuXG4gICAgLy8gSWYgd2UncmUgaW4gZHJhd2luZyBtb2RlXG4gICAgaWYgKHRoaXMubW9kZSA9PT0gRWRpdG9yLk1vZGUuRFJBVykge1xuICAgICAgICBjb250ZXh0LnN0cm9rZVJlY3QoeFBvcywgeVBvcywgeFNpemUsIHlTaXplKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gRWRpdG9yLk1vZGUuU0VMRUNUKSB7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHhQb3MgKyAoeFNpemUgLyAyKSwgeVBvcyk7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHhQb3MgKyAoeFNpemUgLyAyKSwgeVBvcyArIHlTaXplKTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeFBvcywgeVBvcyArICh5U2l6ZSAvIDIpKTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeFBvcyArIHhTaXplLCB5UG9zICsgKHlTaXplIC8gMikpO1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cblxuICAgIGNvbnRleHQuZm9udCA9ICc5cHQgQXJpYWwnO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICBjb250ZXh0LmZpbGxUZXh0KCcoJyArICh0aGlzLmN1cnNvci54ICsgMSkgKyAnLCAnICsgKHRoaXMuY3Vyc29yLnkgKyAxKSArICcpJywgNSwgMTUpO1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICBjb250ZXh0LmZpbGxUZXh0KCcoJyArICh0aGlzLmN1cnNvci54ICsgMSkgKyAnLCAnICsgKHRoaXMuY3Vyc29yLnkgKyAxKSArICcpJywgNCwgMTQpO1xuXG59O1xuXG5leHBvcnRzLkVkaXRvciA9IEVkaXRvcjtcbiIsIi8qKlxuICogSlpUU2NyaXB0XG4gKiBDb3B5cmlnaHQgwqkgMjAxNCBPcmFuZ2VsaW5lIEludGVyYWN0aXZlLCBJbmMuXG4gKiBAYXV0aG9yIE1hcmsgTWNJbnR5cmVcbiAqL1xuXG4vKmpzbGludCBub2RlOnRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdhbWVTdGF0ZSBpcyBhbiBlbnVtZXJhdGVkIHR5cGUgcmVwcmVzZW50aW5nIGEgc3RhdGUgaW4gb3VyIGdhbWUncyBmaW5pdGUgc3RhdGVcbiAqIG1hY2hpbmUuXG4gKi9cbnZhciBHYW1lU3RhdGUgPSB7XG4gICAgRXJyb3I6IC0yLFxuICAgIFNwbGFzaDogLTEsXG4gICAgTG9hZGluZzogMCxcbiAgICBQbGF5aW5nOiAxLFxuICAgIFBhdXNlZDogMixcbiAgICBHYW1lT3ZlcjogMyxcbiAgICBSZWFkaW5nOiA0LFxuICAgIFRpdGxlOiA1LFxuICAgIFZpY3Rvcnk6IDYsXG4gICAgRmlsZU1hbmFnZW1lbnQ6IDdcbn07XG5cbmV4cG9ydHMuR2FtZVN0YXRlID0gR2FtZVN0YXRlO1xuIiwiLyoqXG4gKiBKWlQgR3JhcGhpY3MgYW5kIENvbG9yXG4gKiBDb3B5cmlnaHQgwqkgMjAxNCBPcmFuZ2VsaW5lIEludGVyYWN0aXZlLCBJbmMuXG4gKiBAYXV0aG9yIE1hcmsgTWNJbnR5cmVcbiAqL1xuXG4vKmpzbGludCBub2RlOnRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29uc3RydWN0b3JFcnJvciA9IHJlcXVpcmUoJy4vYmFzaWMnKS5Db25zdHJ1Y3RvckVycm9yLFxuICAgIFBvaW50ID0gcmVxdWlyZSgnLi9iYXNpYycpLlBvaW50LFxuICAgIGNvbG9ycyxcbiAgICBjeWNsZSxcbiAgICBCTElOS19SQVRFID0gMTAsXG4gICAgU1BSSVRFX0RBVEEgPSAnZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJQUFBQUVBQVFNQUFBQkJOK3prQUFBQUJsQk1WRVVBQUFELy8vK2wyWi9kQUFBR0JFbEVRVlJZdzhXWHY0c2tSUlRIQzRXT21yMDFlN2pMYldKd1lhRXdWMGl4QytLL1lHSlUzRWw1UVNFYnRRTVdmV2R5LzRPSm1Zbi9nOURNeWNPZ3VIQVptSEhaYURlUlkwRFltMkNwOXZ1cVoyWi9lSHFucmxyVDg2TS84N3JlajNyOVhyVlNxOUhqZFcxY2dyWmRnN3YyNERGK2ZZMS9pQVJzK1E4ZWtsTGZ6Y0sydFFMZTlRZVBTU1N5c2EzcTdiUDN2WDQ0S3lDZTlYVG12eGtEV0tWK2VKYnpHZjcvNklkazljTXpwYjQ1ZzBSYkFCV0pyL3RvaU9TUzFCNStYdVl3MjZMV1BrdTBPQ014YkZzTmFzZDBja28zVE85ZTVjc2JnODE0OGhZKzRoWFFWZVFmTXdLd1ZuaXlaZjNNd1pJMVdOeHQvY3pBdkFLMnMxcnVrNThGdVlTMHVtZXl5cG44VjJXTzJuWEJ4Q0t4VTBET1hZNnh6TEVUY2p0SVJDTmExSTdKbGxyUytWNDJ4WTZkT2hOWjBaSzN4VkxNSVpkY3RUK3FmenpvK3FrWG9LLzg3YUhFNkhxRHJBK3NncjYwdzc0WEpwUGdkRjNPRUZDcmNzZEc2ZHFMVENVcVFxd2JnQkxFdW9DSzVnQjlxN0lvRktEVFdxTG95azlkS25PQXVDTEJuQ1F6OFpPNllkS25qUkxEQUo1YzgwWC9nWFAvZkJpS3NjNUdGbkdJZnpETXU1MWpabkhWc2VKeFZkbXVxNWl4dWtvRFVGMkZGY0Q2MXVvSXE1b3VMdXJZaXFVMUFlZ3FWMHhjaWFzVjRSSlgxUlZyQWJxdEJYUXJJSmtKcndJeDF3eFFGeTJrVEp2ajNSaDFIQ3NOTzI3ZDhUOGEyeGQybWJObGUvZDB3UnhWTk40SDd6Mjg5dTdGS2R3UGZ1SWZQSmdVa004QjJIZiswYU1PSUxpY1dSMXo3UHg0M0dXcXgrN29HQ0FYaVdNV3dNOUZBc0FoeUpSQ0NmV2NaZElDL0FNQkhZdGE1d1Y0QVpIRnNNV0hiTWVuV1F6N0Yxei9YWElvZFJFdllndjk3TE5WTnVCK1lzOERZUDJrNWdGOGl2UGduK3BPN2hrQWg5WGs2R3Q5SWlBeWFpUHprYkdrRHdVNERuVUJwTFVaZ0s4RVJISjZ0NEFqZU00aEI1cm9yUUtPQlpnWCtOQ1ZnRVU4alRadUI3Ylp2bFdLU24zVC9LMGJSZlAxUTc4V2tEcFJ1d2pNQ1ZVblprQU9tZ015dEZvbnFZRFA1QjVmZ2ZFWWxyb21tQzFQdjh5eGNuWGd3SXZVVUJVb2U4UXcraTVsbHp4Vll6b1NrQUM2VjRPd0JweTRBRCtBSnNZbUlpcTJPclhzTi9sUlN3bThPdEpOTUpZS2R3dDVzMFdIemJXbzRkYWUzd1FRbmpmemVKRWtxYk1BbzN4cVdBTUVUb2RZdEFEZ0hjQ1JrUXFEWWdIZ3pBRDBCdFFEY0J2QW8yUnpLRlVKUlRnaUZyc05CVzR6REpOVldlZEh0ZnJlZ0hyVENWYy9sbTlhUE9YaWJlVU12SEtLa05iS0pqSkpCd1ZMdmRYaW5NSVpHWGhGeWhOQ05WbDFtZFVVYUkwcGpqRjhqTkVZRXdJQTF4aFNHT0NMRklPRStod2ppa3Nld0NSMUNjTjNYVmVhTU53dndBNEFFamF4Z0hvelI5M0VCcVBDUE5aYWdPcWFIWCt2OTlJcjdoZUVRanNVUmZpODNFSlk5aEdLTWRxR291RFREbVRnSVNWQ1ZiQ2YrU1JMbFlaclVWS2NYU0pLS2NISWxHQzZXOUNQcEZ5RGdzY0RjRzFxVlJ5bFMwREhrR2czd09NM3dIUURyQk50L2hMUXFZRDh4WE5vYVpvMlJyb2d2dlJrRlplcFV0ZlQ0L0RxRGZObm83a2FJTFF6TmJlU0tGM1o0bW1VdkFZaDBBSkVLWUxsNWx6QVpMS3g0blRmbElnVWRTYW0rWG1KYlVvMG1xTERjdks1amJxa0E4SVpCUnhqcnE3U21xWWpsUVE4RnhXVjh4WVNCV0EyN3FyNWM0czVyb0NuMzBvT05EWTJwUlRCNGYwYjYwclZEUmYzcXpmTGozYysrUmtXanBRYWpYQmcxbysvLy9JNitMc1N5NUZhbm8veStXaDVLVUhWcUtyV0VzdmxlWWJFZWM3TDVWcGloR05VMG5hbDVSTDhOeEpscnlORWxkZHRncjNSL1lPWC9mMytaYitSMEhwVmVmZjZYbzc3Qi9pN1NKUW5JZ25acUVSVi9WOUFEcEszUEo4dDd2UzNBM0RzN2VIcm1nUmRrZWo3L21Cdjc2RHZsd2pMNG83WU5aSzNCUFAvQmE4ZjQ3eHVQdWhXdTlMUFdRbHFEVXJJMnpvS3dCN1VTK3NqVldFRDM2UXV1TmJQVWZUcnRnV1lUN3VncDU3UWd2ZG5zOGhxQ2drU2tJT2Z6U0F4NWJVRXdLOHI0S2FSTE1Bd0J3QlBuWlFmanhvMmFNbUhqbHJ6d3FwdWw5ZlBuN2YrUUZjQXF1T2Q2Ym9pYjhuemcreXFocHF0NjUwMWtPeVhHcmxUOWhrQUxwYWlMTHNJS2ROMStFbEFpNjBieW5RQnl5aVhpRVFybW40WitxTHNRNmFvN1BCMzFTaDFUZE95dlJtQUxBSEFxcU9LUkk4bjZzSEMzVDkxNVMrQTN3Qk84OXZsZzJoZFdnQUFBQUJKUlU1RXJrSmdnZz09JztcblxuLyoqXG4gKiBTcHJpdGUgcmVwcmVzZW50cyBhIHN1YnNlY3Rpb24gb2YgYSBsYXJnZXIgZ3JhcGhpYyB0aGF0IGNhbiBiZSBkcmF3biBpbmRlcGVuZGV0bHlcbiAqIGF0IGEgbG9jYXRpb24uXG4gKlxuICogQHBhcmFtIHBvaW50IEEgcG9pbnQgZGVmaW5pbmcgdGhlIHRvcC1sZWZ0IHNwcml0ZSBvcmlnaW5cbiAqIEBwYXJhbSBvd25lciBBIEdyYXBoaWNzIGluc3RhbmNlIHRvIHdoaWNoIHRoaXMgU3ByaXRlIGJlbG9uZ3NcbiAqL1xuZnVuY3Rpb24gU3ByaXRlKHBvaW50LCBvd25lcikge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNwcml0ZSkpIHtcbiAgICAgICAgdGhyb3cgQ29uc3RydWN0b3JFcnJvcjtcbiAgICB9XG5cbiAgICB0aGlzLnBvaW50ID0gcG9pbnQ7XG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xufVxuXG4vKipcbiAqIERyYXdzIHRoaXMgU3ByaXRlIGluc3RhbmNlIG9uIGEgcHJvdmlkZWQgY29udGV4dCBhdCBhIHByb3ZpZGVkIFBvaW50IHVzaW5nIGEgZ2l2ZW5cbiAqIGZvcmVncm91bmQgYW5kIGJhY2tncm91bmQgY29sb3IuXG4gKlxuICogQHBhcmFtIGNvbnRleHQgQSAyRCBncmFwaGljcyBjb250ZXh0XG4gKiBAcGFyYW0gcG9pbnQgQSBQb2ludFxuICogQHBhcmFtIGZvcmVncm91bmQgQSBmb3JlZ3JvdW5kIGNvbG9yLlxuICogQHBhcmFtIGJhY2tncm91bmQgQSBiYWNrZ3JvdW5kIGNvbG9yLlxuICovXG5TcHJpdGUucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoY29udGV4dCwgcG9pbnQsIGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcblxuICAgIHZhciBibGluayxcbiAgICAgICAgZGVzdGluYXRpb25YLFxuICAgICAgICBkZXN0aW5hdGlvblk7XG5cbiAgICAvKlxuICAgICAqIEJhY2sgaW4gdGhlIERPUyBkYXlzLCBhIGJyaWdodCBiYWNrZ3JvdW5kIHdvdWxkIGFjdHVhbGx5IHNpZ25hbFxuICAgICAqIHRoYXQgdGhlIGZvcmVncm91bmQgY29sb3Igc2hvdWxkIGJsaW5rLiBXZSdyZSBkb2luZyB0aGUgc2FtZS5cbiAgICAgKi9cbiAgICBpZiAoYmFja2dyb3VuZCAmJiBiYWNrZ3JvdW5kLmlzTGlnaHQoKSkge1xuICAgICAgICBibGluayA9IHRydWU7XG4gICAgICAgIGJhY2tncm91bmQgPSBiYWNrZ3JvdW5kLmRhcmtlbigpO1xuICAgIH1cblxuICAgIGRlc3RpbmF0aW9uWCA9IHBvaW50LnggKiB0aGlzLm93bmVyLlRJTEVfU0laRS54O1xuICAgIGRlc3RpbmF0aW9uWSA9IHBvaW50LnkgKiB0aGlzLm93bmVyLlRJTEVfU0laRS55O1xuXG4gICAgLy8gRHJhdyB0aGUgYmFja2dyb3VuZFxuICAgIGlmIChiYWNrZ3JvdW5kKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYmFja2dyb3VuZC5yZ2JWYWx1ZTtcbiAgICAgICAgY29udGV4dC5maWxsUmVjdChkZXN0aW5hdGlvblgsIGRlc3RpbmF0aW9uWSwgdGhpcy5vd25lci5USUxFX1NJWkUueCwgdGhpcy5vd25lci5USUxFX1NJWkUueSk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgYXJlbid0IGJsaW5raW5nLCBvciBpZiB0aGUgYmxpbmsgc3RhdGUgaXMgb2ZmLCBkcmF3IG91ciBzcHJpdGVcbiAgICBpZiAoIWJsaW5rIHx8ICF0aGlzLm93bmVyLmJsaW5rU3RhdGUpIHtcblxuICAgICAgICBjb250ZXh0LmRyYXdJbWFnZSh0aGlzLm93bmVyLmNvbG9yU3ByaXRlU291cmNlc1tmb3JlZ3JvdW5kLmluZGV4XSwgdGhpcy5wb2ludC54LCB0aGlzLnBvaW50LnksIHRoaXMub3duZXIuU1BSSVRFX1NJWkUueCwgdGhpcy5vd25lci5TUFJJVEVfU0laRS55LFxuICAgICAgICAgICAgZGVzdGluYXRpb25YLCBkZXN0aW5hdGlvblksIHRoaXMub3duZXIuVElMRV9TSVpFLngsIHRoaXMub3duZXIuVElMRV9TSVpFLnkpO1xuXG4gICAgfVxuXG59O1xuXG5cbi8qKlxuICogR3JhcGhpY3MgcHJvdmlkZXMgZnVuY3Rpb25zIGZvciBkcmF3aW5nIHN0YW5kYXJkIERPUyBDb2RlUGFnZSA0MzcgY2hhcmFjdGVycyBpbiB0aGUgdXN1YWwgMTYgY29sb3VyXG4gKiBwYWxsZXR0ZSB0byBhIGdyYXBoaWNzIGNvbnRleHQuIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGNhbiBiZSBwcm92aWRlZCB0aGF0IHdpbGwgc2lnbmFsIHdoZW4gYWxsIGdyYXBoaWNzXG4gKiBoYXZlIGJlZW4gbG9hZGVkIGFuZCBpbml0aWFsaXplZC5cbiAqXG4gKiBAcGFyYW0gb25Mb2FkQ2FsbGJhY2sgQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgdHJpZ2dlcmVkIHdoZW4gdGhpcyBHcmFwaGljcyBpcyBsb2FkZWQgYW5kIHJlYWR5IHRvIHVzZS5cbiAqL1xuZnVuY3Rpb24gR3JhcGhpY3Mob25Mb2FkQ2FsbGJhY2spIHtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHcmFwaGljcykpIHtcbiAgICAgICAgdGhyb3cgQ29uc3RydWN0b3JFcnJvcjtcbiAgICB9XG5cbiAgICB2YXIgbWUgPSB0aGlzO1xuXG4gICAgdGhpcy5USUxFX1NJWkUgPSBuZXcgUG9pbnQoMTYsIDMyKTtcbiAgICB0aGlzLlNQUklURV9TSVpFID0gbmV3IFBvaW50KDgsIDE2KTtcblxuICAgIHRoaXMuREFSS19JTUFHRSA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLk5PSVNFX0lNQUdFID0gdW5kZWZpbmVkO1xuXG4gICAgdGhpcy5ibGlua0N5Y2xlID0gMDtcbiAgICB0aGlzLmJsaW5rU3RhdGUgPSB0cnVlO1xuXG4gICAgdGhpcy5zcHJpdGVzID0gW107XG4gICAgdGhpcy5zcHJpdGVTb3VyY2UgPSBuZXcgSW1hZ2UoKTtcbiAgICB0aGlzLnNwcml0ZVNvdXJjZS5zcmMgPSBTUFJJVEVfREFUQTtcbiAgICB0aGlzLmNvbG9yU3ByaXRlU291cmNlcyA9IFtdO1xuICAgIHRoaXMub25Mb2FkQ2FsbGJhY2sgPSBvbkxvYWRDYWxsYmFjaztcblxuICAgIC8vIEEgZnVuY3Rpb24gdG8gZmluaXNoIGluaXRpYWxpemF0aW9uIG9uY2Ugb3VyIHNwcml0ZSBzb3VyY2UgaGFzIGJlZW4gZnVsbHkgbG9hZGVkXG4gICAgdGhpcy5zcHJpdGVTb3VyY2Uub25sb2FkID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBidWZmZXIsXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgcGl4ZWxDb3VudCxcbiAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgaW1hZ2VEYXRhLFxuICAgICAgICAgICAgcmdiYSxcbiAgICAgICAgICAgIHBpeGVsLFxuICAgICAgICAgICAgdGlsZXNQZXJSb3csXG4gICAgICAgICAgICB0aWxlc1BlckNvbHVtbixcbiAgICAgICAgICAgIHJvdyxcbiAgICAgICAgICAgIGNvbHVtbixcbiAgICAgICAgICAgIHNwcml0ZVBvaW50LFxuICAgICAgICAgICAgc3ByaXRlO1xuXG4gICAgICAgIC8vIENyZWF0ZSBvZmZzY3JlZW4gY2FudmFzZXNcbiAgICAgICAgZm9yIChjb2xvciBpbiBjb2xvcnMpIHtcbiAgICAgICAgICAgIGlmIChjb2xvcnMuaGFzT3duUHJvcGVydHkoY29sb3IpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBidWZmZXIgdG8gc3RvcmUgb3VyIHNwcml0ZSBncmFwaGljc1xuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgICAgIGJ1ZmZlci53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgICAgICAgICAgYnVmZmVyLmhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgLy8gV2Ugd2lsbCBjcmVhdGUgYSB2ZXJzaW9uIG9mIG91ciBzcHJpdGUgZm9yIGVhY2ggZm9yZWdyb3VuZCBjb2xvclxuICAgICAgICAgICAgICAgIG1lLmNvbG9yU3ByaXRlU291cmNlc1tjb2xvcl0gPSBidWZmZXI7XG5cbiAgICAgICAgICAgICAgICAvLyBHcmFiIG91ciAyRCBjb250ZXh0XG4gICAgICAgICAgICAgICAgY29udGV4dCA9IGJ1ZmZlci5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgICAgICAgICAgLy8gRWFjaCBwaXhlbCBoYXMgYW4gQVJHQiB2YWx1ZVxuICAgICAgICAgICAgICAgIHBpeGVsQ291bnQgPSB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQgKiA0O1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IG91ciBjb2xvclxuICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3JzW2NvbG9yXTtcblxuICAgICAgICAgICAgICAgIC8vIERyYXcgdGhlIGJsYWNrIGFuZCB3aGl0ZSBpbWFnZSBmaXJzdFxuICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRoaXMsIDAsIDApO1xuXG4gICAgICAgICAgICAgICAgLy8gR3JhYiB0aGUgcmF3IGltYWdlIGRhdGFcbiAgICAgICAgICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgcmdiYSA9IGltYWdlRGF0YS5kYXRhO1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggb2Ygb3VyIHBpeGVscy4uLlxuICAgICAgICAgICAgICAgIGZvciAocGl4ZWwgPSAwOyBwaXhlbCA8IHBpeGVsQ291bnQ7IHBpeGVsICs9IDQpIHtcblxuICAgICAgICAgICAgICAgICAgICAvKiBGb3IgYSBibGFjayBhbmQgd2hpdGUgaW1hZ2UsIHdlIG9ubHkgbmVlZCB0byB0ZXN0IG9uZSBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICogdmFsdWVzIHRvIGRldGVybWluZSBpZiB3ZSBuZWVkIHRvIHdyaXRlIGEgY29sb3Igb3IgYSB0cmFuc3BhcmVudFxuICAgICAgICAgICAgICAgICAgICAgKiB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgZm91bmQgYW4gJ29uJyBwaXhlbFxuICAgICAgICAgICAgICAgICAgICBpZiAocmdiYVtwaXhlbF0gPj0gMjU1KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiBvdXIgbmV3IHBpeGVsIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgICAgICByZ2JhW3BpeGVsXSA9IGNvbG9yLnI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZ2JhW3BpeGVsICsgMV0gPSBjb2xvci5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmdiYVtwaXhlbCArIDJdID0gY29sb3IuYjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBpdCBjb21wbGV0ZWx5IG9wYXF1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmdiYVtwaXhlbCArIDNdID0gMjU1O1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugb3VyIHBpeGVsIGNvbXBsZXRlbHkgdHJhbnNwYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJnYmFbcGl4ZWwgKyAzXSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV3JpdGUgb3VyIGltYWdlIGRhdGEgYXQgdGhlIHNhbWUgbG9jYXRpb24gYXMgaXQgd2FzIHJlYWQgZnJvbVxuICAgICAgICAgICAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIG91ciBzcHJpdGVzXG4gICAgICAgIHRpbGVzUGVyUm93ID0gdGhpcy53aWR0aCAvIG1lLlNQUklURV9TSVpFLng7XG4gICAgICAgIHRpbGVzUGVyQ29sdW1uID0gdGhpcy5oZWlnaHQgLyBtZS5TUFJJVEVfU0laRS55O1xuXG4gICAgICAgIGZvciAocm93ID0gMDsgcm93IDwgdGlsZXNQZXJDb2x1bW47IHJvdyArPSAxKSB7XG4gICAgICAgICAgICBmb3IgKGNvbHVtbiA9IDA7IGNvbHVtbiA8IHRpbGVzUGVyUm93OyBjb2x1bW4gKz0gMSkge1xuXG4gICAgICAgICAgICAgICAgc3ByaXRlUG9pbnQgPSBuZXcgUG9pbnQoY29sdW1uICogbWUuU1BSSVRFX1NJWkUueCwgcm93ICogbWUuU1BSSVRFX1NJWkUueSk7XG4gICAgICAgICAgICAgICAgc3ByaXRlID0gbmV3IFNwcml0ZShzcHJpdGVQb2ludCwgbWUpO1xuICAgICAgICAgICAgICAgIG1lLnNwcml0ZXMucHVzaChzcHJpdGUpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDcmVhdGUgb3VyIG5vaXNlIGltYWdlXG4gICAgICAgIGJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBidWZmZXIud2lkdGggPSAyNTY7XG4gICAgICAgIGJ1ZmZlci5oZWlnaHQgPSAyNTY7XG4gICAgICAgIHBpeGVsQ291bnQgPSAyNTYgKiAyNTYgKiA0O1xuICAgICAgICBjb250ZXh0ID0gYnVmZmVyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNvbnRleHQuY2FudmFzLndpZHRoLCBjb250ZXh0LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICByZ2JhID0gaW1hZ2VEYXRhLmRhdGE7XG4gICAgICAgIGZvciAocGl4ZWwgPSAwOyBwaXhlbCA8IHBpeGVsQ291bnQ7IHBpeGVsICs9IDQpIHtcbiAgICAgICAgICAgIHJnYmFbcGl4ZWxdID0gMDtcbiAgICAgICAgICAgIHJnYmFbcGl4ZWwgKyAxXSA9IDA7XG4gICAgICAgICAgICByZ2JhW3BpeGVsICsgMl0gPSAwO1xuICAgICAgICAgICAgcmdiYVtwaXhlbCArIDNdID0gTWF0aC5yb3VuZCgyMCAqIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgICAgIG1lLk5PSVNFX0lNQUdFID0gYnVmZmVyO1xuXG4gICAgICAgIC8vIENyZWF0ZSBvdXIgZGFya25lc3MgaW1hZ2VcbiAgICAgICAgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGJ1ZmZlci53aWR0aCA9IG1lLlRJTEVfU0laRS54O1xuICAgICAgICBidWZmZXIuaGVpZ2h0ID0gbWUuVElMRV9TSVpFLnk7XG4gICAgICAgIGNvbnRleHQgPSBidWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgY29udGV4dC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgY29udGV4dC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgc3ByaXRlID0gbWUuZ2V0U3ByaXRlKDE3Nik7XG4gICAgICAgIHNwcml0ZS5kcmF3KGNvbnRleHQsIG5ldyBQb2ludCgwLCAwKSwgZXhwb3J0cy5Db2xvcnMuR3JleSwgZXhwb3J0cy5Db2xvcnMuQmxhY2spO1xuICAgICAgICBtZS5EQVJLX0lNQUdFID0gYnVmZmVyO1xuXG4gICAgICAgIC8vIE5vdyB0aGF0IGV2ZXJ5dGhpbmcgaXMgaW5pdGlhbGl6ZWQsIHRyaWdnZXIgb3VyIGxvYWQgY2FsbGJhY2tcbiAgICAgICAgbWUub25Mb2FkQ2FsbGJhY2soKTtcblxuICAgIH07XG5cbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoaXMgR3JhcGhpY3MncyBpbnN0YW5jZSdzIGJsaW5raW5nIGFuZCBjb2xvciBjeWNsZSBzdGF0ZS5cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIC8vIEluY3JlbWVudCBvdXIgYmxpbmsgY3ljbGUgY291bnRlclxuICAgIHRoaXMuYmxpbmtDeWNsZSArPSAxO1xuXG4gICAgLy8gSWYgd2UndmUgcGFzc2VkIHRoZSBibGluayByYXRlIHRocmVzaG9sZC4uLlxuICAgIGlmICh0aGlzLmJsaW5rQ3ljbGUgPiBCTElOS19SQVRFKSB7XG5cbiAgICAgICAgLy8gQWRqdXN0IG91ciBibGluayBzdGF0ZVxuICAgICAgICB0aGlzLmJsaW5rU3RhdGUgPSAhdGhpcy5ibGlua1N0YXRlO1xuXG4gICAgICAgIC8vIE91ciBjb2xvciBjeWNsZSB1c2VzIHRoZSBzYW1lIHJhdGVcbiAgICAgICAgZXhwb3J0cy5Db2xvcnMuQ3ljbGUudXBkYXRlKCk7XG5cbiAgICAgICAgLy8gUmVzZXQgdGhlIGJsaW5rIGN5Y2xlXG4gICAgICAgIHRoaXMuYmxpbmtDeWNsZSA9IDA7XG4gICAgfVxuXG59O1xuXG5HcmFwaGljcy5wcm90b3R5cGUuZmlsbFRpbGUgPSBmdW5jdGlvbiAoYywgcG9pbnQsIGNvbG9yKSB7XG5cbiAgICB2YXIgZGVzdGluYXRpb25YID0gcG9pbnQueCAqIHRoaXMuVElMRV9TSVpFLngsXG4gICAgICAgIGRlc3RpbmF0aW9uWSA9IHBvaW50LnkgKiB0aGlzLlRJTEVfU0laRS55O1xuXG4gICAgLy8gRHJhdyB0aGUgdGlsZVxuICAgIGlmIChjb2xvcikge1xuICAgICAgICBjLmZpbGxTdHlsZSA9IGNvbG9yLnJnYlZhbHVlO1xuICAgICAgICBjLmZpbGxSZWN0KGRlc3RpbmF0aW9uWCwgZGVzdGluYXRpb25ZLCB0aGlzLlRJTEVfU0laRS54LCB0aGlzLlRJTEVfU0laRS55KTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogR2V0cyBhIFNwcml0ZSBpbnN0YW5jZSBmb3IgYSBwcm92aWRlZCBDb2RlUGFnZS00MzcgY2hhcmFjdGVyIGluZGV4LlxuICpcbiAqIEBwYXJhbSBpbmRleCBBIENvZGVQYWdlLTQzNyBjaGFyYWN0ZXIgaW5kZXhcbiAqIEByZXR1cm4gQSBzcHJpdGUgcmVwcmVzZW50aW5nIGEgcHJvdmlkZWQgQ29kZVBhZ2UtNDM3IGluZGV4LlxuICovXG5HcmFwaGljcy5wcm90b3R5cGUuZ2V0U3ByaXRlID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuc3ByaXRlc1tpbmRleF07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcHJvdmlkZWQgdGV4dCBzdHJpbmcgaW50byBhbiBhcnJheSBvZiBTcHJpdGUgaW5zdGFuY2VzIHJlcHJlc2VudGluZ1xuICogQ29kZVBhZ2UtNDM3IGNoYXJhY3RlcnMuIEFueSB0ZXh0IGNoYXJhY3RlciB0aGF0IGRvZXMgbm90IGhhdmUgYW4gZXF1aXZhbGVudFxuICogQ29kZVBhZ2UtNDM3IHJlcHJlc2VudGF0aW9uIHdpbGwgYmUgcmVwcmVzZW50ZWQgYnkgYSAnPycgY2hhcmFjdGVyLlxuICpcbiAqIEBwYXJhbSB0ZXh0IEEgdGV4dCBzdHJpbmcgdG8gY29udmVydCB0byBTcHJpdGUgaW5zdGFuY2VzXG4gKiBAcmV0dXJuIEFuIGFycmF5IG9mIFNwcml0ZSBpbnN0YW5jZXNcbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLnRleHRUb1Nwcml0ZXMgPSBmdW5jdGlvbiAodGV4dCkge1xuXG4gICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgc3ByaXRlSW5kZXg7XG5cbiAgICAvLyBGb3IgZWFjaCBjaGFyYWN0ZXIgaW4gb3VyIHN0cmluZy4uLlxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRleHQubGVuZ3RoOyBpbmRleCArPSAxKSB7XG5cbiAgICAgICAgLy8gQ29udmVydCB0aGUgY2hhcmFjdGVyIGludG8gaXRzIENvZGVQYWdlLTQzNyBpbmRleFxuICAgICAgICBzcHJpdGVJbmRleCA9IHRoaXMuY29udmVydFNwZWNpYWxDaGFyYWN0ZXIodGV4dC5jaGFyQXQoaW5kZXgpKTtcblxuICAgICAgICAvLyBQdXNoIHRoZSByZXN1bHRpbmcgU3ByaXRlIG9udG8gb3VyIHJlc3VsdFxuICAgICAgICByZXN1bHQucHVzaCh0aGlzLmdldFNwcml0ZShzcHJpdGVJbmRleCkpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcblxufTtcblxuLyoqXG4gKiBEcmF3cyBhIHByb3ZpZGVkIHRleHQgc3RyaW5nIHRvIGEgcHJvdmlkZWQgZ3JhcGhpY3MgY29udGV4dCBhdCBhIHByb3ZpZGVkIFBvaW50IHVzaW5nIGFcbiAqIHByb3ZpZGVkIGJhY2tncm91bmQgYW5kIGZvcmVncm91bmQgY29sb3IuXG4gKlxuICogQHBhcmFtIGNvbnRleHQgQSAyRCBncmFwaGljcyBjb250ZXh0IG9udG8gd2hpY2ggdG8gZHJhdyBvdXIgc3RyaW5nXG4gKiBAcGFyYW0gcG9pbnQgQSBQb2ludCBpbnN0YW5jZSByZXByZXNlbnRpbmcgWCxZIGNvb3JkaW5hdGVzIChpbiBzcHJpdGUgYmxvY2tzKSB3aGVyZSB0byBkcmF3XG4gKiBAcGFyYW0gdGV4dCBBIHRleHQgc3RyaW5nIHRvIGRyYXcsIHJlcHJlc2VudGVkIGFzIFNwcml0ZXNcbiAqIEBwYXJhbSBmb3JlZ3JvdW5kIEEgZm9yZWdyb3VuZCBDb2xvci5cbiAqIEBwYXJhbSBiYWNrZ3JvdW5kIEEgYmFja2dyb3VuZCBDb2xvci5cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLmRyYXdTdHJpbmcgPSBmdW5jdGlvbiAoY29udGV4dCwgcG9pbnQsIHRleHQsIGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcbiAgICB0aGlzLmRyYXdTcHJpdGVzKGNvbnRleHQsIHBvaW50LCB0aGlzLnRleHRUb1Nwcml0ZXModGV4dCksIGZvcmVncm91bmQsIGJhY2tncm91bmQpO1xufTtcblxuLyoqXG4gKiBEcmF3cyBhIHByb3ZpZGVkIGFycmF5IG9mIFNwcml0ZSBpbnN0YW5jZXMgdG8gYSBnaXZlbiBQb2ludCBvbiBhIHByb3ZpZGVkIDJEIGdyYXBoaWNzIGNvbnRleHRcbiAqIHVzaW5nIGEgcHJvdmlkZWQgZm9yZWdyb3VuZCBhbmQgYmFja2dyb3VuZCBjb2xvci5cbiAqXG4gKiBAcGFyYW0gY29udGV4dCBBIDJEIGdyYXBoaWNzIGNvbnRleHQgb250byB3aGljaCB0byBkcmF3IG91ciBzcHJpdGVzXG4gKiBAcGFyYW0gcG9pbnQgQSBQb2ludCBpbnN0YW5jZSByZXByZXNlbnRpbmcgWCxZIGNvb3JkaW5hdGVzIChpbiBzcHJpdGUgYmxvY2tzKSB3aGVyZSB0byBkcmF3XG4gKiBAcGFyYW0gc3ByaXRlcyBBbiBhcnJheSBvZiBTcHJpdGUgaW5zdGFuY2VzXG4gKiBAcGFyYW0gZm9yZWdyb3VuZCBBIGZvcmVncm91bmQgQ29sb3IuXG4gKiBAcGFyYW0gYmFja2dyb3VuZCBBIGJhY2tncm91bmQgQ29sb3IuXG4gKi9cbkdyYXBoaWNzLnByb3RvdHlwZS5kcmF3U3ByaXRlcyA9IGZ1bmN0aW9uIChjb250ZXh0LCBwb2ludCwgc3ByaXRlcywgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCkge1xuICAgIHZhciBzcHJpdGUsXG4gICAgICAgIGluZGV4O1xuXG4gICAgcG9pbnQgPSBwb2ludC5jbG9uZSgpO1xuICAgIGZvcmVncm91bmQgPSBmb3JlZ3JvdW5kIHx8IGNvbG9ycy5ZZWxsb3c7XG4gICAgYmFja2dyb3VuZCA9IGJhY2tncm91bmQgfHwgdW5kZWZpbmVkO1xuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHNwcml0ZXMubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgIHNwcml0ZSA9IHNwcml0ZXNbaW5kZXhdO1xuICAgICAgICBzcHJpdGUuZHJhdyhjb250ZXh0LCBwb2ludCwgZm9yZWdyb3VuZCwgYmFja2dyb3VuZCk7XG4gICAgICAgIHBvaW50LnggKz0gMTtcbiAgICB9XG59O1xuXG5HcmFwaGljcy5jaGFyYWN0ZXJUYWJsZSA9IHtcbiAgICAnXFx1MjM2QSc6IDEsICAgLy8g4pi6IEhhcHB5IEZhY2VcbiAgICAnXFx1MjYzQic6IDIsICAgLy8g4pi7IEJsYWNrIGhhcHB5IGZhY2VcbiAgICAnXFx1MjY2NSc6IDMsICAgLy8g4pmlIEhlYXJ0IFN1aXRcbiAgICAnXFx1MjY2Nic6IDQsICAgLy8g4pmmIERpYW1vbmQgU3VpdFxuICAgICdcXHUyNjYzJzogNSwgICAvLyDimaMgQ2x1YiBTdWl0XG4gICAgJ1xcdTI2NjAnOiA2LCAgIC8vIOKZoCBTcGFkZSBTdWl0XG4gICAgJ1xcdTIwMjInOiA3LCAgIC8vIOKAoiBCdWxsZXRcbiAgICAnXFx1MjVEOCc6IDgsICAgLy8g4peYIEludmVyc2UgQnVsbGV0XG4gICAgJ1xcdTI1Q0InOiA5LCAgIC8vIOKXiyBXaGl0ZSBDaXJjbGVcbiAgICAnXFx1MjVEOSc6IDEwLCAgLy8g4peZIEludmVyc2UgV2hpdGUgQ2lyY2xlXG4gICAgJ1xcdTI2NDInOiAxMSwgIC8vIOKZgiBNYWxlIFNpZ25cbiAgICAnXFx1MjY0MCc6IDEyLCAgLy8g4pmAIEZlbWFsZSBTaWduXG4gICAgJ1xcdTI2NkEnOiAxMywgIC8vIOKZqiBFaWdodGggTm90ZVxuICAgICdcXHUyNjZCJzogMTQsICAvLyDimasgQmVhbWVkIEVpZ2h0aCBOb3Rlc1xuICAgICdcXHUyNjNDJzogMTUsICAvLyDimLwgV2hpdGUgU3VuIFdpdGggUmF5c1xuICAgICdcXHUyNUJBJzogMTYsICAvLyDilrogQmxhY2sgUmlnaHQtUG9pbnRpbmcgUG9pbnRlclxuICAgICdcXHUyNUM0JzogMTcsICAvLyDil4QgQmxhY2sgTGVmdC1Qb2ludGluZyBQb2ludGVyXG4gICAgJ1xcdTIxOTUnOiAxOCwgIC8vIOKGlSBVcCBEb3duIEFycm93XG4gICAgJ1xcdTIwM0MnOiAxOSwgIC8vIOKAvCBEb3VibGUgRXhjbGFtYXRpb24gTWFya1xuICAgICdcXHUwMEI2JzogMjAsICAvLyDCtiBQaWxjcm93IFNpZ25cbiAgICAnXFx1MDBBNyc6IDIxLCAgLy8gwqcgU2VjdGlvbiBTaWduXG4gICAgJ1xcdTI1QUMnOiAyMiwgIC8vIOKWrCBCbGFjayBSZWN0YW5nbGVcbiAgICAnXFx1MjE4QSc6IDIzLCAgLy8g4oaoIFVwIERvd24gQXJyb3cgV2l0aCBCYXNlXG4gICAgJ1xcdTIxOTEnOiAyNCwgIC8vIOKGkSBVcHdhcmRzIEFycm93XG4gICAgJ1xcdTIxOTMnOiAyNSwgIC8vIOKGkyBEb3dud2FyZHMgQXJyb3dcbiAgICAnXFx1MjE5Mic6IDI2LCAgLy8g4oaSIFJpZ2h0d2FyZHMgQXJyb3dcbiAgICAnXFx1MjE5MCc6IDI3LCAgLy8g4oaQIExlZnR3YXJkcyBBcnJvd1xuICAgICdcXHUyMjFGJzogMjgsICAvLyDiiJ8gUmlnaHQgQW5nbGVcbiAgICAnXFx1MjE5NCc6IDI5LCAgLy8g4oaUIExlZnQgUmlnaHQgQXJyb3dcbiAgICAnXFx1MjVCMic6IDMwLCAgLy8g4payIEJsYWNrIFVwLVBvaW50aW5nIFRyaWFuZ2xlXG4gICAgJ1xcdTI1QkMnOiAzMSwgIC8vIOKWvCBCbGFjayBEb3duLVBvaW50aW5nIFRyaWFuZ2xlXG4gICAgJ1xcdTIzMDMnOiAxMjcsIC8vIOKMgiBIb3VzZVxuICAgICdcXHUwMEM3JzogMTI4LCAvLyDDhyBDYXBpdGFsIEMgQ2VkaWxsYVxuICAgICdcXHUwMEZDJzogMTI5LCAvLyDDvCBTbWFsbCB1IERpYWVyZXNpc1xuICAgICdcXHUwMEU5JzogMTMwLCAvLyBlIFNtYWxsIGUgQWN1dGVcbiAgICAnXFx1MDBFMic6IDEzMSwgLy8gw6IgU21hbGwgYSBDaXJjdW1mbGV4XG4gICAgJ1xcdTAwRTQnOiAxMzIsIC8vIMOkIFNtYWxsIGEgRGlhZXJlc2lzXG4gICAgJ1xcdTAwRTAnOiAxMzMsIC8vIMOgIFNtYWxsIGEgR3JhdmVcbiAgICAnXFx1MDBFNSc6IDEzNCwgLy8gw6UgU21hbGwgYSBSaW5nXG4gICAgJ1xcdTAwRTcnOiAxMzUsIC8vIMOnIFNtYWxsIGMgQ2VkaWxsYVxuICAgICdcXHUwMEVBJzogMTM2LCAvLyDDqiBTbWFsbCBlIENpcmN1bWZsZXhcbiAgICAnXFx1MDBFQic6IDEzNywgLy8gw6sgU21hbGwgZSBEaWFlcmVzaXNcbiAgICAnXFx1MDBFOCc6IDEzOCwgLy8gw6ggU21hbGwgZSBHcmF2ZVxuICAgICdcXHUwMEVGJzogMTM5LCAvLyDDryBTbWFsbCB1IERpYWVyZXNpc1xuICAgICdcXHUwMEVFJzogMTQwLCAvLyDDriBTbWFsbCBpIENpcmN1bWZsZXhcbiAgICAnXFx1MDBFQyc6IDE0MSwgLy8gw6wgU21hbGwgaSBHcmF2ZVxuICAgICdcXHUwMEM0JzogMTQyLCAvLyDDhCBDYXBpdGFsIEEgRGlhZXJlc2lzXG4gICAgJ1xcdTAwQzUnOiAxNDMsIC8vIMOFIENhcGl0YWwgQSBSaW5nXG4gICAgJ1xcdTAwQzknOiAxNDQsIC8vIMOJIENhcGl0YWwgRSBBY3V0ZVxuICAgICdcXHUwMEU2JzogMTQ1LCAvLyDDpiBTbWFsbCBBRVxuICAgICdcXHUwMEM2JzogMTQ2LCAvLyDDhiBDYXBpdGFsIEFFXG4gICAgJ1xcdTAwRjQnOiAxNDcsIC8vIMO0IFNtYWxsIG8gQ2lyY3VtZmxleFxuICAgICdcXHUwMEY2JzogMTQ4LCAvLyDDtiBTbWFsbCBvIERpYWVyZXNpc1xuICAgICdcXHUwMEYyJzogMTQ5LCAvLyDDsiBTbWFsbCBvIEdyYXZlXG4gICAgJ1xcdTAwRkInOiAxNTAsIC8vIMO7IFNtYWxsIHUgQ2lyY3VtZmxleFxuICAgICdcXHUwMEY5JzogMTUxLCAvLyDDuSBTbWFsbCB1IEdyYXZlXG4gICAgJ1xcdTAwRkYnOiAxNTIsIC8vIMO/IFNtYWxsIHkgRGlhZXJlc2lzXG4gICAgJ1xcdTAwRDYnOiAxNTMsIC8vIMOWIENhcGl0YWwgTyBEaWFlcmVzaXNcbiAgICAnXFx1MDBEQyc6IDE1NCwgLy8gw5wgQ2FwaXRhbCBVIERpYWVyZXNpc1xuICAgICdcXHUwMEEyJzogMTU1LCAvLyDCoiBDZW50IFNpZ25cbiAgICAnXFx1MDBBMyc6IDE1NiwgLy8gwqMgUG91bmQgU2lnblxuICAgICdcXHUwMEE1JzogMTU3LCAvLyDCpSBZZW4gU2lnblxuICAgICdcXHUyMEE3JzogMTU4LCAvLyDigqcgUGVzZXRhIFNpZ25cbiAgICAnXFx1MDE5Mic6IDE1OSwgLy8gxpIgU21hbGwgZiB3aXRoIEhvb2tcbiAgICAnXFx1MDBFMSc6IDE2MCwgLy8gw6EgU21hbGwgYSBBY3V0ZVxuICAgICdcXHUwMEVEJzogMTYxLCAvLyDDrSBTbWFsbCBpIEFjdXRlXG4gICAgJ1xcdTAwRjMnOiAxNjIsIC8vIMOzIFNtYWxsIG8gQWN1dGVcbiAgICAnXFx1MDBGQSc6IDE2MywgLy8gw7ogU21hbGwgdSBBY3V0ZVxuICAgICdcXHUwMEYxJzogMTY0LCAvLyDDsSBTbWFsbCBuIFRpbGRlXG4gICAgJ1xcdTAwRDEnOiAxNjUsIC8vIMORIENhcGl0YWwgTiBUaWxkZVxuICAgICdcXHUwMEFBJzogMTY2LCAvLyDCqiBGZW1pbmluZSBPcmRpbmFsIEluZGljYXRvclxuICAgICdcXHUwMEJBJzogMTY3LCAvLyDCuiBNYXNjdWxpbmUgT3JkaW5hbCBJbmRpY2F0b3JcbiAgICAnXFx1MDBCRic6IDE2OCwgLy8gwr8gSW52ZXJ0ZWQgUXVlc3Rpb24gTWFya1xuICAgICdcXHUyMzEwJzogMTY5LCAvLyDijJAgUmV2ZXJzZWQgTm90IFNpZ25cbiAgICAnXFx1MDBBQyc6IDE3MCwgLy8gwqwgTm90IFNpZ25cbiAgICAnXFx1MDBCRCc6IDE3MSwgLy8gwr0gVnVsZ2FyIEZyYWN0aW9uIE9uZSBIYWxmXG4gICAgJ1xcdTAwQkMnOiAxNzIsIC8vIMK8IFZ1bGdhciBGcmFjdGlvbiBPbmUgUXVhcnRlclxuICAgICdcXHUwMEExJzogMTczLCAvLyDCoSBJbnZlcnRlZCBFeGNsYW1hdGlvbiBNYXJrXG4gICAgJ1xcdTAwQUInOiAxNzQsIC8vIMKrIExlZnQgUG9pbnRpbmcgRG91YmxlIEFuZ2xlIFF1b3RhdGlvbiBNYXJrXG4gICAgJ1xcdTAwQkInOiAxNzUsIC8vIMK7IFJpZ2h0IFBvaW50aW5nIERvdWJsZSBBbmdsZSBRdW90YXRpb24gTWFya1xuICAgICdcXHUyNTkxJzogMTc2LCAvLyDilpEgTGlnaHQgU2hhZGVcbiAgICAnXFx1MjU5Mic6IDE3NywgLy8g4paSIE1lZGl1bSBTaGFkZVxuICAgICdcXHUyNTkzJzogMTc4LCAvLyDilpMgRGFyayBTaGFkZVxuICAgICdcXHUyNTAyJzogMTc5LCAvLyDilIIgQm94IERyYXdpbmcgTGlnaHQgVmVydGljYWxcbiAgICAnXFx1MjUyNCc6IDE4MCwgLy8g4pSkIEJveCBEcmF3aW5nIExpZ2h0IFZlcnRpY2FsIExlZnRcbiAgICAnXFx1MjU2MSc6IDE4MSwgLy8g4pWhIEJveCBEcmF3aW5nIFZlcnRpY2FsIFNpbmdsZSBMZWZ0IERvdWJsZVxuICAgICdcXHUyNTYyJzogMTgyLCAvLyDilaIgQm94IERyYXdpbmcgVmVydGljYWwgRG91YmxlIExlZnQgU2luZ2xlXG4gICAgJ1xcdTI1NTYnOiAxODMsIC8vIOKVliBCb3ggRHJhd2luZyBEb3duIERvdWJsZSBMZWZ0IFNpbmdsZVxuICAgICdcXHUyNTU1JzogMTg0LCAvLyDilZUgQm94IERyYXdpbmcgRG93biBTaW5nbGUgTGVmdCBEb3VibGVcbiAgICAnXFx1MjU2Myc6IDE4NSwgLy8g4pWjIEJveCBEcmF3aW5nIFZlcnRpY2FsIERvdWJsZSBMZWZ0IERvdWJsZVxuICAgICdcXHUyNTUxJzogMTg2LCAvLyDilZEgQm94IERyYXdpbmcgVmVydGljYWwgRG91YmxlXG4gICAgJ1xcdTI1NTcnOiAxODcsIC8vIOKVlyBCb3ggRHJhd2luZyBEb3duIERvdWJsZSBMZWZ0IERvdWJsZVxuICAgICdcXHUyNTVEJzogMTg4LCAvLyDilZ0gQm94IERyYXdpbmcgVXAgRG91YmxlIExlZnQgRG91YmxlXG4gICAgJ1xcdTI1NUMnOiAxODksIC8vIOKVnCBCb3ggRHJhd2luZyBVcCBEb3VibGUgTGVmdCBTaW5nbGVcbiAgICAnXFx1MjU1Qic6IDE5MCwgLy8g4pWbIEJveCBEcmF3aW5nIFVwIFNpbmdsZSBMZWZ0IERvdWJsZVxuICAgICdcXHUyNTEwJzogMTkxLCAvLyDilJAgQm94IERyYXdpbmcgRG93biBTaW5nbGUgTGVmdCBTaW5nbGVcbiAgICAnXFx1MjUxNCc6IDE5MiwgLy8g4pSUIEJveCBEcmF3aW5nIFVwIFNpbmdsZSBSaWdodCBTaW5nbGVcbiAgICAnXFx1MjUzNCc6IDE5MywgLy8g4pS0IEJveCBEcmF3aW5nIEhvcml6b250YWwgU2luZ2xlIFVwIFNpbmdsZVxuICAgICdcXHUyNTJDJzogMTk0LCAvLyDilKwgQm94IERyYXdpbmcgSG9yaXpvbnRhbCBTaW5nbGUgRG93biBTaW5nbGVcbiAgICAnXFx1MjUxQyc6IDE5NSwgLy8g4pScIEJveCBEcmF3aW5nIFZlcnRpY2FsIFNpbmdsZSBSaWdodCBTaW5nbGVcbiAgICAnXFx1MjUwMCc6IDE5NiwgLy8g4pSAIEJveCBEcmF3aW5nIExpZ2h0IEhvcml6b250YWxcbiAgICAnXFx1MjUzQyc6IDE5NywgLy8g4pS8IEJveCBEcmF3aW5nIExpZ2h0IEhvcml6b250YWwgVmVydGljYWxcbiAgICAnXFx1MjU1RSc6IDE5OCwgLy8g4pWeIEJveCBEcmF3aW5nIFZlcnRpY2FsIFNpbmdsZSBSaWdodCBEb3VibGVcbiAgICAnXFx1MjU1Ric6IDE5OSwgLy8g4pWfIEJveCBEcmF3aW5nIFZlcnRpY2FsIERvdWJsZSBSaWdodCBTaW5nbGVcbiAgICAnXFx1MjU1QSc6IDIwMCwgLy8g4pWaIEJveCBEcmF3aW5nIFVwIERvdWJsZSBSaWdodCBEb3VibGVcbiAgICAnXFx1MjU1NCc6IDIwMSwgLy8g4pWUIEJveCBEcmF3aW5nIERvd24gRG91YmxlIFJpZ2h0IERvdWJsZVxuICAgICdcXHUyNTY5JzogMjAyLCAvLyDilakgQm94IERyYXdpbmcgRG91YmxlIEhvcml6b250YWwgVXAgRG91YmxlXG4gICAgJ1xcdTI1NjYnOiAyMDMsIC8vIOKVpiBCb3ggRHJhd2luZyBEb3VibGUgSG9yaXpvbnRhbCBEb3duIERvdWJsZVxuICAgICdcXHUyNTYwJzogMjA0LCAvLyDilaAgQm94IERyYXdpbmcgRG91YmxlIFZlcnRpY2FsIERvdWJsZSBSaWdodFxuICAgICdcXHUyNTUwJzogMjA1LCAvLyDilZAgQm94IERyYXdpbmcgRG91YmxlIEhvcml6b250YWxcbiAgICAnXFx1MjU2Qyc6IDIwNiwgLy8g4pWsIEJveCBEcmF3aW5nIERvdWJsZSBIb3Jpem9udGFsIERvdWJsZSBWZXJ0aWNhbFxuICAgICdcXHUyNTY3JzogMjA3LCAvLyDilacgQm94IERyYXdpbmcgRG91YmxlIEhvcml6b250YWwgU2luZ2xlIFVwXG4gICAgJ1xcdTI1NjgnOiAyMDgsIC8vIOKVqCBCb3ggRHJhd2luZyBTaW5nbGUgSG9yaXpvbnRhbCBEb3VibGUgVXBcbiAgICAnXFx1MjU2NCc6IDIwOSwgLy8g4pWkIEJveCBEcmF3aW5nIERvdWJsZSBIb3Jpem9udGFsIFNpbmdsZSBEb3duXG4gICAgJ1xcdTI1NjUnOiAyMTAsIC8vIOKVpSBCb3ggRHJhd2luZyBTaW5nbGUgSG9yaXpvbnRhbCBEb3VibGUgRG93blxuICAgICdcXHUyNTU5JzogMjExLCAvLyDilZkgQm94IERyYXdpbmcgRG91YmxlIFVwIFNpbmdsZSBSaWdodFxuICAgICdcXHUyNTU4JzogMjEyLCAvLyDilZggQm94IERyYXdpbmcgU2luZ2xlIFVwIERvdWJsZSBSaWdodFxuICAgICdcXHUyNTUyJzogMjEzLCAvLyDilZIgQm94IERyYXdpbmcgU2luZ2xlIERvd24gRG91YmxlIFJpZ2h0XG4gICAgJ1xcdTI1NTMnOiAyMTQsIC8vIOKVkyBCb3ggRHJhd2luZyBEb3VibGUgRG93biBTaW5nbGUgUmlnaHRcbiAgICAnXFx1MjU2Qic6IDIxNSwgLy8g4pWrIEJveCBEcmF3aW5nIERvdWJsZSBWZXJ0aWNhbCBTaW5nbGUgSG9yaXpvbnRhbFxuICAgICdcXHUyNTZBJzogMjE2LCAvLyDilaogQm94IERyYXdpbmcgU2luZ2xlIFZlcnRpY2FsIERvdWJsZSBIb3Jpem9udGFsXG4gICAgJ1xcdTI1MTgnOiAyMTcsIC8vIOKUmCBCb3ggRHJhd2luZyBTaW5nbGUgVXAgU2luZ2xlIExlZnRcbiAgICAnXFx1MjUwQyc6IDIxOCwgLy8g4pSMIEJveCBEcmF3aW5nIFNpbmdsZSBEb3duIFNpbmdsZSBSaWdodFxuICAgICdcXHUyNTg4JzogMjE5LCAvLyDiloggRnVsbCBCbG9ja1xuICAgICdcXHUyNTg0JzogMjIwLCAvLyDiloQgTG93ZXIgSGFsZiBCbG9ja1xuICAgICdcXHUyNThDJzogMjIxLCAvLyDilowgTGVmdCBIYWxmIEJsb2NrXG4gICAgJ1xcdTI1OTAnOiAyMjIsIC8vIOKWkCBSaWdodCBIYWxmIEJsb2NrXG4gICAgJ1xcdTI1ODAnOiAyMjMsIC8vIOKWgCBVcHBlciBIYWxmIEJsb2NrXG4gICAgJ1xcdTAzQjEnOiAyMjQsIC8vIM6xIEdyZWVrIFNtYWxsIEFscGhhXG4gICAgJ1xcdTAwREYnOiAyMjUsIC8vIMOfIEdyZWVrIENhcGl0YWwgQmV0YVxuICAgICdcXHUwMzkzJzogMjI2LCAvLyDOkyBHcmVlayBDYXBpdGFsIEdhbW1hXG4gICAgJ1xcdTAzQzAnOiAyMjcsIC8vIM+AIEdyZWVrIFNtYWxsIFBpXG4gICAgJ1xcdTAzQTMnOiAyMjgsIC8vIM6jIEdyZWVrIENhcGl0YWwgU2lnbWFcbiAgICAnXFx1MDNDMyc6IDIyOSwgLy8gz4MgR3JlZWsgU21hbGwgU2lnbWFcbiAgICAnXFx1MDBCNSc6IDIzMCwgLy8gwrUgTWljcm8gU2lnblxuICAgICdcXHUwM0M0JzogMjMxLCAvLyDPhCBHcmVlayBTbWFsbCBUYXVcbiAgICAnXFx1MDNBNic6IDIzMiwgLy8gzqYgR3JlZWsgQ2FwaXRhbCBQaGlcbiAgICAnXFx1MDM5OCc6IDIzMywgLy8gzpggR3JlZWsgQ2FwaXRhbCBUaGV0YVxuICAgICdcXHUwM0E5JzogMjM0LCAvLyDOqSBHcmVlayBDYXBpdGFsIE9tZWdhXG4gICAgJ1xcdTAzQjQnOiAyMzUsIC8vIM60IEdyZWVrIFNtYWxsIERlbHRhXG4gICAgJ1xcdTIyMUUnOiAyMzYsIC8vIOKIniBJbmZpbml0eVxuICAgICdcXHUwM0M2JzogMjM3LCAvLyBHcmVlayBTbWFsbCBQaGlcbiAgICAnXFx1MDNCNSc6IDIzOCwgLy8gR3JlZWsgU21hbGwgRXBzaWxvblxuICAgICdcXHUyMjI5JzogMjM5LCAvLyDiiKkgSW50ZXJzZWN0aW9uXG4gICAgJ1xcdTIyNjEnOiAyNDAsIC8vIOKJoSBJZGVudGljYWwgVG9cbiAgICAnXFx1MDBCMSc6IDI0MSwgLy8gwrEgUGx1cyBNaW51cyBTaWduXG4gICAgJ1xcdTIyNjUnOiAyNDIsIC8vIOKJpSBHcmVhdGVyIFRoYW4gT3IgRXF1YWwgVG9cbiAgICAnXFx1MjI2NCc6IDI0MywgLy8g4omkIExlc3MgVGhhbiBPciBFcXVhbCBUb1xuICAgICdcXHUyMzIwJzogMjQ0LCAvLyDijKAgVG9wIEhhbGYgSW50ZWdyYWxcbiAgICAnXFx1MjMyMSc6IDI0NSwgLy8g4oyhIEJvdHRvbSBIYWxmIEludGVncmFsXG4gICAgJ1xcdTAwRjcnOiAyNDYsIC8vIMO3IERpdmlzaW9uXG4gICAgJ1xcdTIyNDgnOiAyNDcsIC8vIOKJiCBBbG1vc3QgRXF1YWwgVG9cbiAgICAnXFx1MDBCMCc6IDI0OCwgLy8gwrAgRGVncmVlc1xuICAgICdcXHUyMjE5JzogMjQ5LCAvLyDiiJkgQnVsbGV0IE9wZXJhdG9yXG4gICAgJ1xcdTAwQjcnOiAyNTAsIC8vIMK3IE1pZGRsZSBEb3RcbiAgICAnXFx1MjIxQSc6IDI1MSwgLy8g4oiaIFNxdWFyZSBSb290XG4gICAgJ1xcdTIwN0YnOiAyNTIsIC8vIOKBvyBTdXBlcnNjcmlwdCBMYXRpbiBTbWFsbCBuXG4gICAgJ1xcdTAwQjInOiAyNTMsIC8vIMKyIFNxdWFyZWRcbiAgICAnXFx1MjVBMCc6IDI1NCAgLy8g4pagIEJsYWNrIFNxdWFyZVxufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHByb3ZpZGVkIHNwZWNpYWwgY2hhcmFjdGVyIGludG8gaXRzIEFOU0kgZXF1aXZhbGVudC5cbiAqXG4gKiBAcGFyYW0gY2hhcmFjdGVyIEEgVW5pY29kZSBjaGFyYWN0ZXJcbiAqIEByZXR1cm4gQW4gQU5TSSBjaGFyYWN0ZXIgY29kZS5cbiAqL1xuR3JhcGhpY3MucHJvdG90eXBlLmNvbnZlcnRTcGVjaWFsQ2hhcmFjdGVyID0gZnVuY3Rpb24gKGNoYXJhY3Rlcikge1xuXG4gICAgLy8gR2V0IG91ciBjaGFyIGNvZGVcbiAgICB2YXIgY2hhcmFjdGVyQ29kZSA9IGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIGNoYXJhY3RlciBtYXBwaW5nIGlzbid0IG5lY2Vzc2FyeVxuICAgIGlmIChjaGFyYWN0ZXJDb2RlID49IDMyICYmIGNoYXJhY3RlckNvZGUgPD0gMTI2KSB7XG4gICAgICAgIHJldHVybiBjaGFyYWN0ZXJDb2RlO1xuICAgIH1cblxuICAgIC8vIE1hcHBpbmcgaXMgbmVjZXNzYXJ5LCBidXQgZG8gd2UgaGF2ZSBhIG1hcHBpbmcgZm9yIHRoaXMgY2hhcmFjdGVyP1xuICAgIGlmIChHcmFwaGljcy5jaGFyYWN0ZXJUYWJsZS5oYXNPd25Qcm9wZXJ0eShjaGFyYWN0ZXIpKSB7XG4gICAgICAgIHJldHVybiBHcmFwaGljcy5jaGFyYWN0ZXJUYWJsZVtjaGFyYWN0ZXJdO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmVuJ3QgbWFwcGVkLCByZXR1cm4gYSBxdWVzdGlvbiBtYXJrLlxuICAgIHJldHVybiA2MztcblxufTtcblxuLyoqXG4gKiBTcHJpdGVHcmlkIHJlcHJlc2VudHMgYSBibG9jayBvZiByZW5kZXJhYmxlIHNwcml0ZXMgZGVmaW5lZCB3aXRoIHRoZWlyIGNvbG91cnMuXG4gKlxuICogQHBhcmFtIHdpZHRoIEEgd2lkdGggZm9yIHRoaXMgc3ByaXRlIGdyaWRcbiAqIEBwYXJhbSBoZWlnaHQgQSBoZWlnaHQgZm9yIHRoaXMgc3ByaXRlIGdyaWRcbiAqIEBwYXJhbSBncmFwaGljcyBhIEdyYXBoaWNzIGluc3RhbmNlIHRvIG93biB0aGlzIFNwcml0ZUdyaWRcbiAqL1xuZnVuY3Rpb24gU3ByaXRlR3JpZCh3aWR0aCwgaGVpZ2h0LCBncmFwaGljcykge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNwcml0ZUdyaWQpKSB7XG4gICAgICAgIHRocm93IENvbnN0cnVjdG9yRXJyb3I7XG4gICAgfVxuXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuZ3JhcGhpY3MgPSBncmFwaGljcztcbiAgICB0aGlzLnRpbGVzID0gW107XG59XG5cbi8qKlxuICogQXNzaWducyBhIHRpbGUgdG8gdGhpcyBTcHJpdGVHcmlkIGF0IGEgcHJvdmlkZWQgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHBvaW50IGEgUG9pbnQgdG8gd2hpY2ggdG8gYXNzaWduIGEgc3ByaXRlXG4gKiBAcGFyYW0gc3ByaXRlSW5kZXggYSBzcHJpdGUgaW5kZXhcbiAqIEBwYXJhbSBmb3JlZ3JvdW5kIGEgZm9yZWdyb3VuZCBDb2xvclxuICogQHBhcmFtIGJhY2tncm91bmQgYSBiYWNrZ3JvdW5kIENvbG9yXG4gKi9cblNwcml0ZUdyaWQucHJvdG90eXBlLnNldFRpbGUgPSBmdW5jdGlvbiAocG9pbnQsIHNwcml0ZUluZGV4LCBmb3JlZ3JvdW5kLCBiYWNrZ3JvdW5kKSB7XG5cbiAgICB0aGlzLnRpbGVzW3BvaW50LnggKyBwb2ludC55ICogdGhpcy53aWR0aF0gPSB7XG4gICAgICAgIHNwcml0ZTogc3ByaXRlSW5kZXggPyB0aGlzLmdyYXBoaWNzLmdldFNwcml0ZShzcHJpdGVJbmRleCkgOiB1bmRlZmluZWQsXG4gICAgICAgIGZvcmVncm91bmQ6IGZvcmVncm91bmQgfHwgY29sb3JzLldoaXRlLFxuICAgICAgICBiYWNrZ3JvdW5kOiBiYWNrZ3JvdW5kXG4gICAgfTtcblxufTtcblxuLyoqXG4gKiBBc3NpZ25zIGEgbmV3IGNvbG9yIHRvIHRoaXMgU3ByaXRlR3JpZCdzIHRpbGUgYXQgYSBwcm92aWRlZCBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0gcG9pbnQgYSBQb2l0IHRvIHdoaWNoIHRvIGFzc2lnbiBhIG5ldyBjb2xvclxuICogQHBhcmFtIGZvcmVncm91bmQgQSBmb3JlZ3JvdW5kIGNvbG9yXG4gKiBAcGFyYW0gYmFja2dyb3VuZCBBIGJhY2tncm91bmQgY29sb3JcbiAqL1xuU3ByaXRlR3JpZC5wcm90b3R5cGUuc2V0Q29sb3IgPSBmdW5jdGlvbiAocG9pbnQsIGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcbiAgICB2YXIgdGlsZSA9IHRoaXMudGlsZXNbcG9pbnQueCArIHBvaW50LnkgKiB0aGlzLndpZHRoXTtcbiAgICBpZiAodGlsZSkge1xuICAgICAgICB0aWxlLmZvcmVncm91bmQgPSBmb3JlZ3JvdW5kIHx8IHRpbGUuZm9yZWdyb3VuZDtcbiAgICAgICAgdGlsZS5iYWNrZ3JvdW5kID0gYmFja2dyb3VuZCB8fCB0aWxlLmJhY2tncm91bmQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGVhcnMgdGhpcyBTcHJpdGVHcmlkJ3MgdGlsZXMuXG4gKi9cblNwcml0ZUdyaWQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudGlsZXMgPSBbXTtcbn07XG5cbi8qKlxuICogQWRkcyB0ZXh0IGFzIHNwcml0ZXMgdG8gdGhpcyBTcHJpdGVHcmlkLlxuICpcbiAqIEBwYXJhbSBwb2ludCBhIFBvaW50IHRvIHdoaWNoIHRvIGFkZCB0ZXh0XG4gKiBAcGFyYW0gdGV4dCBBIHRleHQgc3RyaW5nIHRvIGFkZCB0byB0aGlzIFNwcml0ZUdyaWRcbiAqIEBwYXJhbSBmb3JlZ3JvdW5kIEEgZm9yZWdyb3VuZCBDb2xvclxuICogQHBhcmFtIGJhY2tncm91bmQgQSBiYWNrZ3JvdW5kIENvbG9yXG4gKi9cblNwcml0ZUdyaWQucHJvdG90eXBlLmFkZFRleHQgPSBmdW5jdGlvbiAocG9pbnQsIHRleHQsIGZvcmVncm91bmQsIGJhY2tncm91bmQpIHtcblxuICAgIHZhciB0ZXh0UG9pbnQgPSBwb2ludC5jbG9uZSgpLFxuICAgICAgICBpbmRleDtcblxuICAgIHRleHQgPSB0aGlzLmdyYXBoaWNzLnRleHRUb1Nwcml0ZXModGV4dCk7XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0ZXh0Lmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICB0ZXh0UG9pbnQueCA9IHBvaW50LnggKyBpbmRleDtcbiAgICAgICAgdGhpcy50aWxlc1t0ZXh0UG9pbnQueCArIHRleHRQb2ludC55ICogdGhpcy53aWR0aF0gPSB7XG4gICAgICAgICAgICBzcHJpdGU6IHRleHRbaW5kZXhdLFxuICAgICAgICAgICAgZm9yZWdyb3VuZDogZm9yZWdyb3VuZCxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6IGJhY2tncm91bmRcbiAgICAgICAgfTtcbiAgICB9XG5cbn07XG5cblNwcml0ZUdyaWQucHJvdG90eXBlLmFkZEFydCA9IGZ1bmN0aW9uIChzdGFydGluZ1BvaW50LCBhcnRTdHJpbmcpIHtcblxuICAgIHZhciBpbmRleCxcbiAgICAgICAgcG9pbnQgPSBzdGFydGluZ1BvaW50LmNsb25lKCksXG4gICAgICAgIHN5bWJvbCxcbiAgICAgICAgY29sb3I7XG5cbiAgICAvLyBGb3IgZWFjaCBjaGFyYWN0ZXIgaW4gb3VyIHN0cmluZ1xuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGFydFN0cmluZy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcblxuICAgICAgICAvLyBHcmFiIG91ciBuZXh0IHN5bWJvbFxuICAgICAgICBzeW1ib2wgPSBhcnRTdHJpbmcuY2hhckF0KGluZGV4KTtcblxuICAgICAgICAvLyBJZiBpdCdzIGEgbmV3bGluZSwgYnJlYWsgdG8gdGhlIG5leHQgbGluZVxuICAgICAgICBpZiAoc3ltYm9sID09PSAnXFxuJykge1xuXG4gICAgICAgICAgICBwb2ludC54ID0gc3RhcnRpbmdQb2ludC54O1xuICAgICAgICAgICAgcG9pbnQueSArPSAxO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHN5bWJvbCA9IHRoaXMuZ3JhcGhpY3MuY29udmVydFNwZWNpYWxDaGFyYWN0ZXIoc3ltYm9sKTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ICsgMSA8PSBhcnRTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICBjb2xvciA9IGV4cG9ydHMuZ2V0Q29sb3IoYXJ0U3RyaW5nLmNoYXJBdChpbmRleCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNldFRpbGUocG9pbnQsIHN5bWJvbCwgY29sb3IpO1xuXG4gICAgICAgICAgICBwb2ludC54ICs9IDE7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhIHRpbGUgZnJvbSB0aGlzIFNwcml0ZUdyaWQgYXQgYSBzcGVjaWZpYyBwb3NpdGlvblxuICpcbiAqIEBwYXJhbSBhIFBvaW50IGZvciB3aGljaCB0byByZXRyaWV2ZSBzcHJpdGUgZGF0YVxuICogQHJldHVybiBBbiBPYmplY3QgY29udGFpbmluZyBhIHNwcml0ZSwgZm9yZWdyb3VuZCwgYW5kIGJhY2tncm91bmQgY29sb3IuXG4gKi9cblNwcml0ZUdyaWQucHJvdG90eXBlLmdldFRpbGUgPSBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICByZXR1cm4gdGhpcy50aWxlc1twb2ludC54ICsgcG9pbnQueSAqIHRoaXMud2lkdGhdO1xufTtcblxuLyoqXG4gKiBEcmF3cyB0aGlzIFNwcml0ZUdyaWQgdG8gYSBzcGVjaWZpZWQgcG9zaXRpb24gb24gYSBwcm92aWRlZCBncmFwaGljcyBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSBjb250ZXh0IEEgMkQgZ3JhcGhpY3MgY29udGV4dFxuICogQHBhcmFtIHBvaW50IGEgUG9pbnQgYXQgd2hpY2ggdG8gZHJhdyBvdXIgU3ByaXRlR3JpZFxuICovXG5TcHJpdGVHcmlkLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGNvbnRleHQsIHBvaW50KSB7XG5cbiAgICB2YXIgdGlsZSxcbiAgICAgICAgc3ByaXRlUG9pbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgZm9yIChzcHJpdGVQb2ludC54ID0gMDsgc3ByaXRlUG9pbnQueCA8IHRoaXMud2lkdGg7IHNwcml0ZVBvaW50LnggKz0gMSkge1xuICAgICAgICBmb3IgKHNwcml0ZVBvaW50LnkgPSAwOyBzcHJpdGVQb2ludC55IDwgdGhpcy5oZWlnaHQ7IHNwcml0ZVBvaW50LnkgKz0gMSkge1xuICAgICAgICAgICAgdGlsZSA9IHRoaXMuZ2V0VGlsZShzcHJpdGVQb2ludCk7XG4gICAgICAgICAgICBpZiAodGlsZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIGhhdmUgYSBzcHJpdGUgdG8gZHJhdywgb3IganVzdCBhIGJhY2tncm91bmQgY29sb3JcbiAgICAgICAgICAgICAgICBpZiAodGlsZS5zcHJpdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGlsZS5zcHJpdGUuZHJhdyhjb250ZXh0LCBzcHJpdGVQb2ludC5hZGQocG9pbnQpLCB0aWxlLmZvcmVncm91bmQsIHRpbGUuYmFja2dyb3VuZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5maWxsVGlsZShjb250ZXh0LCBzcHJpdGVQb2ludC5hZGQocG9pbnQpLCB0aWxlLmJhY2tncm91bmQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIENvbG9yIHJlcHJlc2VudHMgYSBuYW1lZCBSQkcgY29sb3IuXG4gKlxuICogQHBhcmFtIGNvZGUgQSBIZXggY2hhcmFjdGVyIHJlcHJlc2VudGluZyBhIERPUyBjb2xvciBjb2RlXG4gKiBAcGFyYW0gbmFtZSBBIG5hbWUgb2YgdGhpcyBjb2xvclxuICogQHBhcmFtIGluZGV4IEFuIGluZGV4IGZvciB0aGlzIGNvbG9yXG4gKiBAcGFyYW0gciBBIHJlZCB2YWx1ZVxuICogQHBhcmFtIGcgQSBncmVlbiB2YWx1ZVxuICogQHBhcmFtIGIgQSBibHVlIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIENvbG9yKGNvZGUsIG5hbWUsIGluZGV4LCByLCBnLCBiKSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29sb3IpKSB7XG4gICAgICAgIHRocm93IENvbnN0cnVjdG9yRXJyb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBieXRlIGludG8gYSBIZXhpZGVjaW1hbCBjaGFyYWN0ZXIgZGlnaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbnVtYmVyIEEgbnVtYmVyIGZyb20gMCB0byAyNTUgdG8gY29udmVydFxuICAgICAqIEByZXR1cm4gQSBoZXhpZGVjaW1hbCByZXByZXNlbnRhdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJ5dGVUb0hleChudW1iZXIpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbnVtYmVyLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcwJyArIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgfVxuXG4gICAgaWYgKHIgIT09IHVuZGVmaW5lZCAmJiBnICE9PSB1bmRlZmluZWQgJiYgYiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgIHRoaXMuZyA9IGc7XG4gICAgICAgIHRoaXMuYiA9IGI7XG5cbiAgICAgICAgdGhpcy5yZ2JWYWx1ZSA9ICcjJyArIGJ5dGVUb0hleChyKSArIGJ5dGVUb0hleChnKSArIGJ5dGVUb0hleChiKTtcbiAgICB9XG5cbn1cblxuQ29sb3IucHJvdG90eXBlLmRhcmtlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gY29sb3JzW3RoaXMuaW5kZXggLSA4XTtcbiAgICByZXR1cm4gcmVzdWx0IHx8IHRoaXM7XG59O1xuXG5Db2xvci5wcm90b3R5cGUubGlnaHRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gY29sb3JzW3RoaXMuaW5kZXggKyA4XTtcbiAgICByZXR1cm4gcmVzdWx0IHx8IHRoaXM7XG59O1xuXG5Db2xvci5wcm90b3R5cGUuaXNMaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleCA+PSA4O1xufTtcblxuQ29sb3IucHJvdG90eXBlLmlzRGFyayA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleCA8IDg7XG59O1xuXG5mdW5jdGlvbiBDeWNsaW5nQ29sb3IoY29kZSwgbmFtZSwgY3ljbGVTZXF1ZW5jZSkge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEN5Y2xpbmdDb2xvcikpIHtcbiAgICAgICAgdGhyb3cgQ29uc3RydWN0b3JFcnJvcjtcbiAgICB9XG5cbiAgICBDb2xvci5jYWxsKHRoaXMsIGNvZGUsIG5hbWUpO1xuICAgIHRoaXMuY3ljbGVTZXF1ZW5jZSA9IGN5Y2xlU2VxdWVuY2U7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuY3ljbGVJbmRleCA9IDA7XG4gICAgdGhpcy51cGRhdGUoKTtcbn1cbkN5Y2xpbmdDb2xvci5wcm90b3R5cGUgPSBuZXcgQ29sb3IoKTtcbkN5Y2xpbmdDb2xvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDeWNsaW5nQ29sb3I7XG5cbkN5Y2xpbmdDb2xvci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZXF1ZW5jZUNvbG9yO1xuICAgIHRoaXMuY3ljbGVJbmRleCA9IHRoaXMuY3ljbGVJbmRleCArIDEgPCB0aGlzLmN5Y2xlU2VxdWVuY2UubGVuZ3RoID8gdGhpcy5jeWNsZUluZGV4ICsgMSA6IDA7XG4gICAgc2VxdWVuY2VDb2xvciA9IHRoaXMuY3ljbGVTZXF1ZW5jZVt0aGlzLmN5Y2xlSW5kZXhdO1xuICAgIHRoaXMuaW5kZXggPSBzZXF1ZW5jZUNvbG9yLmluZGV4O1xuICAgIHRoaXMuciA9IHNlcXVlbmNlQ29sb3IucjtcbiAgICB0aGlzLmcgPSBzZXF1ZW5jZUNvbG9yLmc7XG4gICAgdGhpcy5iID0gc2VxdWVuY2VDb2xvci5iO1xuICAgIHRoaXMucmdiVmFsdWUgPSBzZXF1ZW5jZUNvbG9yLnJnYlZhbHVlO1xufTtcblxuLyoqXG4gKiBjb2xvcnMgaXMgYW4gZW51bWVyYXRlZCB0eXBlIHJlcHJlc2VudGluZyBkZWZpbmVkIERPUyBjb2xvcnMuXG4gKi9cbmNvbG9ycyA9IFtcbiAgICBuZXcgQ29sb3IoJzAnLCAnQmxhY2snLCAgICAgICAgIDAsICAwLCAgIDAsICAgMCksXG4gICAgbmV3IENvbG9yKCcxJywgJ0JsdWUnLCAgICAgICAgICAxLCAgMCwgICAwLCAgIDE3MCksXG4gICAgbmV3IENvbG9yKCcyJywgJ0dyZWVuJywgICAgICAgICAyLCAgMCwgICAxNzAsIDApLFxuICAgIG5ldyBDb2xvcignMycsICdDeWFuJywgICAgICAgICAgMywgIDAsICAgMTcwLCAxNzApLFxuICAgIG5ldyBDb2xvcignNCcsICdSZWQnLCAgICAgICAgICAgNCwgIDE3MCwgMCwgICAwKSxcbiAgICBuZXcgQ29sb3IoJzUnLCAnTWFnZW50YScsICAgICAgIDUsICAxNzAsIDAsICAgMTcwKSxcbiAgICBuZXcgQ29sb3IoJzYnLCAnQnJvd24nLCAgICAgICAgIDYsICAxNzAsIDg1LCAgMCksXG4gICAgbmV3IENvbG9yKCc3JywgJ1doaXRlJywgICAgICAgICA3LCAgMTcwLCAxNzAsIDE3MCksXG4gICAgbmV3IENvbG9yKCc4JywgJ0dyZXknLCAgICAgICAgICA4LCAgODUsICA4NSwgIDg1KSxcbiAgICBuZXcgQ29sb3IoJzknLCAnQnJpZ2h0Qmx1ZScsICAgIDksICA4NSwgIDg1LCAgMjU1KSxcbiAgICBuZXcgQ29sb3IoJ0EnLCAnQnJpZ2h0R3JlZW4nLCAgIDEwLCA4NSwgIDI1NSwgODUpLFxuICAgIG5ldyBDb2xvcignQicsICdCcmlnaHRDeWFuJywgICAgMTEsIDg1LCAgMjU1LCAyNTUpLFxuICAgIG5ldyBDb2xvcignQycsICdCcmlnaHRSZWQnLCAgICAgMTIsIDI1NSwgODUsICA4NSksXG4gICAgbmV3IENvbG9yKCdEJywgJ0JyaWdodE1hZ2VudGEnLCAxMywgMjU1LCA4NSwgIDI1NSksXG4gICAgbmV3IENvbG9yKCdFJywgJ1llbGxvdycsICAgICAgICAxNCwgMjU1LCAyNTUsIDg1KSxcbiAgICBuZXcgQ29sb3IoJ0YnLCAnQnJpZ2h0V2hpdGUnLCAgIDE1LCAyNTUsIDI1NSwgMjU1KVxuXTtcblxuY3ljbGUgPSBuZXcgQ3ljbGluZ0NvbG9yKCcqJywgJ0N5Y2xlJywgW2NvbG9yc1s5XSwgY29sb3JzWzEwXSwgY29sb3JzWzExXSwgY29sb3JzWzEyXSwgY29sb3JzWzEzXSwgY29sb3JzWzE0XSwgY29sb3JzWzE1XV0pO1xuXG5mdW5jdGlvbiBnZXRDb2xvcihoZXhEaWdpdCkge1xuICAgIHJldHVybiBjb2xvcnNbcGFyc2VJbnQoaGV4RGlnaXQsIDE2KV07XG59XG5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplRm9yZWdyb3VuZChjb2xvckNvZGUpIHtcblxuICAgIHZhciBmb3JlZ3JvdW5kQ29kZTtcblxuICAgIGlmIChjb2xvckNvZGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGZvcmVncm91bmRDb2RlID0gY29sb3JDb2RlLmNoYXJBdCgxKTtcbiAgICB9IGVsc2UgaWYgKGNvbG9yQ29kZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZm9yZWdyb3VuZENvZGUgPSBjb2xvckNvZGUuY2hhckF0KDApO1xuICAgIH1cblxuICAgIGlmIChmb3JlZ3JvdW5kQ29kZSkge1xuICAgICAgICByZXR1cm4gZm9yZWdyb3VuZENvZGUgPT09ICcqJyA/IGN5Y2xlIDogZ2V0Q29sb3IoZm9yZWdyb3VuZENvZGUpO1xuICAgIH1cblxuICAgIHRocm93ICdJbnZhbGlkIGNvbG9yIGNvZGU6ICcgKyBjb2xvckNvZGU7XG5cbn1cblxuZnVuY3Rpb24gZGVzZXJpYWxpemVCYWNrZ3JvdW5kKGNvbG9yQ29kZSkge1xuXG4gICAgdmFyIGJhY2tncm91bmRDb2RlO1xuXG4gICAgaWYgKGNvbG9yQ29kZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgYmFja2dyb3VuZENvZGUgPSBjb2xvckNvZGUuY2hhckF0KDApO1xuICAgICAgICByZXR1cm4gYmFja2dyb3VuZENvZGUgPT09ICcqJyA/IHVuZGVmaW5lZCA6IGdldENvbG9yKGJhY2tncm91bmRDb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShiYWNrZ3JvdW5kLCBmb3JlZ3JvdW5kKSB7XG4gICAgcmV0dXJuIChiYWNrZ3JvdW5kID09PSB1bmRlZmluZWQgPyAnKicgOiBiYWNrZ3JvdW5kLmNvZGUpICtcbiAgICAgICAgKGZvcmVncm91bmQgPT09IHVuZGVmaW5lZCA/ICdFJyA6IGZvcmVncm91bmQgaW5zdGFuY2VvZiBDeWNsaW5nQ29sb3IgPyAnKicgOiBmb3JlZ3JvdW5kLmNvZGUpO1xufVxuXG4vKipcbiAqIEFzc2lnbnMgY29udmVuaWVuY2UgYWNjZXNzb3JzIGZvciBlYWNoIG9mIHRoZSBjb2xvcnMgaW4gYSBwcm92aWRlZCBhcnJheVxuICogdG8gYSBzcGVjaWZpZWQgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBjb2xvcnMgQW4gYXJyYXkgb2YgQ29sb3IgaW5zdGFuY2VzLlxuICogQHBhcmFtIG15IEFuIG9iamVjdCB0byB3aGljaCB0byBhc3NpZ24gY29udmVuaWVuY2UgYWNjZXNzb3JzLlxuICovXG5leHBvcnRzLkNvbG9ycyA9IHt9O1xuKGZ1bmN0aW9uIChjb2xvcnMsIGV4cG9ydHMpIHtcblxuICAgIHZhciBjb2xvckluZGV4O1xuXG4gICAgZm9yIChjb2xvckluZGV4ID0gMDsgY29sb3JJbmRleCA8IGNvbG9ycy5sZW5ndGg7IGNvbG9ySW5kZXggKz0gMSkge1xuXG4gICAgICAgIC8vIFJlZ3VsYXIgdmVyc2lvblxuICAgICAgICBleHBvcnRzW2NvbG9yc1tjb2xvckluZGV4XS5uYW1lXSA9IGNvbG9yc1tjb2xvckluZGV4XTtcblxuICAgICAgICAvLyBBbGwgY2FwcyB2ZXJzaW9uXG4gICAgICAgIGV4cG9ydHNbY29sb3JzW2NvbG9ySW5kZXhdLm5hbWUudG9VcHBlckNhc2UoKV0gPSBjb2xvcnNbY29sb3JJbmRleF07XG5cbiAgICB9XG5cbn0oY29sb3JzLCBleHBvcnRzLkNvbG9ycykpO1xuXG4vLyBFeHBvcnRzXG5leHBvcnRzLmdldENvbG9yID0gZ2V0Q29sb3I7XG5leHBvcnRzLmRlc2VyaWFsaXplRm9yZWdyb3VuZCA9IGRlc2VyaWFsaXplRm9yZWdyb3VuZDtcbmV4cG9ydHMuZGVzZXJpYWxpemVCYWNrZ3JvdW5kID0gZGVzZXJpYWxpemVCYWNrZ3JvdW5kO1xuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5leHBvcnRzLkNvbG9ycy5DeWNsZSA9IGN5Y2xlO1xuZXhwb3J0cy5Db2xvciA9IENvbG9yO1xuZXhwb3J0cy5DeWNsaW5nQ29sb3IgPSBDeWNsaW5nQ29sb3I7XG5leHBvcnRzLkdyYXBoaWNzID0gR3JhcGhpY3M7XG5leHBvcnRzLlNwcml0ZSA9IFNwcml0ZTtcbmV4cG9ydHMuU3ByaXRlR3JpZCA9IFNwcml0ZUdyaWQ7XG4iLCIvKipcbiAqIEpaVCBJMThOXG4gKiBDb3B5cmlnaHQgwqkgMjAxNCBPcmFuZ2VsaW5lIEludGVyYWN0aXZlLCBJbmMuXG4gKiBAYXV0aG9yIE1hcmsgTWNJbnR5cmVcbiAqL1xuXG4vKmpzbGludCBub2RlOnRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgREVGQVVMVF9MQU5HVUFHRSA9ICdlbic7XG52YXIgTUVTU0FHRVMgPSB7XG5cbiAgICAvLyBFTkdMSVNILUxBTkdVQUdFIE1FU1NBR0VTXG4gICAgZW46IHtcblxuICAgICAgICBrZXlzOiB7XG4gICAgICAgICAgICAnY29sbGVjdCc6ICdZb3Ugbm93IGhhdmUgdGhlIHswfSBrZXkuJyxcbiAgICAgICAgICAgICd0b29tYW55JzogJ1lvdSBhbHJlYWR5IGhhdmUgYSB7MH0ga2V5LicsXG4gICAgICAgICAgICAnOSc6ICdibHVlJyxcbiAgICAgICAgICAgICdBJzogJ2dyZWVuJyxcbiAgICAgICAgICAgICdCJzogJ2N5YW4nLFxuICAgICAgICAgICAgJ0MnOiAncmVkJyxcbiAgICAgICAgICAgICdEJzogJ3B1cnBsZScsXG4gICAgICAgICAgICAnRSc6ICd5ZWxsb3cnLFxuICAgICAgICAgICAgJ0YnOiAnd2hpdGUnXG4gICAgICAgIH0sXG4gICAgICAgIGRvb3JzOiB7XG4gICAgICAgICAgICAnbG9ja2VkJzogJ1RoZSB7MH0gZG9vciBpcyBsb2NrZWQuJyxcbiAgICAgICAgICAgICdvcGVuJzogJ1RoZSB7MH0gZG9vciBpcyBub3cgb3Blbi4nLFxuICAgICAgICAgICAgJzEnOiAnYmx1ZScsXG4gICAgICAgICAgICAnMic6ICdncmVlbicsXG4gICAgICAgICAgICAnMyc6ICdjeWFuJyxcbiAgICAgICAgICAgICc0JzogJ3JlZCcsXG4gICAgICAgICAgICAnNSc6ICdwdXJwbGUnLFxuICAgICAgICAgICAgJzYnOiAneWVsbG93JyxcbiAgICAgICAgICAgICc3JzogJ3doaXRlJ1xuICAgICAgICB9LFxuICAgICAgICBvYnN0YWNsZXM6IHtcbiAgICAgICAgICAgICd3YXRlcic6ICdZb3VyIHdheSBpcyBibG9ja2VkIGJ5IHdhdGVyLicsXG4gICAgICAgICAgICAnc2lnbnBvc3QnOiAnU2lnbnBvc3QnLFxuICAgICAgICAgICAgJ3NpZ25wb3N0bWVzc2FnZSc6ICdUaGUgc2lnbnBvc3QgaXMgY3VyaW91c2x5IGxlZnQgYmxhbmsuJ1xuICAgICAgICB9LFxuICAgICAgICBzdGF0dXM6IHtcbiAgICAgICAgICAgICdnYW1lb3Zlcic6ICdHYW1lIG92ZXIhJyxcbiAgICAgICAgICAgICdub2FtbW8nOiAnWW91IGRvblxcJ3QgaGF2ZSBhbnkgYW1tby4nLFxuICAgICAgICAgICAgJ2h1cnQnOiAnT3VjaCEnLFxuICAgICAgICAgICAgJ25vdG9yY2hlcyc6ICdZb3UgZG9uXFwndCBoYXZlIGFueSB0b3JjaGVzLicsXG4gICAgICAgICAgICAndGl0bGUnOiAnUHJlc3MgW1BdIHRvIHBsYXkuJyxcbiAgICAgICAgICAgICdmb3Jlc3QnOiAnQSBwYXRoIGlzIGNsZWFyZWQgdGhyb3VnaCB0aGUgZm9yZXN0LicsXG4gICAgICAgICAgICAnZ2VtJzogJ0dlbXMgZ2l2ZSB5b3UgaGVhbHRoLicsXG4gICAgICAgICAgICAndG9yY2gnOiAnVG9yY2hlcyBsaWdodCB1cCBkYXJrIHJvb21zLicsXG4gICAgICAgICAgICAnYW1tbyc6ICdBbW11bml0aW9uOiA1IHNob3RzIHBlciBjb250YWluZXIuJyxcbiAgICAgICAgICAgICdkYXJrJzogJ1Jvb20gaXMgZGFyayAtLSBZb3UgbmVlZCB0byBsaWdodCBhIHRvcmNoLicsXG4gICAgICAgICAgICAnYnJlYWthYmxlJzogJ1RoaXMgd2FsbCBoYXMgc2V2ZXJhbCBjcmFja3MuJyxcbiAgICAgICAgICAgICdub3Nob290JzogJ1lvdSBjYW5cXCd0IHNob290IGhlcmUuJyxcbiAgICAgICAgICAgICdoZWFydCc6ICdNYXhpbXVtIGhlYWx0aCBpbmNyZWFzZWQgYnkgMTAhJyxcbiAgICAgICAgICAgICdpbnZpc2libGUnOiAnWW91IGFyZSBibG9ja2VkIGJ5IGFuIGludmlzaWJsZSB3YWxsLicsXG4gICAgICAgICAgICAnbm90ZGFyayc6ICdZb3UgZG9uXFwndCBuZWVkIGEgdG9yY2ggaGVyZS4nLFxuICAgICAgICAgICAgJ2xvYWRpbmcnOiAnTG9hZGluZy4uLicsXG4gICAgICAgICAgICAnbG9hZGVycm9yJzogJ09vcHMhIExvYWRpbmcgZmFpbGVkLicsXG4gICAgICAgICAgICAnZmF0YWxlcnJvcic6ICdJIGhhcyBlcnJvciwgSmltLicsXG4gICAgICAgICAgICAnaW5jb21wYXRpYmxlJzogJ1VtLCB0aGlzIGZpbGUgaXNuXFwndCBjb21wYXRpYmxlLicsXG4gICAgICAgICAgICAnbm9zYXZlJzogJ1lpa2VzISBZb3VcXCdyZSBvdXQgb2Ygc2F2ZSBzcGFjZS4nXG4gICAgICAgIH0sXG4gICAgICAgIHBhdXNlOiB7XG4gICAgICAgICAgICAncGF1c2VkJzogJ1BhdXNlZCcsXG4gICAgICAgICAgICAnaGVhbHRoJzogJyAgICBIZWFsdGg6JyxcbiAgICAgICAgICAgICdhbW1vJzogJyAgICAgIEFtbW86JyxcbiAgICAgICAgICAgICdnZW1zJzogJyAgICAgIEdlbXM6JyxcbiAgICAgICAgICAgICd0b3JjaGVzJzogJyAgIFRvcmNoZXM6JyxcbiAgICAgICAgICAgICdzY29yZSc6ICcgICAgIFNjb3JlOicsXG4gICAgICAgICAgICAna2V5cyc6ICcgICAgICBLZXlzOidcbiAgICAgICAgfSxcbiAgICAgICAgZmlsZToge1xuICAgICAgICAgICAgJ25ldyc6ICdFbXB0eSBTbG90JyxcbiAgICAgICAgICAgICdzYXZlZCc6ICdTYXZlZCBHYW1lJyxcbiAgICAgICAgICAgICdzYXZlJzogJ1NhdmUgR2FtZScsXG4gICAgICAgICAgICAnbG9hZCc6ICdSZXN0b3JlIEdhbWUnLFxuICAgICAgICAgICAgJ3Jlc3RhcnQnOiAnUmVzdGFydCBHYW1lJ1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIEZSRU5DSC1MQU5HVUFHRSBNRVNTQUdFU1xuICAgIGZyOiB7XG5cbiAgICAgICAga2V5czoge1xuICAgICAgICAgICAgJ2NvbGxlY3QnOiAnVm91cyBhdmV6IG1haW50ZW5hbnQgbGEgY2zDqSB7MH0uJyxcbiAgICAgICAgICAgICd0b29tYW55JzogJ1ZvdXMgYXZleiBkw6lqYSB1bmUgY2zDqSB7MH0uJyxcbiAgICAgICAgICAgICc5JzogJ2JsZXVlJyxcbiAgICAgICAgICAgICdBJzogJ3ZlcnRlJyxcbiAgICAgICAgICAgICdCJzogJ2N5YW4nLFxuICAgICAgICAgICAgJ0MnOiAncm91Z2UnLFxuICAgICAgICAgICAgJ0QnOiAndmlvbGV0JyxcbiAgICAgICAgICAgICdFJzogJ2phdW5lJyxcbiAgICAgICAgICAgICdGJzogJ2JsYW5jaGUnXG4gICAgICAgIH0sXG4gICAgICAgIGRvb3JzOiB7XG4gICAgICAgICAgICAnbG9ja2VkJzogJ0xhIHBvcnRlIHswfSBlc3QgdmVycm91aWxsw6llLicsXG4gICAgICAgICAgICAnb3Blbic6ICdMYSBwb3J0ZSB7MH0gZXN0IG1haW50ZW5hbnQgb3ZlcnRlLicsXG4gICAgICAgICAgICAnMSc6ICdibGV1ZScsXG4gICAgICAgICAgICAnMic6ICd2ZXJ0ZScsXG4gICAgICAgICAgICAnMyc6ICdjeWFuJyxcbiAgICAgICAgICAgICc0JzogJ3JvdWdlJyxcbiAgICAgICAgICAgICc1JzogJ3Zpb2xldCcsXG4gICAgICAgICAgICAnNic6ICdqYXVuZScsXG4gICAgICAgICAgICAnNyc6ICdibGFuY2hlJ1xuICAgICAgICB9LFxuICAgICAgICBvYnN0YWNsZXM6IHtcbiAgICAgICAgICAgICd3YXRlcic6ICdWb3RyZSBjaGVtaW4gZXN0IGJsb3F1w6llIHBhciBkZSBsXFwnZWF1JyxcbiAgICAgICAgICAgICdzaWducG9zdCc6ICdQb3RlYXUgSW5kaWNhdGV1cicsXG4gICAgICAgICAgICAnc2lnbnBvc3RtZXNzYWdlJzogJ0xlIHBvdGVhdSBpbmRpY2F0ZXVyIGVzdCBjdXJpZXVzZW1lbnQgdmllcmdlLidcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzOiB7XG4gICAgICAgICAgICAnZ2FtZW92ZXInOiAnR2FtZSBvdmVyICEnLFxuICAgICAgICAgICAgJ25vYW1tbyc6ICdWb3VzIG5cXCdhdmV6IHBsdXMgZGUgbXVuaXRpb25zLicsXG4gICAgICAgICAgICAnaHVydCc6ICdBw69lICEnLFxuICAgICAgICAgICAgJ25vdG9yY2hlcyc6ICdWb3VzIG5cXCdhdmV6IHBsdXMgZGUgdG9yY2hlcy4nLFxuICAgICAgICAgICAgJ3RpdGxlJzogJ0FwcHV5ZXogc3VyIFtQXSBwb3VyIGpvdWVyLicsXG4gICAgICAgICAgICAnZm9yZXN0JzogJ1ZvdXMgZnJheWV6IHVuIGNoZW1pbiBkYW5zIGxhIGbDtHJldC4nLFxuICAgICAgICAgICAgJ2dlbSc6ICdMZXMgYmlqb3V4IGF1Z21lbnRlbnQgdm9zIFBWLicsXG4gICAgICAgICAgICAndG9yY2gnOiAnTGVzIHRvcmNoZXMgw6ljbGFpcmVudCBkZXMgcGnDqGNlcyBzb21icmVzLicsXG4gICAgICAgICAgICAnYW1tbyc6ICdNdW5pdGlvbnM6IDUgYnVsbGVzIHBhciB1bml0w6kuJyxcbiAgICAgICAgICAgICdkYXJrJzogJ1Bpw6hjZSBzb21icmUgLS0gVm91cyBhdmV6IGJlc29pbiBkXFwndW5lIHRvcmNoZSEnLFxuICAgICAgICAgICAgJ2JyZWFrYWJsZSc6ICdDZSBtdXIgYSBwbHVzaWV1cnMgZmlzc3VyZXMuJyxcbiAgICAgICAgICAgICdub3Nob290JzogJ0lsIGVzdCBpbnRlcmRpdCBkZSB0aXJlciBpY2kuJyxcbiAgICAgICAgICAgICdoZWFydCc6ICdQViBtYXggYSBhdWdtZW50w6kgcGFyIDEwICEnLFxuICAgICAgICAgICAgJ2ludmlzaWJsZSc6ICdWb3VzIMOqdGVzIGJsb3F1w6kgcGFyIHVuIG11ciBpbnZpc2libGUuJyxcbiAgICAgICAgICAgICdub3RkYXJrJzogJ1ZvdXMgblxcJ2F2ZXogcGFzIGJlc29pbiBkXFwndW5lIHRvcmNoZSBpY2kuJyxcbiAgICAgICAgICAgICdsb2FkaW5nJzogJ0NoYXJnZW1lbnQuLi4nLFxuICAgICAgICAgICAgJ2xvYWRlcnJvcic6ICdPdXBzISBDaGFyZ2VtZW50IGVjaG91w6kuJyxcbiAgICAgICAgICAgICdmYXRhbGVycm9yJzogJ0pcXCdhaSBsXFwnZXJyZXVyLCBKaW0uJyxcbiAgICAgICAgICAgICdpbmNvbXBhdGlibGUnOiAnTWFpcyBjZSBmaWNoaWVyIGVzdCBpbmNvbXBhdGlibGUuLi4nLFxuICAgICAgICAgICAgJ25vc2F2ZSc6ICdWb3VzIG5cXCdhdmV6IHBsdXMgZFxcJ8Opc3BhY2UgcG91ciBzYXV2ZWdhcmRlci4nXG4gICAgICAgIH0sXG4gICAgICAgIHBhdXNlOiB7XG4gICAgICAgICAgICAncGF1c2VkJzogJ1BhdXNlJyxcbiAgICAgICAgICAgICdoZWFsdGgnOiAnICAgICAgICBQVjonLFxuICAgICAgICAgICAgJ2FtbW8nOiAnIE11bml0aW9uczonLFxuICAgICAgICAgICAgJ2dlbXMnOiAnICAgIEJpam91czonLFxuICAgICAgICAgICAgJ3RvcmNoZXMnOiAnICAgVG9yY2hlczonLFxuICAgICAgICAgICAgJ3Njb3JlJzogJyAgICAgU2NvcmU6JyxcbiAgICAgICAgICAgICdrZXlzJzogJyAgICAgIENsw6lzOidcbiAgICAgICAgfSxcbiAgICAgICAgZmlsZToge1xuICAgICAgICAgICAgJ25ldyc6ICdFc3BhY2UgVmlkZScsXG4gICAgICAgICAgICAnc2F2ZWQnOiAnSmV1IFNhdXZlZ2FyZMOpJyxcbiAgICAgICAgICAgICdzYXZlJzogJ1NhdXZlZ2FyZGVyJyxcbiAgICAgICAgICAgICdsb2FkJzogJ091dnJpcicsXG4gICAgICAgICAgICAncmVzdGFydCc6ICdSw6ljb21tZW5jZXInXG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbnZhciBjdXJyZW50TGFuZ3VhZ2U7XG52YXIgY3VycmVudE1lc3NhZ2VzO1xuXG5mdW5jdGlvbiBmaW5kTWVzc2FnZShzb3VyY2UsIGtleSkge1xuXG4gICAgdmFyIHBhdGggPSBrZXkuc3BsaXQoJy4nKSxcbiAgICAgICAgY3VycmVudCA9IHNvdXJjZSxcbiAgICAgICAgaW5kZXg7XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwYXRoLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICBpZiAoY3VycmVudFtwYXRoW2luZGV4XV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhdGhbaW5kZXhdXTtcblxuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50O1xuXG59XG5cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoa2V5KSB7XG5cbiAgICB2YXIgYXJndW1lbnRJbmRleCxcbiAgICAgICAgcmVzdWx0ID0gZmluZE1lc3NhZ2UoY3VycmVudE1lc3NhZ2VzLCBrZXkpLFxuICAgICAgICByZWdFeDtcblxuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCAmJiBjdXJyZW50TWVzc2FnZXMgIT09IERFRkFVTFRfTEFOR1VBR0UpIHtcbiAgICAgICAgcmVzdWx0ID0gZmluZE1lc3NhZ2UoTUVTU0FHRVNbREVGQVVMVF9MQU5HVUFHRV0sIGtleSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuXG4gICAgZm9yIChhcmd1bWVudEluZGV4ID0gMTsgYXJndW1lbnRJbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGFyZ3VtZW50SW5kZXggKz0gMSkge1xuICAgICAgICByZWdFeCA9IG5ldyBSZWdFeHAoJ1xcXFx7JyArIChhcmd1bWVudEluZGV4IC0gMSkgKyAnXFxcXH0nLCAnZycpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShyZWdFeCwgYXJndW1lbnRzW2FyZ3VtZW50SW5kZXhdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG59XG5cbmZ1bmN0aW9uIGdldExhbmd1YWdlKCkge1xuICAgIHJldHVybiBjdXJyZW50TGFuZ3VhZ2U7XG59XG5cbmZ1bmN0aW9uIHNldExhbmd1YWdlKGxhbmd1YWdlKSB7XG4gICAgY3VycmVudExhbmd1YWdlID0gbGFuZ3VhZ2U7XG4gICAgY3VycmVudE1lc3NhZ2VzID0gTUVTU0FHRVMuaGFzT3duUHJvcGVydHkobGFuZ3VhZ2UpID8gTUVTU0FHRVNbbGFuZ3VhZ2VdIDogTUVTU0FHRVNbREVGQVVMVF9MQU5HVUFHRV07XG59XG5cbmZ1bmN0aW9uIGdldEJvYXJkTWVzc2FnZShib2FyZCwgcG90ZW50aWFsS2V5KSB7XG5cbiAgICBpZiAocG90ZW50aWFsS2V5LmluZGV4T2YoJ2kxOG46JykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGJvYXJkLmdldE1lc3NhZ2UocG90ZW50aWFsS2V5LnN1YnN0cmluZyg1KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvdGVudGlhbEtleTtcblxufVxuXG4vLyBTZXQgb3VyIGRlZmF1bHQgbGFuZ3VhZ2UgcmlnaHQgb2ZmIHRoZSBiYXRcbnNldExhbmd1YWdlKERFRkFVTFRfTEFOR1VBR0UpO1xuXG4vLyBFeHBvcnRzXG5leHBvcnRzLkRlZmF1bHRMYW5ndWFnZSA9IERFRkFVTFRfTEFOR1VBR0U7XG5leHBvcnRzLk1lc3NhZ2VzID0gTUVTU0FHRVM7XG5leHBvcnRzLmdldE1lc3NhZ2UgPSBnZXRNZXNzYWdlO1xuZXhwb3J0cy5maW5kTWVzc2FnZSA9IGZpbmRNZXNzYWdlO1xuZXhwb3J0cy5nZXRMYW5ndWFnZSA9IGdldExhbmd1YWdlO1xuZXhwb3J0cy5zZXRMYW5ndWFnZSA9IHNldExhbmd1YWdlO1xuZXhwb3J0cy5nZXRCb2FyZE1lc3NhZ2UgPSBnZXRCb2FyZE1lc3NhZ2U7XG4iLCIvKipcbiAqIEpaVFNjcmlwdCBDb21tYW5kc1xuICogQ29weXJpZ2h0IMKpIDIwMTQgT3JhbmdlbGluZSBJbnRlcmFjdGl2ZSwgSW5jLlxuICogQGF1dGhvciBNYXJrIE1jSW50eXJlXG4gKi9cblxuLypqc2xpbnQgbm9kZTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFRoaW5nRmFjdG9yeSA9IHJlcXVpcmUoJy4vdGhpbmdzJykuVGhpbmdGYWN0b3J5LFxuICAgIEJhc2ljRGlyZWN0aW9uID0gcmVxdWlyZSgnLi9iYXNpYycpLkRpcmVjdGlvbixcbiAgICBDb25zdHJ1Y3RvckVycm9yID0gcmVxdWlyZSgnLi9iYXNpYycpLkNvbnN0cnVjdG9yRXJyb3IsXG4gICAgR2FtZVN0YXRlID0gcmVxdWlyZSgnLi9nYW1lLXN0YXRlJykuR2FtZVN0YXRlLFxuICAgIGdldEJvYXJkTWVzc2FnZSA9IHJlcXVpcmUoJy4vaTE4bicpLmdldEJvYXJkTWVzc2FnZTtcblxuLyoqXG4gKiB7QGNvZGUgQ29tbWFuZFJlc3VsdH0gaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgZGVmaW5pdGlvbnMgb2ZcbiAqIGNvbW1hbmQgcmVzdWx0cy4gVGhlIHZhbHVlcyBhcmUgTk9STUFMLCBDT05USU5VRSwgYW5kIFJFUEVBVC5cbiAqIE5PUk1BTDogUmV0dXJuZWQgd2hlbiBhIENvbW1hbmQgZXhlY3V0ZXMgbm9ybWFsbHkuXG4gKiBDT05USU5VRTogUmVxdWVzdHMgdGhhdCB0aGUgbmV4dCBjb21tYW5kIGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5LlxuICogUkVQRUFUOiBSZXF1ZXN0cyB0aGF0IHRoZSBzYW1lIGNvbW1hbmQgYmUgZXhlY3V0ZWQgYWdhaW4gbmV4dCBjeWNsZS5cbiAqL1xudmFyIENvbW1hbmRSZXN1bHQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBOT1JNQUw6IDAsXG4gICAgQ09OVElOVUU6IDEsXG4gICAgQ09OVElOVUVfQUZURVJfSlVNUDogMixcbiAgICBSRVBFQVQ6IDNcbn0pO1xuXG4vKipcbiAqIERpcmVjdGlvbiBNb2RpZmllciBFbnVtZXJhdGVkIFR5cGVzXG4gKlxuICogRWFjaCBkaXJlY3Rpb24gbW9kaWZpZXIgaGFzIGFuIGFzc29jaWF0ZWQgdG9rZW4gdmFsdWUsIGEgZGlzcGxheSBuYW1lLCBhbmQgYSBwcm9jZXNzIGZ1bmN0aW9uLlxuICogVGhlIHByb2Nlc3MgZnVuY3Rpb24gdGFrZXMgYSBkaXJlY3Rpb24gYW5kIHJldHVybnMgYSBmaW5hbCwgY2FsY3VsYXRlZCBkaXJlY3Rpb24gdmFsdWUuXG4gKi9cbnZhciBEaXJlY3Rpb25Nb2RpZmllciA9IE9iamVjdC5mcmVlemUoe1xuICAgIENXOiAgIHtuYW1lOiAnQ2xvY2t3aXNlJywgICAgICAgICAgICAgIHR5cGU6ICdtb2RpZmllcicsIHByb2Nlc3M6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBCYXNpY0RpcmVjdGlvbi5jbG9ja3dpc2UoZCk7IH19LFxuICAgIENDVzogIHtuYW1lOiAnQ291bnRlci1jbG9ja3dpc2UnLCAgICAgIHR5cGU6ICdtb2RpZmllcicsIHByb2Nlc3M6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBCYXNpY0RpcmVjdGlvbi5jb3VudGVyQ2xvY2t3aXNlKGQpOyB9fSxcbiAgICBPUFA6ICB7bmFtZTogJ09wcG9zaXRlJywgICAgICAgICAgICAgICB0eXBlOiAnbW9kaWZpZXInLCBwcm9jZXNzOiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gQmFzaWNEaXJlY3Rpb24ub3Bwb3NpdGUoZCk7IH19LFxuICAgIFJORFA6IHtuYW1lOiAnUGVycGVuZGljdWxhcmx5IFJhbmRvbScsIHR5cGU6ICdtb2RpZmllcicsIHByb2Nlc3M6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBCYXNpY0RpcmVjdGlvbi5yYW5kb21QZXJwZW5kaWN1bGFyKGQpOyB9fVxufSk7XG5cblxuLyoqXG4gKiBEaXJlY3Rpb24gRW51bWVyYXRlZCBUeXBlc1xuICpcbiAqIEVhY2ggZGlyZWN0aW9uIGhhcyBhbiBhc3NvY2lhdGVkIHRva2VuIHZhbHVlLCBhIGRpc3BsYXkgbmFtZSwgYW5kIGEgcHJvY2VzcyBmdW5jdGlvbi5cbiAqIFRoZSBwcm9jZXNzIGZ1bmN0aW9uIHRha2VzIGEgSnp0T2JqZWN0IGFuZCByZXR1cm5zIGEgZmluYWwsIGNhbGN1bGF0ZWQgZGlyZWN0aW9uIHZhbHVlLlxuICovXG52YXIgRGlyZWN0aW9uID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgU0VFSzogIHtuYW1lOiAnVG93YXJkIHBsYXllcicsICAgICAgICAgICAgdHlwZTogJ3Rlcm1pbmFsJywgcHJvY2VzczogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8uZ2V0UGxheWVyRGlyZWN0aW9uKCk7IH19LFxuICAgIFNNQVJUOiB7bmFtZTogJ1NtYXJ0IHNlZWsnLCAgICAgICAgICAgICAgIHR5cGU6ICd0ZXJtaW5hbCcsIHByb2Nlc3M6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvLmdldFNtYXJ0RGlyZWN0aW9uKCkgfHwgby5nZXRQbGF5ZXJEaXJlY3Rpb24oKTsgfX0sXG4gICAgRkxPVzogIHtuYW1lOiAnQ3VycmVudCBvcmllbnRhdGlvbicsICAgICAgdHlwZTogJ3Rlcm1pbmFsJywgcHJvY2VzczogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8ub3JpZW50YXRpb247IH19LFxuICAgIFJBTkQ6ICB7bmFtZTogJ1JhbmRvbSBkaXJlY3Rpb24nLCAgICAgICAgIHR5cGU6ICd0ZXJtaW5hbCcsIHByb2Nlc3M6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhc2ljRGlyZWN0aW9uLnJhbmRvbSgpOyB9fSxcbiAgICBSQU5ERjoge25hbWU6ICdSYW5kb20gZnJlZSBkaXJlY3Rpb24nLCAgICB0eXBlOiAndGVybWluYWwnLCBwcm9jZXNzOiBmdW5jdGlvbiAobykgeyByZXR1cm4gQmFzaWNEaXJlY3Rpb24ucmFuZG9tKG8uZ2V0RnJlZURpcmVjdGlvbnMoKSk7IH19LFxuICAgIFJBTkRCOiB7bmFtZTogJ1JhbmRvbSBibG9ja2VkIGRpcmVjdGlvbicsIHR5cGU6ICd0ZXJtaW5hbCcsIHByb2Nlc3M6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBCYXNpY0RpcmVjdGlvbi5yYW5kb20oby5nZXRCbG9ja2VkRGlyZWN0aW9ucygpKTsgfX0sXG4gICAgUk5ERVc6IHtuYW1lOiAnUmFuZG9tbHkgRWFzdCBvciBXZXN0JywgICAgdHlwZTogJ3Rlcm1pbmFsJywgcHJvY2VzczogZnVuY3Rpb24gKCkgeyByZXR1cm4gQmFzaWNEaXJlY3Rpb24ucmFuZG9tRWFzdFdlc3QoKTsgfX0sXG4gICAgUk5ETlM6IHtuYW1lOiAnUmFuZG9tbHkgTm9ydGggb3IgU291dGgnLCAgdHlwZTogJ3Rlcm1pbmFsJywgcHJvY2VzczogZnVuY3Rpb24gKCkgeyByZXR1cm4gQmFzaWNEaXJlY3Rpb24ucmFuZG9tTm9ydGhTb3V0aCgpOyB9fSxcbiAgICBSTkRORToge25hbWU6ICdSYW5kb21seSBOb3J0aCBvciBFYXN0JywgICB0eXBlOiAndGVybWluYWwnLCBwcm9jZXNzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBCYXNpY0RpcmVjdGlvbi5yYW5kb21Ob3J0aEVhc3QoKTsgfX0sXG4gICAgTk9SVEg6IHtuYW1lOiAnTm9ydGgnLCAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Rlcm1pbmFsJywgcHJvY2VzczogZnVuY3Rpb24gKCkgeyByZXR1cm4gQmFzaWNEaXJlY3Rpb24uTm9ydGg7IH19LFxuICAgIEVBU1Q6ICB7bmFtZTogJ0Vhc3QnLCAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXJtaW5hbCcsIHByb2Nlc3M6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhc2ljRGlyZWN0aW9uLkVhc3Q7IH19LFxuICAgIFNPVVRIOiB7bmFtZTogJ1NvdXRoJywgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXJtaW5hbCcsIHByb2Nlc3M6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhc2ljRGlyZWN0aW9uLlNvdXRoOyB9fSxcbiAgICBXRVNUOiAge25hbWU6ICdXZXN0JywgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGVybWluYWwnLCBwcm9jZXNzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBCYXNpY0RpcmVjdGlvbi5XZXN0OyB9fSxcbiAgICBOOiAgICAge25hbWU6ICdOb3J0aCBzaG9ydGhhbmQnLCAgICAgICAgICB0eXBlOiAndGVybWluYWwnLCBwcm9jZXNzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBCYXNpY0RpcmVjdGlvbi5Ob3J0aDsgfX0sXG4gICAgRTogICAgIHtuYW1lOiAnRWFzdCBzaG9ydGhhbmQnLCAgICAgICAgICAgdHlwZTogJ3Rlcm1pbmFsJywgcHJvY2VzczogZnVuY3Rpb24gKCkgeyByZXR1cm4gQmFzaWNEaXJlY3Rpb24uRWFzdDsgfX0sXG4gICAgUzogICAgIHtuYW1lOiAnU291dGggc2hvcnRoYW5kJywgICAgICAgICAgdHlwZTogJ3Rlcm1pbmFsJywgcHJvY2VzczogZnVuY3Rpb24gKCkgeyByZXR1cm4gQmFzaWNEaXJlY3Rpb24uU291dGg7IH19LFxuICAgIFc6ICAgICB7bmFtZTogJ1dlc3Qgc2hvcnRoYW5kJywgICAgICAgICAgIHR5cGU6ICd0ZXJtaW5hbCcsIHByb2Nlc3M6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhc2ljRGlyZWN0aW9uLldlc3Q7IH19XG59KTtcblxuLyoqXG4gKiBMYWJlbFxuICpcbiAqIEEgbGFiZWwgaXMgYSBuYW1lZCBsaW5lIGlkZW50aWZpZXIgdXNlZCB0byBqdW1wIHRvIGluc3RydWN0aW9uIGxvY2F0aW9ucyB3aXRoaW5cbiAqIGEgc2NyaXB0LiBBIGxhYmVsIGlzbid0IHN0cmljdGx5IGEgY29tbWFuZCBhbmQgY2FuJ3QgYmUgZXhlY3V0ZWQ7IGluc3RlYWQsIGl0J3NcbiAqIHVzZWQgYXMgYSBtYXJrZXIgaW4gYSBwYXJzZWQgc2NyaXB0IHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gTGFiZWwobmFtZSkge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExhYmVsKSkge1xuICAgICAgICB0aHJvdyBDb25zdHJ1Y3RvckVycm9yO1xuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG59XG5cbi8qKlxuICogRGlyZWN0aW9uRXhwcmVzc2lvblxuICpcbiAqIEEgRGlyZWN0aW9uRXhwcmVzc2lvbiBjb25zaXN0cyBvZiBhIGRpcmVjdGlvbiB0ZXJtaW5hbCBhbmQgYSBzZXJpZXMgb2Ygb3B0aW9uYWxcbiAqIG1vZGlmaWVycyB0aGF0IHRyYW5zZm9ybSB0aGUgZGlyZWN0aW9uIGludG8gYSBmaW5hbCByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIERpcmVjdGlvbkV4cHJlc3Npb24odGVybWluYWwpIHtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEaXJlY3Rpb25FeHByZXNzaW9uKSkge1xuICAgICAgICB0aHJvdyBDb25zdHJ1Y3RvckVycm9yO1xuICAgIH1cblxuICAgIHRoaXMubW9kaWZpZXJzID0gW107XG4gICAgdGhpcy50ZXJtaW5hbCA9IHRlcm1pbmFsO1xuICAgIHRoaXMuY291bnQgPSAxO1xufVxuXG4vKipcbiAqIEV4ZWN1dGVzIHRoaXMgRGlyZWN0aW9uRXhwcmVzc2lvbiBhbmQgcmV0dXJucyBhIGNvbmNyZXRlIERpcmVjdGlvbiBpbnN0YW5jZS5cbiAqL1xuRGlyZWN0aW9uRXhwcmVzc2lvbi5wcm90b3R5cGUuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKG93bmVyKSB7XG5cbiAgICAvLyBHZXQgb3VyIGRpcmVjdGlvbiBmcm9tIG91ciBleHByZXNzaW9uXG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMudGVybWluYWwucHJvY2Vzcyhvd25lciksXG4gICAgICAgIG1vZGlmaWVycyA9IHRoaXMubW9kaWZpZXJzLnNsaWNlKDApO1xuXG4gICAgd2hpbGUgKG1vZGlmaWVycy5sZW5ndGgpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gbW9kaWZpZXJzLnBvcCgpLnByb2Nlc3MoZGlyZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gb3VyIHJlc3VsdFxuICAgIHJldHVybiBkaXJlY3Rpb247XG59O1xuXG4vKipcbiAqIEJlY29tZUNvbW1hbmRcbiAqXG4gKiBXaGVuIGV4ZWN1dGVkLCBhIHByb3ZpZGVkIG93bmVyIFRoaW5nIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBhbm90aGVyIFRoaW5nIHNwZWNpZmllZFxuICogYnkgdGhpcyBjb21tYW5kJ3MgdGVtcGxhdGUuXG4gKi9cbmZ1bmN0aW9uIEJlY29tZUNvbW1hbmQodGhpbmdUZW1wbGF0ZSkge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJlY29tZUNvbW1hbmQpKSB7XG4gICAgICAgIHRocm93IENvbnN0cnVjdG9yRXJyb3I7XG4gICAgfVxuXG4gICAgdGhpcy50aGluZ1RlbXBsYXRlID0gdGhpbmdUZW1wbGF0ZTtcblxufVxuXG4vKipcbiAqIFJlcGxhY2UgYSBwcm92aWRlZCBvd25lciB3aXRoIGFub3RoZXIgVGhpbmcgYmFzZWQgb24gdGhpcyBjb21tYW5kJ3NcbiAqIGFzc29jaWF0ZWQgdGhpbmcgdGVtcGxhdGUuXG4gKi9cbkJlY29tZUNvbW1hbmQucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAob3duZXIpIHtcblxuICAgIC8vIENyZWF0ZSBvdXIgbmV3IHRoaW5nXG4gICAgdmFyIG5ld1RoaW5nID0gVGhpbmdGYWN0b3J5LmRlc2VyaWFsaXplKHRoaXMudGhpbmdUZW1wbGF0ZSwgb3duZXIuYm9hcmQpO1xuXG4gICAgLy8gUmVwbGFjZSBvdXIgb3duZXIncyB0aWxlIHdpdGggdGhlIG5ldyB0aGluZ1xuICAgIG93bmVyLmJvYXJkLnJlcGxhY2VUaWxlKG93bmVyLnBvaW50LCBuZXdUaGluZyk7XG5cbn07XG5cbi8qKlxuICogQ2hhbmdlQ29tbWFuZFxuICpcbiAqIFdoZW4gZXhlY3V0ZWQsIGEgYm9hcmQgd2lsbCBoYXZlIGFsbCBpbnN0YW5jZXMgb2YgdGhpbmdzXG4gKiBzcGVjaWZpZWQgYnkgdGhpcyBjb21tYW5kcyB0ZW1wbGF0ZSBieSBhbm90aGVyIHR5cGUgb2YgVGhpbmcuXG4gKi9cbmZ1bmN0aW9uIENoYW5nZUNvbW1hbmQoZnJvbVRlbXBsYXRlLCB0b1RlbXBsYXRlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENoYW5nZUNvbW1hbmQpKSB7XG4gICAgICAgIHRocm93IENvbnN0cnVjdG9yRXJyb3I7XG4gICAgfVxuXG4gICAgdGhpcy5mcm9tVGVtcGxhdGUgPSBmcm9tVGVtcGxhdGU7XG4gICAgdGhpcy50b1RlbXBsYXRlID0gdG9UZW1wbGF0ZTtcbn1cblxuLyoqXG4gKiBSZXBsYWNlcyBhbGwgdGhpbmdzIG9uIGEgcHJvdmlkZWQgb3duZXIncyBib2FyZCBtYXRjaGluZyB0aGlzIGNvbW1hbmQncyBmcm9tVGVtcGxhdGUuXG4gKi9cbkNoYW5nZUNvbW1hbmQucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAob3duZXIpIHtcbiAgICBvd25lci5ib2FyZC5jaGFuZ2VUaWxlcyh0aGlzLmZyb21UZW1wbGF0ZSwgdGhpcy50b1RlbXBsYXRlKTtcbiAgICByZXR1cm4gQ29tbWFuZFJlc3VsdC5DT05USU5VRTtcbn07XG5cbi8qKlxuICogQ2hhckNvbW1hbmRcbiAqXG4gKiBBIGNvbW1hbmQgdGhhdCBjaGFuZ2VzIGFuIG93bmVyJ3MgY2hhcmFjdGVyIGNvZGUgdG8gYSBzcGVjaWZpZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIENoYXJDb21tYW5kKHZhbHVlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENoYXJDb21tYW5kKSkge1xuICAgICAgICB0aHJvdyBDb25zdHJ1Y3RvckVycm9yO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG59XG5cbi8qKlxuICogQ2hhbmdlcyBhIHByb3ZpZGVkIG93bmVyJ3MgY2hhcmFjdGVyIHZhbHVlLlxuICovXG5DaGFyQ29tbWFuZC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChvd25lcikge1xuICAgIG93bmVyLnNwcml0ZUluZGV4ID0gdGhpcy52YWx1ZTtcbn07XG5cbi8qKlxuICogRGllQ29tbWFuZFxuICpcbiAqIEEgQ29tbWFuZCB0aGF0IHJlbW92ZXMgYW4gb3duZXIgZnJvbSBpdHMgYm9hcmQuXG4gKi9cbmZ1bmN0aW9uIERpZUNvbW1hbmQobWFnbmV0aWNhbGx5KSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERpZUNvbW1hbmQpKSB7XG4gICAgICAgIHRocm93IENvbnN0cnVjdG9yRXJyb3I7XG4gICAgfVxuICAgIHRoaXMubWFnbmV0aWNhbGx5ID0gbWFnbmV0aWNhbGx5O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYSBwcm92aWRlZCBvd25lciBmcm9tIGl0cyBhc3NvY2lhdGVkIGJvYXJkLlxuICovXG5EaWVDb21tYW5kLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgb3duZXIucmVtb3ZlKCk7XG4gICAgaWYgKHRoaXMubWFnbmV0aWNhbGx5KSB7XG4gICAgICAgIG93bmVyLmJvYXJkLnBsYXllci5wdXNoKEJhc2ljRGlyZWN0aW9uLm9wcG9zaXRlKG93bmVyLmdldFBsYXllckRpcmVjdGlvbigpKSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmRDb21tYW5kXG4gKlxuICogQSBjb21tYW5kIHRoYXQgaGFsdHMgc2NyaXB0IGV4ZWN1dGlvbiBvbiBpdHMgb3duZXIncyBzY3JpcHQgY29udGV4dC5cbiAqL1xuZnVuY3Rpb24gRW5kQ29tbWFuZCgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRW5kQ29tbWFuZCkpIHtcbiAgICAgICAgdGhyb3cgQ29uc3RydWN0b3JFcnJvcjtcbiAgICB9XG59XG5cbi8qKlxuICogSGFsdCBzY3JpcHQgZXhlY3V0aW9uIG9uIGEgcHJvdmlkZWQgb3duZXIncyBzY3JpcHQgY29udGV4dC5cbiAqL1xuRW5kQ29tbWFuZC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChvd25lcikge1xuICAgIG93bmVyLnNjcmlwdENvbnRleHQuc3RvcCgpO1xufTtcblxuLyoqXG4gKiBHaXZlQ29tbWFuZFxuICpcbiAqIEluY3JlYXNlcyBhIGdhbWUgY291bnRlciBieSBhIHNwZWNpZmllZCBhbW91bnQuXG4gKi9cbmZ1bmN0aW9uIEdpdmVDb21tYW5kKGNvdW50ZXIsIGFtb3VudCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHaXZlQ29tbWFuZCkpIHtcbiAgICAgICAgdGhyb3cgQ29uc3RydWN0b3JFcnJvcjtcbiAgICB9XG4gICAgdGhpcy5jb3VudGVyID0gY291bnRlci50b1VwcGVyQ2FzZSgpO1xuICAgIHRoaXMuYW1vdW50ID0gYW1vdW50O1xufVxuXG4vKipcbiAqIEluY3JlYXNlcyBhIGNvdW50ZXIgb24gdGhpcyBvd25lcidzIGdhbWUgYnkgYW4gYW1vdW50IHNwZWNpZmllZFxuICogYnkgdGhpcyBjb21tYW5kLlxuICovXG5HaXZlQ29tbWFuZC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChvd25lcikge1xuICAgIG93bmVyLmJvYXJkLmdhbWUuYWRqdXN0Q291bnRlcih0aGlzLmNvdW50ZXIsIHRoaXMuYW1vdW50KTtcbiAgICByZXR1cm4gQ29tbWFuZFJlc3VsdC5DT05USU5VRTtcbn07XG5cbi8qKlxuICogSWZDb21tYW5kXG4gKlxuICogSnVtcHMgdG8gYSBuZXcgZXhlY3V0aW9uIGxvY2F0aW9uIGlmIGFuIGV4cHJlc3Npb24gZXZhbHVhdGVzIHRvIHRydWUuXG4gKi9cbmZ1bmN0aW9uIElmQ29tbWFuZChsYWJlbCwgZXhwcmVzc2lvbikge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJZkNvbW1hbmQpKSB7XG4gICAgICAgIHRocm93IENvbnN0cnVjdG9yRXJyb3I7XG4gICAgfVxuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xufVxuXG4vKipcbiAqIEp1bXBzIHRvIGFuIG93bmVyJ3MgbGFiZWwgaWYgdGhpcyBjb21tYW5kJ3MgZXhwcmVzc2lvbiBldmFsdWF0ZXMgdG8gdHJ1ZS5cbiAqL1xuSWZDb21tYW5kLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgaWYgKHRoaXMuZXhwcmVzc2lvbi5nZXRSZXN1bHQob3duZXIpKSB7XG4gICAgICAgIG93bmVyLnNjcmlwdENvbnRleHQuanVtcFRvTGFiZWwodGhpcy5sYWJlbCk7XG4gICAgICAgIHJldHVybiBDb21tYW5kUmVzdWx0LkNPTlRJTlVFX0FGVEVSX0pVTVA7XG4gICAgfVxuICAgIHJldHVybiBDb21tYW5kUmVzdWx0LkNPTlRJTlVFO1xufTtcblxuLyoqXG4gKiBMb2NrQ29tbWFuZFxuICpcbiAqIFdoZW4gZXhlY3V0ZWQsIGFuIG93bmVyIHdpbGwgbm8gbG9uZ2VyIGJlIGFibGUgdG8gcmVjZWl2ZSBtZXNzYWdlc1xuICogZnJvbSBvdGhlciBzY3JpcHRzLlxuICovXG5mdW5jdGlvbiBMb2NrQ29tbWFuZCgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTG9ja0NvbW1hbmQpKSB7XG4gICAgICAgIHRocm93IENvbnN0cnVjdG9yRXJyb3I7XG4gICAgfVxufVxuXG4vKipcbiAqIExvY2tzIHRoZSBwcm92aWRlZCBvd25lciBzbyB0aGF0IGl0IGNhbiBubyBsb25nZXIgcmVjZWl2ZSBtZXNzYWdlcyBmcm9tIG90aGVyIHNjcmlwdHMuXG4gKi9cbkxvY2tDb21tYW5kLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgb3duZXIubG9ja2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gQ29tbWFuZFJlc3VsdC5DT05USU5VRTtcbn07XG5cbi8qKlxuICogTW92ZUNvbW1hbmRcbiAqXG4gKiBXaGVuIGV4ZWN1dGVkLCBhbiBvd25lciB3aWxsIGJlIG1vdmVkIGFjY29yZGluZyB0byB0aGlzIGNvbW1hbmQnc1xuICogZGlyZWN0aW9uIGV4cHJlc3Npb24gYW5kIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIE1vdmVDb21tYW5kKGRpcmVjdGlvbkV4cHJlc3Npb24sIGZvcmNlZnVsKSB7XG4gICAgdGhpcy5kaXJlY3Rpb25FeHByZXNzaW9uID0gZGlyZWN0aW9uRXhwcmVzc2lvbjtcbiAgICB0aGlzLmZvcmNlZnVsID0gZm9yY2VmdWw7XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhpcyBNb3ZlQ29tbWFuZCwgbW92aW5nIGEgcHJvdmlkZWQgb3duZXIgb24gdGhlIGJvYXJkXG4gKiBhY2NvcmRpbmcgdG8gdGhlIHJlc3VsdCBvZiB0aGlzIGNvbW1hbmQncyBkaXJlY3Rpb24gZXhwcmVzc2lvbiBhbmRcbiAqIG9wdGlvbnMuXG4gKi9cbk1vdmVDb21tYW5kLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKG93bmVyKSB7XG5cbiAgICByZXR1cm4gdGhpcy5mb3JjZWZ1bCA/IHRoaXMuZm9yY2VmdWxNb3ZlKG93bmVyKSA6IHRoaXMubW92ZShvd25lcik7XG5cbn07XG5cbi8qKlxuICogTW92ZXMgYSBwcm92aWRlZCBvd25lciBnZW50bHkgaW4gYSBkaXJlY3Rpb24gYWNjb3JkaW5nIHRvXG4gKiB0aGlzIGNvbW1hbmQncyBkaXJlY3Rpb24gZXhwcmVzc2lvbiByZXN1bHQuXG4gKi9cbk1vdmVDb21tYW5kLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKG93bmVyKSB7XG5cbiAgICB2YXIgaGVhcCA9IG93bmVyLnNjcmlwdENvbnRleHQuaGVhcCxcbiAgICAgICAgZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb25FeHByZXNzaW9uLmdldFJlc3VsdChvd25lciksXG4gICAgICAgIGNvdW50ID0gJzxjb3VudD4nO1xuXG4gICAgaWYgKCFoZWFwW2NvdW50XSkge1xuICAgICAgICBoZWFwW2NvdW50XSA9IHRoaXMuZGlyZWN0aW9uRXhwcmVzc2lvbi5jb3VudDtcbiAgICB9XG5cbiAgICAvLyBJZiBhIGRpcmVjdGlvbiBpcyBhdmFpbGFibGVcbiAgICBpZiAoZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgLy8gSWYgd2UgYXJlIHRvIGdvIGEgbnVtYmVyIG9mIHRpbWVzLi4uXG4gICAgICAgIGlmIChoZWFwW2NvdW50XSA+IDApIHtcblxuICAgICAgICAgICAgaGVhcFtjb3VudF0gLT0gMTtcblxuICAgICAgICAgICAgaWYgKG93bmVyLm1vdmUoZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDb21tYW5kUmVzdWx0LlJFUEVBVDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGhlYXBbY291bnRdO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cbi8qKlxuICogTW92ZXMgYSBwcm92aWRlZCBvd25lciBmb3JjZWZ1bGx5IGluIGEgZGlyZWN0aW9uIGFjY29yZGluZyB0b1xuICogdGhpcyBjb21tYW5kJ3MgZGlyZWN0aW9uIGV4cHJlc3Npb24gcmVzdWx0LlxuICovXG5Nb3ZlQ29tbWFuZC5wcm90b3R5cGUuZm9yY2VmdWxNb3ZlID0gZnVuY3Rpb24gKG93bmVyKSB7XG5cbiAgICB2YXIgZGlyZWN0aW9uLFxuICAgICAgICBoZWFwID0gb3duZXIuc2NyaXB0Q29udGV4dC5oZWFwLFxuICAgICAgICBjb3VudCA9ICc8Y291bnQ+JyxcbiAgICAgICAgc3R1Y2sgPSAnPHN0dWNrPicsXG4gICAgICAgIHN1Y2Nlc3M7XG5cbiAgICBpZiAoIWhlYXBbY291bnRdKSB7XG4gICAgICAgIGhlYXBbY291bnRdID0gdGhpcy5kaXJlY3Rpb25FeHByZXNzaW9uLmNvdW50O1xuICAgIH1cblxuXG4gICAgLy8gRGVwZW5kaW5nIG9uIGlmIHdlIGFyZSBzdHVjayBvciBub3QuLi5cbiAgICBpZiAoIWhlYXBbc3R1Y2tdKSB7XG4gICAgICAgIC8vIFdlJ3JlIG5vdCBzdHVjaywgc28gY2FsY3VsYXRlIG91ciBuZXh0IGRpcmVjdGlvblxuICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbkV4cHJlc3Npb24uZ2V0UmVzdWx0KG93bmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBhcmUgc3R1Y2ssIGNvbnRpbnVlIHRyeWluZyB0aGF0IGRpcmVjdGlvblxuICAgICAgICBkaXJlY3Rpb24gPSBCYXNpY0RpcmVjdGlvbi5mcm9tTmFtZShoZWFwW3N0dWNrXSk7XG4gICAgfVxuXG4gICAgLy8gSWYgYSBkaXJlY3Rpb24gaXMgYXZhaWxhYmxlXG4gICAgaWYgKGRpcmVjdGlvbikge1xuXG4gICAgICAgIHN1Y2Nlc3MgPSBvd25lci5tb3ZlKGRpcmVjdGlvbik7XG5cbiAgICAgICAgLy8gSWYgd2Ugd2VyZSBub3Qgc3VjY2Vzc2Z1bCwgd2UncmUgc3R1Y2tcbiAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG5cbiAgICAgICAgICAgIGhlYXBbc3R1Y2tdID0gQmFzaWNEaXJlY3Rpb24uZ2V0U2hvcnROYW1lKGRpcmVjdGlvbik7XG5cbiAgICAgICAgICAgIC8vIFdlIHdpbGwgdHJ5IGFnYWluIHVudGlsIHdlJ3JlIGZyZWVcbiAgICAgICAgICAgIHJldHVybiBDb21tYW5kUmVzdWx0LlJFUEVBVDtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgYXJlbid0IHN0dWNrLCBzbyBjb3VudCBvdXIgbW92ZXMgZG93blxuICAgICAgICBoZWFwW2NvdW50XSAtPSAxO1xuICAgICAgICBpZiAoaGVhcFtjb3VudF0gPiAwKSB7XG4gICAgICAgICAgICBkZWxldGUgaGVhcFtzdHVja107XG4gICAgICAgICAgICByZXR1cm4gQ29tbWFuZFJlc3VsdC5SRVBFQVQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSdyZSBub3QgbW92aW5nIGFueW1vcmUuLi5cbiAgICAgICAgZGVsZXRlIGhlYXBbY291bnRdO1xuICAgICAgICBkZWxldGUgaGVhcFtzdHVja107XG5cbiAgICB9XG5cbn07XG5cbi8qKlxuICogUGxheUNvbW1hbmRcbiAqXG4gKiBXaGVuIGV4ZWN1dGVkLCBoYXMgdGhlIG93bmVyIHBsYXkgYSBzcGVjaWZpZWQgYXVkaW8gc2VxdWVuY2UuXG4gKi9cbmZ1bmN0aW9uIFBsYXlDb21tYW5kKHNlcXVlbmNlKSB7XG4gICAgdGhpcy5zZXF1ZW5jZSA9IHNlcXVlbmNlO1xufVxuXG4vKipcbiAqIFBsYXkgdGhpcyBjb21tYW5kJ3MgYXVkaW8gc2VxdWVuY2Ugd2l0aCB0aGUgb3duZXIuXG4gKi9cblBsYXlDb21tYW5kLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgb3duZXIucGxheSh0aGlzLnNlcXVlbmNlLCB0cnVlKTtcbiAgICByZXR1cm4gQ29tbWFuZFJlc3VsdC5DT05USU5VRTtcbn07XG5cbi8qKlxuICogUHV0Q29tbWFuZFxuICpcbiAqIFB1dCBpcyBhIGNvbW1hbmQgdGhhdCwgd2hlbiBleGVjdXRlZCwgYWRkcyBhIG5ldyBpbnN0YW5jZSBvZiBhIHByb3ZpZGVkXG4gKiB0ZW1wbGF0ZSBhdCBhIHNwYWNlIGluIGEgcHJvdmlkZWQgZGlyZWN0aW9uIHJlbGF0aXZlIHRvIGFuIG93bmVyLlxuICovXG5mdW5jdGlvbiBQdXRDb21tYW5kKHRoaW5nVGVtcGxhdGUsIGRpcmVjdGlvbkV4cHJlc3Npb24pIHtcbiAgICB0aGlzLnRoaW5nVGVtcGxhdGUgPSB0aGluZ1RlbXBsYXRlO1xuICAgIHRoaXMuZGlyZWN0aW9uRXhwcmVzc2lvbiA9IGRpcmVjdGlvbkV4cHJlc3Npb247XG59XG5cbi8qKlxuICogSW5zZXJ0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGNvbW1hbmQncyB0aGluZyB0ZW1wbGF0ZSBhdCBhIGxvY2F0aW9uXG4gKiBkaXJlY3RseSBhZGphY2VudCB0byBhIHByb3ZpZGVkIG93bmVyLCBpZiB0aGUgc3BhY2UgaXNuJ3QgYWxyZWFkeSBvY2N1cGllZC5cbiAqL1xuUHV0Q29tbWFuZC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChvd25lcikge1xuXG4gICAgdmFyIG5ld1RoaW5nLFxuICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbkV4cHJlc3Npb24uZ2V0UmVzdWx0KG93bmVyKSxcbiAgICAgICAgcG9pbnQgPSBvd25lci5wb2ludC5hZGQoZGlyZWN0aW9uKSxcbiAgICAgICAgb2JzdGFjbGUsXG4gICAgICAgIGlzRnJlZVNwYWNlO1xuXG4gICAgLy8gSWYgb3VyIHBvaW50IGlzIG9mZiB0aGUgYm9hcmQsIHJldHVybiBpbW1lZGlhdGVseVxuICAgIGlmIChvd25lci5ib2FyZC5pc091dHNpZGUocG9pbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cblxuICAgIC8vIEdldCB0aGUgdGlsZSBpbiB0aGUgd2F5LCBpZiBhcHBsaWNhYmxlXG4gICAgb2JzdGFjbGUgPSBvd25lci5ib2FyZC5nZXRUaWxlKHBvaW50KTtcblxuICAgIC8vIERldGVybWluZSBpZiB0aGVyZSBpcyBmcmVlIHNwYWNlLCBvciBpZiB3ZSBjYW4gbWFrZSBzb21lIGJ5IHB1c2hpbmcgYW4gb2JzdGFjbGVcbiAgICBpc0ZyZWVTcGFjZSA9IG9ic3RhY2xlID8gb3duZXIuYm9hcmQubW92ZVRpbGUob3duZXIucG9pbnQsIHBvaW50LCBmYWxzZSwgdHJ1ZSkgOiB0cnVlO1xuXG4gICAgLy8gQ3JlYXRlIG91ciBuZXcgdGhpbmdcbiAgICBuZXdUaGluZyA9IFRoaW5nRmFjdG9yeS5kZXNlcmlhbGl6ZSh0aGlzLnRoaW5nVGVtcGxhdGUsIG93bmVyLmJvYXJkKTtcblxuXG4gICAgLy8gRGVwZW5kaW5nIG9uIGlmIHRoZXJlJ3Mgc3BhY2UgYW5kIGEgdGhpbmcgYXZhaWxhYmxlLi4uXG4gICAgaWYgKGlzRnJlZVNwYWNlICYmIG5ld1RoaW5nKSB7XG5cbiAgICAgICAgLy8gVGhlcmUncyBzcGFjZSwgc28gYWRkIG91ciB0aGluZ1xuICAgICAgICBvd25lci5ib2FyZC5hZGRUaGluZyhwb2ludCwgbmV3VGhpbmcpO1xuXG4gICAgfSBlbHNlIGlmICghaXNGcmVlU3BhY2UgJiYgIW5ld1RoaW5nKSB7XG5cbiAgICAgICAgLy8gVGhlcmUncyBubyBmcmVlIHNwYWNlLCBhbmQgd2UncmUgcHV0dGluZyBlbXB0aW5lc3MsXG4gICAgICAgIC8vIHNvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgdGlsZS5cbiAgICAgICAgb3duZXIuYm9hcmQuZGVsZXRlVGlsZShwb2ludCk7XG5cbiAgICB9XG5cbn07XG5cbi8qKlxuICogUmVzdG9yZSBDb21tYW5kXG4gKlxuICogV2hlbiBleGVjdXRlZCwgYW4gYXNzb2NpYXRlZCBsYWJlbCBpcyByZXN0b3JlZCBpbiBhIHByb3ZpZGVkXG4gKiBvd25lcidzIHNjcmlwdCBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBSZXN0b3JlQ29tbWFuZChsYWJlbCkge1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbn1cblxuLyoqXG4gKiBSZXN0b3JlcyB0aGlzIGNvbW1hbmQncyBhc3NvY2lhdGVkIGxhYmVsIGluIGEgcHJvdmlkZWQgb3duZXInc1xuICogc2NyaXB0IGNvbnRleHQuXG4gKi9cblJlc3RvcmVDb21tYW5kLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgb3duZXIuc2NyaXB0Q29udGV4dC5yZXN0b3JlTGFiZWwodGhpcy5sYWJlbCk7XG4gICAgcmV0dXJuIENvbW1hbmRSZXN1bHQuQ09OVElOVUU7XG59O1xuXG4vKipcbiAqIFNheSBDb21tYW5kXG4gKiBXaGVuIGV4ZWN1dGVkLCBhIHRleHR1YWwgYWxlcnQgaXMgcmVxdWVzdGVkIHRvIGJlIGRpc3BsYXllZCBieVxuICogYSBwcm92aWRlZCBvd25lci5cbiAqL1xuZnVuY3Rpb24gU2F5Q29tbWFuZCh0ZXh0KSB7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbn1cblxuLyoqXG4gKiBEaXNwbGF5IHRoaXMgY29tbWFuZCdzIHRleHR1YWwgYWxlcnQgdmlhIGEgcHJvdmlkZWQgb3duZXIuXG4gKi9cblNheUNvbW1hbmQucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAob3duZXIpIHtcbiAgICB2YXIgbWVzc2FnZSA9IGdldEJvYXJkTWVzc2FnZShvd25lci5ib2FyZCwgdGhpcy50ZXh0KTtcbiAgICBvd25lci5ib2FyZC5zZXREaXNwbGF5TWVzc2FnZShtZXNzYWdlKTtcbiAgICByZXR1cm4gQ29tbWFuZFJlc3VsdC5DT05USU5VRTtcbn07XG5cbi8qKlxuICogU2Nyb2xsQ29tbWFuZFxuICpcbiAqIFdoZW4gZXhlY3V0ZWQsIGFkZHMgYSBsaW5lIG9mIHRleHQgdG8gYSBwcm92aWRlZCBvd25lcidzXG4gKiBzY3JpcHQgY29udGV4dCdzIHNjcm9sbCBxdWV1ZSwgd2l0aCBvcHRpb25hbCBib2xkIGZvcm1hdHRpbmdcbiAqIGFuZCBhbiBvcHRpb25hbCBqdW1wIGxhYmVsIGZvciBjcmVhdGluZyBjb21tYW5kIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIFNjcm9sbENvbW1hbmQodGV4dCwgYm9sZCwgbGFiZWwpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIHRoaXMuYm9sZCA9IGJvbGQ7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICAgIHRoaXMubW9kaWZpZXNTY3JvbGwgPSB0cnVlO1xufVxuXG4vKipcbiAqIEFkZHMgYSBsaW5lIG9mIHRleHQgYmFzZWQgb24gdGhpcyBjb21tYW5kJ3MgY29uZmlndXJhdGlvbiB0b1xuICogYSBwcm92aWRlZCBvd25lcidzIHNjcmlwdCBjb250ZXh0J3Mgc2Nyb2xsIHF1ZXVlLlxuICovXG5TY3JvbGxDb21tYW5kLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBnZXRCb2FyZE1lc3NhZ2Uob3duZXIuYm9hcmQsIHRoaXMudGV4dCk7XG4gICAgb3duZXIuc2NyaXB0Q29udGV4dC5hZGRTY3JvbGxDb250ZW50KG1lc3NhZ2UsIHRoaXMuYm9sZCwgdGhpcy5sYWJlbCk7XG4gICAgcmV0dXJuIENvbW1hbmRSZXN1bHQuQ09OVElOVUU7XG59O1xuXG4vKipcbiAqIFNlbmRDb21tYW5kXG4gKlxuICogV2hlbiBleGVjdXRlZCwgc2VuZHMgYSBtZXNzYWdlIHRvIGEgcHJvdmlkZWQgcmVjaXBpZW50IHZpYSBhXG4gKiBzcGVjaWZpZWQgb3duZXIuIElmIGEgcmVjaXBpZW50IGlzIFNFTEYsIHRoZW4gdGhlIG1lc3NhZ2UgaXNcbiAqIGRlbGl2ZXJlZCB0byB0aGUgb3duZXIgZGlyZWN0bHkuIElmIGEgcmVjaXBpZW50IGlzIEFMTCwgdGhlblxuICogdGhlIG1lc3NhZ2UgaXMgZGVsaXZlcmVkIHRvIGFsbCBzY3JpcHRhYmxlIHRoaW5ncyBvbiB0aGUgYm9hcmQuXG4gKi9cbmZ1bmN0aW9uIFNlbmRDb21tYW5kKHJlY2lwaWVudCwgbWVzc2FnZSkge1xuICAgIHRoaXMucmVjaXBpZW50ID0gcmVjaXBpZW50O1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlIHRvIGEgcHJvdmlkZWQgcmVjaXBpZW50IHZpYSBhIHNwZWNpZmllZCBvd25lci5cbiAqIElmIGEgcmVjaXBpZW50IGlzIFNFTEYsIHRoZW4gdGhlIG1lc3NhZ2UgaXMgZGVsaXZlcmVkIHRvIHRoZSBvd25lclxuICogZGlyZWN0bHkuIElmIGEgcmVjaXBpZW50IGlzIEFMTCwgdGhlbiB0aGUgbWVzc2FnZSBpcyBkZWxpdmVyZWRcbiAqIHRvIGFsbCBzY3JpcHRhYmxlIHRoaW5ncyBvbiB0aGUgYm9hcmQuXG4gKi9cblNlbmRDb21tYW5kLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKG93bmVyKSB7XG5cbiAgICB2YXIgcmVjaXBpZW50cyxcbiAgICAgICAgaW5kZXg7XG5cbiAgICBpZiAodGhpcy5yZWNpcGllbnQgPT09ICdTRUxGJykge1xuICAgICAgICBvd25lci5zY3JpcHRDb250ZXh0Lmp1bXBUb0xhYmVsKHRoaXMubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBDb21tYW5kUmVzdWx0LkNPTlRJTlVFX0FGVEVSX0pVTVA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVjaXBpZW50ID09PSAnQUxMJykge1xuICAgICAgICByZWNpcGllbnRzID0gb3duZXIuYm9hcmQuZ2V0U2NyaXBhYmxlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY2lwaWVudHMgPSBvd25lci5ib2FyZC5nZXRTY3JpcHRhYmxlcyh0aGlzLnJlY2lwaWVudCk7XG4gICAgfVxuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcmVjaXBpZW50cy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgcmVjaXBpZW50c1tpbmRleF0uc2VuZE1lc3NhZ2UodGhpcy5tZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gQ29tbWFuZFJlc3VsdC5DT05USU5VRTtcblxufTtcblxuLyoqXG4gKiBTZXRDb21tYW5kXG4gKlxuICogV2hlbiBleGVjdXRlZCwgc2V0cyBhIGNvdW50ZXIgdG8gYSBwcm92aWRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q29tbWFuZChjb3VudGVyLCB2YWx1ZSkge1xuICAgIHRoaXMuY291bnRlciA9IGNvdW50ZXI7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIFNldHMgYSBjb3VudGVyIHRvIHRoaXMgY29tbWFuZCdzIGFzc29jaWF0ZWQgdmFsdWUuXG4gKi9cblNldENvbW1hbmQucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAob3duZXIpIHtcbiAgICBvd25lci5ib2FyZC5nYW1lLnNldENvdW50ZXJWYWx1ZSh0aGlzLmNvdW50ZXIsIHRoaXMudmFsdWUpO1xufTtcblxuLyoqXG4gKiBTaG9vdENvbW1hbmRcbiAqXG4gKiBXaGVuIGV4ZWN1dGVkLCBhZGRzIGEgZGlyZWN0ZWQgYnVsbGV0IHRvIGFuIG93bmVyJ3MgYm9hcmQgcmVsYXRpdmVcbiAqIHRvIHRoZSBwb3NpdGlvbiBvZiB0aGUgb3duZXIuXG4gKi9cbmZ1bmN0aW9uIFNob290Q29tbWFuZChkaXJlY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgdGhpcy5kaXJlY3Rpb25FeHByZXNzaW9uID0gZGlyZWN0aW9uRXhwcmVzc2lvbjtcbn1cblxuLyoqXG4gKiBQbGFjZXMgYSBkaXJlY3RlZCBidWxsZXQgcmVsYXRpdmUgdG8gdGhlIHBvc2l0aW9uIG9mIGEgcHJvdmlkZWQgb3duZXIuXG4gKi9cblNob290Q29tbWFuZC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChvd25lcikge1xuXG4gICAgLy8gR2V0IG91ciBmaW5hbCBkaXJlY3Rpb25cbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb25FeHByZXNzaW9uLmdldFJlc3VsdChvd25lcik7XG5cbiAgICAvLyBJZiBhIGRpcmVjdGlvbiBpcyBhdmFpbGFibGVcbiAgICBpZiAoZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgLy8gUGxheSBhIHNob290aW5nIG5vaXNlXG4gICAgICAgIG93bmVyLnBsYXkoJ2MtZiMnKTtcblxuICAgICAgICAvLyBTaG9vdFxuICAgICAgICBUaGluZ0ZhY3Rvcnkuc2hvb3Qob3duZXIuYm9hcmQsIG93bmVyLnBvaW50LmFkZChkaXJlY3Rpb24pLCBkaXJlY3Rpb24sIGZhbHNlKTtcblxuICAgIH1cblxufTtcblxuLyoqXG4gKiBTdGFuZENvbW1hbmRcbiAqXG4gKiBXaGVuIGV4ZWN1dGVkLCBoYWx0cyBhbiBvd25lciBmcm9tIHdhbGtpbmcuXG4gKi9cbmZ1bmN0aW9uIFN0YW5kQ29tbWFuZCgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU3RhbmRDb21tYW5kKSkge1xuICAgICAgICB0aHJvdyBDb25zdHJ1Y3RvckVycm9yO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIYWx0cyBhIHByb3ZpZGVkIG93bmVyIGZyb20gd2Fsa2luZy5cbiAqL1xuU3RhbmRDb21tYW5kLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgb3duZXIud2Fsa0RpcmVjdGlvbiA9IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogVGFrZUNvbW1hbmRcbiAqXG4gKiBXaGVuIGV4ZWN1dGVkLCBzdWJ0cmFjdHMgYSBwcm92aWRlZCB2YWx1ZSBmcm9tIGEgZ2l2ZW4gY291bnRlci5cbiAqIElmIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBzdWJ0cmFjdCB0aGUgcmVxdWlyZWQgYW1vdW50LCB0aGVuIGV4ZWN1dGlvblxuICogc2hvdWxkIGp1bXAgdG8gYSBzcGVjaWZpZWQgbGFiZWwgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gVGFrZUNvbW1hbmQoY291bnRlciwgdmFsdWUsIGxhYmVsKSB7XG4gICAgdGhpcy5jb3VudGVyID0gY291bnRlcjtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xufVxuXG4vKipcbiAqIFN1YnRyYWN0cyBhIHByb3ZpZGVkIHZhbHVlIGZyb20gYSBnaXZlbiBjb3VudGVyLlxuICogSWYgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHN1YnRyYWN0IHRoZSByZXF1aXJlZCBhbW91bnQsIHRoZW4gZXhlY3V0aW9uXG4gKiBzaG91bGQganVtcCB0byBhIHNwZWNpZmllZCBsYWJlbCB3aXRoaW4gYSBwcm92aWRlZCBvd25lcidzIGNvbnRleHQgaW5zdGVhZC5cbiAqL1xuVGFrZUNvbW1hbmQucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAob3duZXIpIHtcblxuICAgIC8vIERlcGVuZGluZyBvbiBpZiB0aGVyZSdzIGVub3VnaCBjb3VudGVyIGF2YWlsYWJsZSB0byB0YWtlLi4uXG4gICAgaWYgKG93bmVyLmJvYXJkLmdhbWUuZ2V0Q291bnRlclZhbHVlKHRoaXMuY291bnRlcikgPCB0aGlzLnZhbHVlKSB7XG5cbiAgICAgICAgLy8gVGhlcmUgaXNuJ3QgZW5vdWdoIGNvdW50ZXIsIHNvIGlmIHdlJ3ZlIGdvdCBhIGxhYmVsLi4uXG4gICAgICAgIGlmICh0aGlzLmxhYmVsKSB7XG5cbiAgICAgICAgICAgIC8vIEp1bXAhXG4gICAgICAgICAgICBvd25lci5zY3JpcHRDb250ZXh0Lmp1bXBUb0xhYmVsKHRoaXMubGFiZWwpO1xuICAgICAgICAgICAgcmV0dXJuIENvbW1hbmRSZXN1bHQuQ09OVElOVUVfQUZURVJfSlVNUDtcblxuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFRha2UgYXdheSBvdXIgY291bnRlciB2YWx1ZVxuICAgICAgICBvd25lci5ib2FyZC5nYW1lLmFkanVzdENvdW50ZXIodGhpcy5jb3VudGVyLCAtMSAqIHRoaXMudmFsdWUpO1xuICAgICAgICByZXR1cm4gQ29tbWFuZFJlc3VsdC5DT05USU5VRTtcblxuICAgIH1cbn07XG5cbi8qKlxuICogVGhyb3dTdGFyIENvbW1hbmRcbiAqXG4gKiBXaGVuIGV4ZWN1dGVkLCBsYXVuY2hlcyBhIHRocm93aW5nIHN0YXIgaW4gYSBkaXJlY3Rpb24gcmVsYXRpdmVcbiAqIHRvIHRoaXMgY29tbWFuZCdzIHByb3ZpZGVkIG93bmVyLlxuICovXG5mdW5jdGlvbiBUaHJvd1N0YXJDb21tYW5kKGRpcmVjdGlvbkV4cHJlc3Npb24pIHtcbiAgICB0aGlzLmRpcmVjdGlvbkV4cHJlc3Npb24gPSBkaXJlY3Rpb25FeHByZXNzaW9uO1xufVxuXG4vKipcbiAqIExhdW5jaGVzIGEgdGhyb3dpbmcgc3RhciBpbiBhIGRpcmVjdGlvbiByZWxhdGl2ZSB0byBhIHByb3ZpZGVkIG93bmVyLlxuICovXG5UaHJvd1N0YXJDb21tYW5kLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgLy8gR2V0IG91ciBmaW5hbCBkaXJlY3Rpb25cbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb25FeHByZXNzaW9uLmdldFJlc3VsdChvd25lcik7XG5cbiAgICAvLyBJZiBhIGRpcmVjdGlvbiBpcyBhdmFpbGFibGVcbiAgICBpZiAoZGlyZWN0aW9uKSB7XG5cbiAgICAgICAgLy8gU2hvb3RcbiAgICAgICAgVGhpbmdGYWN0b3J5LnNob290KG93bmVyLmJvYXJkLCBvd25lci5wb2ludC5hZGQoZGlyZWN0aW9uKSwgZGlyZWN0aW9uLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICB9XG59O1xuXG4vKipcbiAqIFRvcmNoIENvbW1hbmRcbiAqXG4gKiBXaGVuIGV4ZWN1dGVzLCBzZXRzIGFuIG93bmVyJ3MgdG9yY2ggcmFkaXVzIHRvIHRoaXMgY29tbWFuZCdzIGFzc29jaWF0ZWRcbiAqIHJhZGl1cy5cbiAqL1xuZnVuY3Rpb24gVG9yY2hDb21tYW5kKHJhZGl1cykge1xuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xufVxuXG4vKipcbiAqIFNldHMgYW4gb3duZXIncyB0b3JjaCByYWRpdXMgdG8gdGhpcyBjb21tYW5kJ3MgYXNzb2NpYXRlZFxuICogcmFkaXVzLlxuICovXG5Ub3JjaENvbW1hbmQucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAob3duZXIpIHtcbiAgICBvd25lci5zZXRUb3JjaFJhZGl1cyh0aGlzLnJhZGl1cyk7XG59O1xuXG4vKipcbiAqIFVubG9ja0NvbW1hbmRcbiAqXG4gKiBXaGVuIGV4ZWN1dGVkLCBzZXRzIGEgcHJvdmlkZWQgb3duZXIncyBsb2NrZWQgc3RhdGUgdG8gZmFsc2UsXG4gKiBhbGxvd2luZyBpdCB0byBvbmNlIGFnYWluIHJlY2VpdmUgbWVzc2FnZXMgZnJvbSBvdGhlclxuICogU2NyaXB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIFVubG9ja0NvbW1hbmQoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVubG9ja0NvbW1hbmQpKSB7XG4gICAgICAgIHRocm93IENvbnN0cnVjdG9yRXJyb3I7XG4gICAgfVxufVxuXG4vKipcbiAqIFNldHMgYSBwcm92aWRlZCBvd25lcidzIGxvY2tlZCBzdGF0ZSB0byBmYWxzZSxcbiAqIGFsbG93aW5nIGl0IHRvIG9uY2UgYWdhaW4gcmVjZWl2ZSBtZXNzYWdlcyBmcm9tIG90aGVyXG4gKiBTY3JpcHRhYmxlcy5cbiAqL1xuVW5sb2NrQ29tbWFuZC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChvd25lcikge1xuICAgIG93bmVyLmxvY2tlZCA9IGZhbHNlO1xuICAgIHJldHVybiBDb21tYW5kUmVzdWx0LkNPTlRJTlVFO1xufTtcblxuLyoqXG4gKiBWaWN0b3J5Q29tbWFuZFxuICpcbiAqIFdoZW4gZXhlY3V0ZWQsIHNldHMgdGhlIG93bmVyJ3MgZ2FtZSdzIHN0YXRlIHRvIFZpY3RvcnkuXG4gKi9cbmZ1bmN0aW9uIFZpY3RvcnlDb21tYW5kKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBWaWN0b3J5Q29tbWFuZCkpIHtcbiAgICAgICAgdGhyb3cgQ29uc3RydWN0b3JFcnJvcjtcbiAgICB9XG59XG5cbi8qKlxuICogU2V0cyBhIHByb3ZpZGVkIG93bmVyJ3MgZ2FtZSdzIHN0YXRlIHRvIHZpY3RvcnkuXG4gKi9cblZpY3RvcnlDb21tYW5kLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgb3duZXIuYm9hcmQuZ2FtZS5zZXRTdGF0ZShHYW1lU3RhdGUuVmljdG9yeSk7XG59O1xuXG4vKipcbiAqIFdhaXRDb21tYW5kXG4gKlxuICogV2hlbiBleGVjdXRlZCwgcGF1c2VzIHNjcmlwdCBleGVjdXRpb24gZm9yIGEgbnVtYmVyXG4gKiBvZiBzcGVjaWZpZWQgY3ljbGVzLlxuICovXG5mdW5jdGlvbiBXYWl0Q29tbWFuZChjb3VudCkge1xuICAgIHRoaXMuY291bnQgPSBjb3VudDtcbn1cblxuLyoqXG4gKiBQYXVzZXMgc2NyaXB0IGV4ZWN1dGlvbiBmb3IgYSBudW1iZXJcbiAqIG9mIHNwZWNpZmllZCBjeWNsZXMuXG4gKi9cbldhaXRDb21tYW5kLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKG93bmVyKSB7XG5cbiAgICB2YXIgaGVhcCA9IG93bmVyLnNjcmlwdENvbnRleHQuaGVhcCxcbiAgICAgICAgY3ljbGVzID0gJzxjeWNsZXM+JztcblxuICAgIGlmICghaGVhcFtjeWNsZXNdKSB7XG4gICAgICAgIGhlYXBbY3ljbGVzXSA9IHRoaXMuY291bnQ7XG4gICAgfVxuXG4gICAgaGVhcFtjeWNsZXNdIC09IDE7XG4gICAgaWYgKGhlYXBbY3ljbGVzXSA+IDApIHtcbiAgICAgICAgcmV0dXJuIENvbW1hbmRSZXN1bHQuUkVQRUFUO1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3ZlIGdvdCBubyBtb3JlIGhlYXAgY3ljbGVzLCBkZWxldGUgaXQgZW50aXJlbHlcbiAgICBkZWxldGUgaGVhcFtjeWNsZXNdO1xuXG59O1xuXG4vKipcbiAqIFdhbGtDb21tYW5kXG4gKlxuICogV2hlbiBleGVjdXRlZCwgaW5zdHJ1Y3RzIGEgcHJvdmlkZWQgb3duZXIgdG8gYmVnaW4gd2Fsa2luZ1xuICogaW4gYSBkaXJlY3Rpb24gYXMgZXZhbHVhdGVkIGJ5IHRoaXMgY29tbWFuZCdzIHByb3ZpZGVkXG4gKiBkaXJlY3Rpb24gZXhwcmVzc2lvbjtcbiAqL1xuZnVuY3Rpb24gV2Fsa0NvbW1hbmQoZGlyZWN0aW9uRXhwcmVzc2lvbikge1xuICAgIHRoaXMuZGlyZWN0aW9uRXhwcmVzc2lvbiA9IGRpcmVjdGlvbkV4cHJlc3Npb247XG59XG5cbi8qKlxuICogSW5zdHJ1Y3RzIGEgcHJvdmlkZWQgb3duZXIgdG8gYmVnaW4gd2Fsa2luZ1xuICogaW4gYSBkaXJlY3Rpb24gYXMgZXZhbHVhdGVkIGJ5IHRoaXMgY29tbWFuZCdzIHByb3ZpZGVkXG4gKiBkaXJlY3Rpb24gZXhwcmVzc2lvbjtcbiAqL1xuV2Fsa0NvbW1hbmQucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAob3duZXIpIHtcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb25FeHByZXNzaW9uLmdldFJlc3VsdChvd25lcik7XG4gICAgb3duZXIud2Fsa0RpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICByZXR1cm4gQ29tbWFuZFJlc3VsdC5DT05USU5VRTtcbn07XG5cbi8qKlxuICogWmFwQ29tbWFuZFxuICpcbiAqIFdoZW4gZXhlY3V0ZWQsIHphcHMgYSBwcm92aWRlZCBsYWJlbCBmcm9tIGFuIG93bmVyJ3Mgc2NyaXB0XG4gKiBjb250ZXh0LlxuICovXG5mdW5jdGlvbiBaYXBDb21tYW5kKGxhYmVsKSB7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xufVxuXG4vKipcbiAqIFphcHMgYSBwcm92aWRlZCBsYWJlbCBmcm9tIGFuIG93bmVyJ3Mgc2NyaXB0IGNvbnRleHQuXG4gKi9cblphcENvbW1hbmQucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAob3duZXIpIHtcbiAgICBvd25lci5zY3JpcHRDb250ZXh0LnphcExhYmVsKHRoaXMubGFiZWwpO1xuICAgIHJldHVybiBDb21tYW5kUmVzdWx0LkNPTlRJTlVFO1xufTtcblxuLy8gRVhQUkVTU0lPTlMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogTm90RXhwcmVzc2lvblxuICovXG5mdW5jdGlvbiBOb3RFeHByZXNzaW9uKGV4cHJlc3Npb24pIHtcbiAgICB0aGlzLnN1YkV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xufVxuXG5Ob3RFeHByZXNzaW9uLnByb3RvdHlwZS5nZXRSZXN1bHQgPSBmdW5jdGlvbiAob3duZXIpIHtcbiAgICByZXR1cm4gIXRoaXMuc3ViRXhwcmVzc2lvbi5nZXRSZXN1bHQob3duZXIpO1xufTtcblxuLyoqXG4gKiBBZGphY2VudEV4cHJlc3Npb25cbiAqL1xuZnVuY3Rpb24gQWRqYWNlbnRFeHByZXNzaW9uKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBBZGphY2VudEV4cHJlc3Npb24pKSB7XG4gICAgICAgIHRocm93IENvbnN0cnVjdG9yRXJyb3I7XG4gICAgfVxufVxuXG5BZGphY2VudEV4cHJlc3Npb24ucHJvdG90eXBlLmdldFJlc3VsdCA9IGZ1bmN0aW9uIChvd25lcikge1xuICAgIHJldHVybiBvd25lci5pc1BsYXllckFkamFjZW50KCk7XG59O1xuXG4vKipcbiAqIEJsb2NrZWRFeHByZXNzaW9uXG4gKi9cbmZ1bmN0aW9uIEJsb2NrZWRFeHByZXNzaW9uKGRpcmVjdGlvbkV4cHJlc3Npb24pIHtcbiAgICB0aGlzLmRpcmVjdGlvbkV4cHJlc3Npb24gPSBkaXJlY3Rpb25FeHByZXNzaW9uO1xufVxuXG5CbG9ja2VkRXhwcmVzc2lvbi5wcm90b3R5cGUuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgcmV0dXJuIG93bmVyLmlzQmxvY2tlZCh0aGlzLmRpcmVjdGlvbkV4cHJlc3Npb24uZ2V0UmVzdWx0KG93bmVyKSk7XG59O1xuXG4vKipcbiAqIEFsaWduZWRFeHByZXNzaW9uXG4gKi9cbmZ1bmN0aW9uIEFsaWduZWRFeHByZXNzaW9uKGRpcmVjdGlvbkV4cHJlc3Npb24pIHtcbiAgICB0aGlzLmRpcmVjdGlvbkV4cHJlc3Npb24gPSBkaXJlY3Rpb25FeHByZXNzaW9uO1xufVxuXG5BbGlnbmVkRXhwcmVzc2lvbi5wcm90b3R5cGUuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uRXhwcmVzc2lvbiA/IG93bmVyLmlzUGxheWVyQWxpZ25lZCgxLCB0aGlzLmRpcmVjdGlvbkV4cHJlc3Npb24uZ2V0UmVzdWx0KG93bmVyKSkgOiBvd25lci5pc1BsYXllckFsaWduZWQoMSk7XG59O1xuXG4vKipcbiAqIFBlZXBFeHByZXNzaW9uXG4gKi9cbmZ1bmN0aW9uIFBlZXBFeHByZXNzaW9uKHJhZGl1cykge1xuICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xufVxuXG5QZWVwRXhwcmVzc2lvbi5wcm90b3R5cGUuZ2V0UmVzdWx0ID0gZnVuY3Rpb24gKG93bmVyKSB7XG4gICAgcmV0dXJuIG93bmVyLmlzUGxheWVyVmlzaWJsZSh0aGlzLnJhZGl1cyk7XG59O1xuXG4vKipcbiAqIEV4aXN0c0V4cHJlc3Npb25cbiAqL1xuZnVuY3Rpb24gRXhpc3RzRXhwcmVzc2lvbih0aGluZ1RlbXBsYXRlLCBjb3VudCkge1xuICAgIHRoaXMudGhpbmdUZW1wbGF0ZSA9IHRoaW5nVGVtcGxhdGU7XG4gICAgdGhpcy5jb3VudCA9IGNvdW50O1xufVxuXG5FeGlzdHNFeHByZXNzaW9uLnByb3RvdHlwZS5nZXRSZXN1bHQgPSBmdW5jdGlvbiAob3duZXIpIHtcbiAgICByZXR1cm4gb3duZXIuYm9hcmQuaGFzVGlsZSh0aGlzLnRoaW5nVGVtcGxhdGUsIHRoaXMuY291bnQpO1xufTtcblxuLyoqXG4gKiBUZXN0aW5nRXhwcmVzc2lvblxuICovXG5mdW5jdGlvbiBUZXN0aW5nRXhwcmVzc2lvbihjb3VudGVyLCBvcGVyYW5kLCB2YWx1ZSkge1xuICAgIHRoaXMuY291bnRlciA9IGNvdW50ZXI7XG4gICAgdGhpcy5vcGVyYW5kID0gb3BlcmFuZDtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG59XG5cblRlc3RpbmdFeHByZXNzaW9uLnByb3RvdHlwZS5nZXRSZXN1bHQgPSBmdW5jdGlvbiAob3duZXIpIHtcblxuICAgIC8vIEdldCBvdXIgY291bnRlciB2YWx1ZVxuICAgIHZhciBjb3VudGVyVmFsdWUgPSBvd25lci5nZXRDb3VudGVyVmFsdWUodGhpcy5jb3VudGVyKTtcblxuICAgIHN3aXRjaCAodGhpcy5vcGVyYW5kKSB7XG4gICAgY2FzZSAnPic6XG4gICAgICAgIHJldHVybiBjb3VudGVyVmFsdWUgPiB0aGlzLnZhbHVlO1xuICAgIGNhc2UgJzwnOlxuICAgICAgICByZXR1cm4gY291bnRlclZhbHVlIDwgdGhpcy52YWx1ZTtcbiAgICBjYXNlICc+PSc6XG4gICAgICAgIHJldHVybiBjb3VudGVyVmFsdWUgPj0gdGhpcy52YWx1ZTtcbiAgICBjYXNlICc8PSc6XG4gICAgICAgIHJldHVybiBjb3VudGVyVmFsdWUgPD0gdGhpcy52YWx1ZTtcbiAgICBjYXNlICc9JzpcbiAgICAgICAgcmV0dXJuIGNvdW50ZXJWYWx1ZSA9PT0gdGhpcy52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLy8gUFVCTElDIElOVEVSRkFDRSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydHMuQ29tbWFuZFJlc3VsdCA9IENvbW1hbmRSZXN1bHQ7XG5cbmV4cG9ydHMuRGlyZWN0aW9uTW9kaWZpZXIgPSBEaXJlY3Rpb25Nb2RpZmllcjtcbmV4cG9ydHMuRGlyZWN0aW9uID0gRGlyZWN0aW9uO1xuXG5leHBvcnRzLkRpcmVjdGlvbkV4cHJlc3Npb24gPSBEaXJlY3Rpb25FeHByZXNzaW9uO1xuXG5leHBvcnRzLkxhYmVsID0gTGFiZWw7XG5cbmV4cG9ydHMuQmVjb21lQ29tbWFuZCA9IEJlY29tZUNvbW1hbmQ7XG5leHBvcnRzLkNoYW5nZUNvbW1hbmQgPSBDaGFuZ2VDb21tYW5kO1xuZXhwb3J0cy5DaGFyQ29tbWFuZCA9IENoYXJDb21tYW5kO1xuZXhwb3J0cy5EaWVDb21tYW5kID0gRGllQ29tbWFuZDtcbmV4cG9ydHMuRW5kQ29tbWFuZCA9IEVuZENvbW1hbmQ7XG5leHBvcnRzLkdpdmVDb21tYW5kID0gR2l2ZUNvbW1hbmQ7XG5leHBvcnRzLklmQ29tbWFuZCA9IElmQ29tbWFuZDtcbmV4cG9ydHMuTG9ja0NvbW1hbmQgPSBMb2NrQ29tbWFuZDtcbmV4cG9ydHMuTW92ZUNvbW1hbmQgPSBNb3ZlQ29tbWFuZDtcbmV4cG9ydHMuUGxheUNvbW1hbmQgPSBQbGF5Q29tbWFuZDtcbmV4cG9ydHMuUHV0Q29tbWFuZCA9IFB1dENvbW1hbmQ7XG5leHBvcnRzLlNjcm9sbENvbW1hbmQgPSBTY3JvbGxDb21tYW5kO1xuZXhwb3J0cy5TZW5kQ29tbWFuZCA9IFNlbmRDb21tYW5kO1xuZXhwb3J0cy5TZXRDb21tYW5kID0gU2V0Q29tbWFuZDtcbmV4cG9ydHMuVGFrZUNvbW1hbmQgPSBUYWtlQ29tbWFuZDtcbmV4cG9ydHMuVGhyb3dTdGFyQ29tbWFuZCA9IFRocm93U3RhckNvbW1hbmQ7XG5leHBvcnRzLlRvcmNoQ29tbWFuZCA9IFRvcmNoQ29tbWFuZDtcbmV4cG9ydHMuUmVzdG9yZUNvbW1hbmQgPSBSZXN0b3JlQ29tbWFuZDtcbmV4cG9ydHMuU2F5Q29tbWFuZCA9IFNheUNvbW1hbmQ7XG5leHBvcnRzLlNob290Q29tbWFuZCA9IFNob290Q29tbWFuZDtcbmV4cG9ydHMuU3RhbmRDb21tYW5kID0gU3RhbmRDb21tYW5kO1xuZXhwb3J0cy5VbmxvY2tDb21tYW5kID0gVW5sb2NrQ29tbWFuZDtcbmV4cG9ydHMuVmljdG9yeUNvbW1hbmQgPSBWaWN0b3J5Q29tbWFuZDtcbmV4cG9ydHMuV2FpdENvbW1hbmQgPSBXYWl0Q29tbWFuZDtcbmV4cG9ydHMuV2Fsa0NvbW1hbmQgPSBXYWxrQ29tbWFuZDtcbmV4cG9ydHMuWmFwQ29tbWFuZCA9IFphcENvbW1hbmQ7XG5cbmV4cG9ydHMuTm90RXhwcmVzc2lvbiA9IE5vdEV4cHJlc3Npb247XG5leHBvcnRzLkFkamFjZW50RXhwcmVzc2lvbiA9IEFkamFjZW50RXhwcmVzc2lvbjtcbmV4cG9ydHMuQmxvY2tlZEV4cHJlc3Npb24gPSBCbG9ja2VkRXhwcmVzc2lvbjtcbmV4cG9ydHMuQWxpZ25lZEV4cHJlc3Npb24gPSBBbGlnbmVkRXhwcmVzc2lvbjtcbmV4cG9ydHMuUGVlcEV4cHJlc3Npb24gPSBQZWVwRXhwcmVzc2lvbjtcbmV4cG9ydHMuRXhpc3RzRXhwcmVzc2lvbiA9IEV4aXN0c0V4cHJlc3Npb247XG5leHBvcnRzLlRlc3RpbmdFeHByZXNzaW9uID0gVGVzdGluZ0V4cHJlc3Npb247XG4iLCIvKipcbiAqIEpaVFNjcmlwdCBDb250ZXh0XG4gKiBDb3B5cmlnaHQgwqkgMjAxNCBPcmFuZ2VsaW5lIEludGVyYWN0aXZlLCBJbmMuXG4gKiBAYXV0aG9yIE1hcmsgTWNJbnR5cmVcbiAqL1xuXG4vKmpzbGludCBub2RlOnRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2FtZVN0YXRlID0gcmVxdWlyZSgnLi9nYW1lLXN0YXRlJykuR2FtZVN0YXRlLFxuICAgIGNvbW1hbmRzID0gcmVxdWlyZSgnLi9qenQtc2NyaXB0LWNvbW1hbmRzJyk7XG5cbi8qKlxuICogQSBTY3JpcHRDb250ZXh0IGlzIGEgY29udGV4dCBpbiB3aGljaCBhIHNjcmlwdCBjYW4gcnVuLCBpbmNsdWRpbmcgYW4gYXNzb2NpYXRlZFxuICogU2NyaXB0YWJsZSwgYSBjdXJyZW50IGV4ZWN1dGlvbiBpbmRleCwgbGFiZWxzLCBhbmQgbW9yZS5cbiAqXG4gKiBAcGFyYW0gc2NyaXB0IEEgc2NyaXB0IHdoaWNoIHRoaXMgU2NyaXB0Q29udGV4dCBpcyBzZXQgdG8gZXhlY3V0ZS5cbiAqIEBwYXJhbSBvd25lciBBIFNjcmlwdGFibGUgdG8gb3duIHRoaXMgU2NyaXB0Q29udGV4dC5cbiAqL1xuZnVuY3Rpb24gSnp0U2NyaXB0Q29udGV4dChzY3JpcHQsIG93bmVyKSB7XG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuICAgIHRoaXMuY29tbWFuZEluZGV4ID0gMDtcbiAgICB0aGlzLmN1cnJlbnRMYWJlbHMgPSB7fTtcbiAgICB0aGlzLmhlYXAgPSB7fTtcbiAgICB0aGlzLmluaXRpYWxpemVMYWJlbHMoc2NyaXB0KTtcbiAgICB0aGlzLnNjcm9sbENvbnRlbnQgPSBbXTtcbiAgICB0aGlzLmp1bXBDb3VudCA9IDA7XG59XG5cbi8qKlxuICogU2VyaWFsaXplcyB0aGlzIEp6dFNjcmlwdENvbnRleHQgdG8gYSBkYXRhIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIEEgZGF0YSBvYmplY3QgcmVwcmVzZW50aW5nIHRoaXMgSnp0U2NyaXB0Q29udGV4dC5cbiAqL1xuSnp0U2NyaXB0Q29udGV4dC5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHJlc3VsdCA9IHt9LFxuICAgICAgICBsYWJlbDtcbiAgICByZXN1bHQuY29tbWFuZEluZGV4ID0gdGhpcy5jb21tYW5kSW5kZXg7XG4gICAgcmVzdWx0LmN1cnJlbnRMYWJlbHMgPSB7fTtcbiAgICByZXN1bHQuaGVhcCA9IHRoaXMuaGVhcDtcbiAgICBmb3IgKGxhYmVsIGluIHRoaXMuY3VycmVudExhYmVscykge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50TGFiZWxzLmhhc093blByb3BlcnR5KGxhYmVsKSAmJiB0aGlzLmN1cnJlbnRMYWJlbHNbbGFiZWxdKSB7XG4gICAgICAgICAgICByZXN1bHQuY3VycmVudExhYmVsc1tsYWJlbF0gPSB0aGlzLmN1cnJlbnRMYWJlbHNbbGFiZWxdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcblxufTtcblxuLyoqXG4gKiBEZS1zZXJpYWxpemVzIGEgcHJvdmlkZWQgZGF0YSBvYmplY3QgdG8gaW5pdGlhbGl6ZSB0aGlzIEp6dFNjcmlwdENvbnRleHQuXG4gKlxuICogQHBhcmFtIGRhdGEgQSBzZXJpYWxpemVkIEp6dFNjcmlwdENvbnRleHQuXG4gKi9cbkp6dFNjcmlwdENvbnRleHQucHJvdG90eXBlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKGRhdGEpIHtcblxuICAgIHZhciBsYWJlbDtcblxuICAgIHRoaXMuY29tbWFuZEluZGV4ID0gZGF0YS5jb21tYW5kSW5kZXg7XG4gICAgdGhpcy5oZWFwID0gZGF0YS5oZWFwO1xuICAgIGZvciAobGFiZWwgaW4gZGF0YS5jdXJyZW50TGFiZWxzKSB7XG4gICAgICAgIGlmIChkYXRhLmN1cnJlbnRMYWJlbHMuaGFzT3duUHJvcGVydHkobGFiZWwpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRMYWJlbHNbbGFiZWxdID0gZGF0YS5jdXJyZW50TGFiZWxzW2xhYmVsXTtcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBhIGRlZmF1bHQgc3RhdGUgZm9yIHRoaXMgSnp0U2NyaXB0Q29udGV4dC5cbiAqIEEgc2NyaXB0IGNvbnRleHQgdGhhdCdzIGluIGl0cyBkZWZhdWx0IHN0YXRlIGhhcyBubyBuZWVkIG9mIGJlaW5nIHNlcmlhbGl6ZWQuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIGluIGEgZGVmYXVsdCBzdGF0ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5KenRTY3JpcHRDb250ZXh0LnByb3RvdHlwZS5pbkRlZmF1bHRTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBkZWZhdWx0U3RhdGUgPSB0cnVlLFxuICAgICAgICBsYWJlbEluZGV4O1xuXG4gICAgLy8gTG9vayBmb3IgZXZpZGVuY2UgdGhhdCB3ZSdyZSBub3QgaW4gYSBkZWZhdWx0IHN0YXRlXG4gICAgaWYgKHRoaXMuY29tbWFuZEluZGV4ID4gMCkge1xuXG4gICAgICAgIC8vIFdlIGFyZW4ndCBhdCB0aGUgZmlyc3QgY29tbWFuZFxuICAgICAgICBkZWZhdWx0U3RhdGUgPSBmYWxzZTtcblxuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmtleXModGhpcy5oZWFwKS5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgLy8gVGhlIGhlYXAgaXMgbm90IGVtcHR5XG4gICAgICAgIGRlZmF1bHRTdGF0ZSA9IGZhbHNlO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvLyBXZSBoYXZlIHNvbWUgbm9uLXplcm8gbGFiZWwgaW5kaWNpZXNcbiAgICAgICAgZm9yIChsYWJlbEluZGV4IGluIHRoaXMuY3VycmVudExhYmVscykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudExhYmVscy5oYXNPd25Qcm9wZXJ0eShsYWJlbEluZGV4KSAmJiB0aGlzLmN1cnJlbnRMYWJlbHNbbGFiZWxJbmRleF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0U3RhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRTdGF0ZTtcblxufTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGlzIEp6dFNjcmlwdENvbnRleHQncyBsYWJlbHMgdG8gdGhhdCBvZiBhIHByb3ZpZGVkIFNjcmlwdCBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gc2NyaXB0IEEgU2NyaXB0IHVzZWQgdG8gaW5pdGlhbGl6ZSB0aGlzIEp6dFNjcmlwdENvbnRleHQncyBsYWJlbHMuXG4gKi9cbkp6dFNjcmlwdENvbnRleHQucHJvdG90eXBlLmluaXRpYWxpemVMYWJlbHMgPSBmdW5jdGlvbiAoc2NyaXB0KSB7XG4gICAgdmFyIGxhYmVsO1xuICAgIGZvciAobGFiZWwgaW4gc2NyaXB0LmxhYmVsSW5kaWNpZXMpIHtcbiAgICAgICAgaWYgKHNjcmlwdC5sYWJlbEluZGljaWVzLmhhc093blByb3BlcnR5KGxhYmVsKSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TGFiZWxzW2xhYmVsXSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyB3aGV0aGVyIG9yIG5vdCB0aGlzIEp6dFNjcmlwdENvbnRleHQgaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoaXMgSnp0U2NyaXB0Q29udGV4dCBpcyBydW5uaW5nLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkp6dFNjcmlwdENvbnRleHQucHJvdG90eXBlLmlzUnVubmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21tYW5kSW5kZXggPj0gMCAmJiB0aGlzLmNvbW1hbmRJbmRleCA8IHRoaXMuc2NyaXB0LmNvbW1hbmRzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogU3RvcHMgcnVubmluZyB0aGlzIEp6dFNjcmlwdENvbnRleHQuXG4gKi9cbkp6dFNjcmlwdENvbnRleHQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jb21tYW5kSW5kZXggPSAtMTtcbn07XG5cbkp6dFNjcmlwdENvbnRleHQucHJvdG90eXBlLmFkZFNjcm9sbENvbnRlbnQgPSBmdW5jdGlvbiAobGluZSwgY2VudGVyLCBsaW5lTGFiZWwpIHtcbiAgICB2YXIgbmV3TGluZSA9IHtcbiAgICAgICAgJ3RleHQnOiBsaW5lLFxuICAgICAgICAnY2VudGVyJzogY2VudGVyLFxuICAgICAgICAnbGFiZWwnOiBsaW5lTGFiZWxcbiAgICB9O1xuICAgIHRoaXMuc2Nyb2xsQ29udGVudC5wdXNoKG5ld0xpbmUpO1xufTtcblxuSnp0U2NyaXB0Q29udGV4dC5wcm90b3R5cGUuZGlzcGxheVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5kZXgsXG4gICAgICAgIGxpbmU7XG5cbiAgICB0aGlzLm93bmVyLmJvYXJkLmdhbWUuc2Nyb2xsLnNldFRpdGxlKHRoaXMub3duZXIubmFtZSk7XG4gICAgdGhpcy5vd25lci5ib2FyZC5nYW1lLnNjcm9sbC5jbGVhckxpbmVzKCk7XG4gICAgdGhpcy5vd25lci5ib2FyZC5nYW1lLnNjcm9sbC5saXN0ZW5lciA9IHRoaXMub3duZXI7XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnNjcm9sbENvbnRlbnQubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgIGxpbmUgPSB0aGlzLnNjcm9sbENvbnRlbnRbaW5kZXhdO1xuICAgICAgICB0aGlzLm93bmVyLmJvYXJkLmdhbWUuc2Nyb2xsLmFkZExpbmUobGluZS50ZXh0LCBsaW5lLmNlbnRlciwgbGluZS5sYWJlbCk7XG4gICAgfVxuXG4gICAgdGhpcy5zY3JvbGxDb250ZW50ID0gW107XG4gICAgdGhpcy5vd25lci5ib2FyZC5nYW1lLnNldFN0YXRlKEdhbWVTdGF0ZS5SZWFkaW5nKTtcblxufTtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIHNpbmdsZSB0aWNrIG9mIHRoaXMgSnp0U2NyaXB0Q29udGV4dCwgdGFraW5nIGEgY29tbWFuZCBmcm9tIGl0cyBhc3NvY2lhdGVkXG4gKiBTY3JpcHQgYW5kIGV4ZWN1dGluZyBpdC5cbiAqL1xuSnp0U2NyaXB0Q29udGV4dC5wcm90b3R5cGUuZXhlY3V0ZVRpY2sgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgbWVzc2FnZSxcbiAgICAgICAgY29tbWFuZCxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgLy8gSWYgb3VyIG93bmVyIGhhcyBhIG1lc3NhZ2Ugd2FpdGluZy4uLlxuICAgIGlmICh0aGlzLm93bmVyLm1lc3NhZ2VRdWV1ZS5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgLy8gR3JhYiBvdXIgbW9zdCByZWNlbnQgbWVzc2FnZVxuICAgICAgICBtZXNzYWdlID0gdGhpcy5vd25lci5tZXNzYWdlUXVldWUuc2hpZnQoKTtcblxuICAgICAgICAvLyBJZiB3ZSB3ZXJlIGFibGUgdG8gcmVjZWl2ZSB0aGlzIG1lc3NhZ2VcbiAgICAgICAgaWYgKCF0aGlzLm93bmVyLmxvY2tlZCkge1xuICAgICAgICAgICAgdGhpcy5qdW1wVG9MYWJlbChtZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKCkpIHtcblxuICAgICAgICAvLyBGZXRjaCBhIG5ldyBjb21tYW5kXG4gICAgICAgIGNvbW1hbmQgPSB0aGlzLnNjcmlwdC5nZXRDb21tYW5kKHRoaXMuY29tbWFuZEluZGV4KTtcblxuICAgICAgICBpZiAoY29tbWFuZCkge1xuXG4gICAgICAgICAgICByZXN1bHQgPSBjb21tYW5kLmV4ZWN1dGUodGhpcy5vd25lcik7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBjb21tYW5kIGRvZXNuJ3QgbW9kaWZ5IHRoZSBzY3JvbGwsIGFuZCB0aGVyZSdzIHNjcm9sbCBjb250ZW50Li4uXG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxDb250ZW50Lmxlbmd0aCA+IDAgJiYgIWNvbW1hbmQubW9kaWZpZXNTY3JvbGwpIHtcblxuICAgICAgICAgICAgICAgIC8vIEl0J3MgdGltZSB0byBzaG93IHRoZSBzY3JvbGwgY29udGVudFxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheVNjcm9sbCgpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAocmVzdWx0KSB7XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbCBleGVjdXRpb24sIGFkdmFuY2UgbGluZVxuICAgICAgICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgICAgICBjYXNlIGNvbW1hbmRzLkNvbW1hbmRSZXN1bHQuTk9STUFMOlxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZUxpbmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmVUaWNrKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgYSBzZWNvbmQgdGlja1xuICAgICAgICAgICAgY2FzZSBjb21tYW5kcy5Db21tYW5kUmVzdWx0LkNPTlRJTlVFOlxuICAgICAgICAgICAgICAgIHRoaXMuYWR2YW5jZUxpbmUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV4ZWN1dGVUaWNrKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIE5vcm1hbCBleGVjdXRpb24sIGFzc3VtaW5nIHRoZSBjb3VudGVyIGlzIGF0IHRoZSByaWdodCBsb2NhdGlvblxuICAgICAgICAgICAgY2FzZSBjb21tYW5kcy5Db21tYW5kUmVzdWx0LkNPTlRJTlVFX0FGVEVSX0pVTVA6XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlbid0IGp1bXBlZCB0b28gbWFueSB0aW1lcyBhbHJlYWR5LCBnbyBhaGVhZFxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UncmUgZG9uZSBmb3IgdGhpcyB0aWNrLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmp1bXBDb3VudCA8PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhlY3V0ZVRpY2soKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvbmVUaWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBFeGVjdXRlIHRoZSBzYW1lIGNvbW1hbmQgbmV4dCB0aWNrXG4gICAgICAgICAgICBjYXNlIGNvbW1hbmRzLkNvbW1hbmRSZXN1bHQuUkVQRUFUOlxuICAgICAgICAgICAgICAgIHRoaXMuZG9uZVRpY2soKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyAnVW5leHBlY3RlZCBjb21tYW5kIGV4ZWN1dGlvbi4nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCB0aGlzIHNjcmlwdCBpcyBkb25lIGV4ZWN1dGluZyBmb3IgdGhpcyB0aWNrLlxuICovXG5KenRTY3JpcHRDb250ZXh0LnByb3RvdHlwZS5kb25lVGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmp1bXBDb3VudCA9IDA7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGFjdGl2ZSBjb21tYW5kIG9mIHRoaXMgSnp0U2NyaXB0Q29udGV4dCB0byB0aGF0IG9mIGEgcHJvdmlkZWQgbGFiZWxcbiAqIG5hbWUuXG4gKlxuICogQHBhcmFtIGxhYmVsIEEgbmFtZSBvZiBhIGxhYmVsIHRvIHdoaWNoIHRvIGp1bXAuXG4gKi9cbkp6dFNjcmlwdENvbnRleHQucHJvdG90eXBlLmp1bXBUb0xhYmVsID0gZnVuY3Rpb24gKGxhYmVsKSB7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50TGFiZWxzLmhhc093blByb3BlcnR5KGxhYmVsKSkge1xuXG4gICAgICAgIHZhciBsYWJlbEluZGV4ID0gdGhpcy5jdXJyZW50TGFiZWxzW2xhYmVsXSxcbiAgICAgICAgICAgIGxhYmVsSW5kaWNpZXMgPSB0aGlzLnNjcmlwdC5sYWJlbEluZGljaWVzW2xhYmVsXTtcblxuICAgICAgICAvLyBJZiBhbGwgbGFiZWxzIGFyZW4ndCB6YXBwZWQuLi5cbiAgICAgICAgaWYgKGxhYmVsSW5kZXggPCBsYWJlbEluZGljaWVzLmxlbmd0aCkge1xuXG4gICAgICAgICAgICAvLyBXZSdyZSBhYm91dCB0byBqdW1wIHN1Y2Nlc3NmdWxseSwgc28gY2xlYXIgb3V0IHRlbXBvcmFyeSBoZWFwIGl0ZW1zXG4gICAgICAgICAgICB0aGlzLmNsZWFyVGVtcG9yYXJ5SGVhcEl0ZW1zKCk7XG5cbiAgICAgICAgICAgIC8vIFNldCBvdXIgY3VycmVudCBsaW5lIHRvIHRoZSBhY3RpdmUgbGFiZWwgaW5kZXhcbiAgICAgICAgICAgIHRoaXMuY29tbWFuZEluZGV4ID0gbGFiZWxJbmRpY2llc1tsYWJlbEluZGV4XTtcblxuICAgICAgICAgICAgLy8gSW5jcmVtZW50IG91ciBqdW1wIGNvdW50IGZvciB0aGlzIHRpY2tcbiAgICAgICAgICAgIHRoaXMuanVtcENvdW50ICs9IDE7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG5KenRTY3JpcHRDb250ZXh0LnByb3RvdHlwZS5jbGVhclRlbXBvcmFyeUhlYXBJdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaGVhcEl0ZW07XG4gICAgZm9yIChoZWFwSXRlbSBpbiB0aGlzLmhlYXApIHtcbiAgICAgICAgaWYgKHRoaXMuaGVhcC5oYXNPd25Qcm9wZXJ0eShoZWFwSXRlbSkgJiYgaGVhcEl0ZW1bMF0gPT09ICc8JyAmJiBoZWFwSXRlbVtoZWFwSXRlbS5sZW5ndGggLSAxXSA9PT0gJz4nKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5oZWFwW2hlYXBJdGVtXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogWmFwcyBhIHByb3ZpZGVkIGxhYmVsIG5hbWUsIG1ha2luZyBpdCBubyBsb25nZXIganVtcGFibGUuIElmIG1vcmUgdGhhbiBvbmVcbiAqIGxhYmVsIHdpdGggdGhlIHNhbWUgbmFtZSBleGlzdHMsIG9ubHkgdGhlIGZpcnN0IHdpbGwgYmUgemFwcGVkLiBTdWJzZXF1ZW50XG4gKiB6YXBzIHdpbGwgemFwIHRoZSBuZXh0IHVuemFwcGVkIGxhYmVsLlxuICpcbiAqIEBwYXJhbSBsYWJlbCBBIG5hbWUgb2YgYSBsYWJlbCB0byB6YXAuXG4gKi9cbkp6dFNjcmlwdENvbnRleHQucHJvdG90eXBlLnphcExhYmVsID0gZnVuY3Rpb24gKGxhYmVsKSB7XG5cbiAgICB2YXIgbGFiZWxJbmRleDtcblxuICAgIGlmICh0aGlzLmN1cnJlbnRMYWJlbHMuaGFzT3duUHJvcGVydHkobGFiZWwpKSB7XG4gICAgICAgIGxhYmVsSW5kZXggPSB0aGlzLmN1cnJlbnRMYWJlbHNbbGFiZWxdO1xuICAgICAgICBpZiAobGFiZWxJbmRleCArIDEgPD0gdGhpcy5zY3JpcHQubGFiZWxJbmRpY2llc1tsYWJlbF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRMYWJlbHNbbGFiZWxdICs9IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbi8qKlxuICogUmVzdG9yZXMgYSBwcmV2aW91c2x5IHphcHBlZCBsYWJlbCwgbWFraW5nIGl0IHJlc3VtYWJsZSBmb3IganVwbWluZy4gSWYgbW9yZSB0aGFuXG4gKiBvbmUgbGFiZWwgd2l0aCB0aGUgc2FtZSBuYW1lIGhhcyBiZWVuIHphcHBlZCwgdGhlIG1vc3QgcmVjZW50bHkgemFwcGVkIGxhYmVsIHdpbGxcbiAqIGJlIHVuemFwcGVkLlxuICpcbiAqIEBwYXJhbSBsYWJlbCBBIG5hbWUgb2YgYSBsYWJlbCB0byByZXN0b3JlLlxuICovXG5KenRTY3JpcHRDb250ZXh0LnByb3RvdHlwZS5yZXN0b3JlTGFiZWwgPSBmdW5jdGlvbiAobGFiZWwpIHtcblxuICAgIHZhciBsYWJlbEluZGV4O1xuXG4gICAgaWYgKHRoaXMuY3VycmVudExhYmVscy5oYXNPd25Qcm9wZXJ0eShsYWJlbCkpIHtcbiAgICAgICAgbGFiZWxJbmRleCA9IHRoaXMuY3VycmVudExhYmVsc1tsYWJlbF07XG4gICAgICAgIGlmIChsYWJlbEluZGV4IC0gMSA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRMYWJlbHNbbGFiZWxdIC09IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbn07XG5cbi8qKlxuICogQWR2YW5jZXMgdGhpcyBKenRTY3JpcHRDb250ZXh0IGJ5IG9uZSBsaW5lLCBwcmVwYXJpbmcgYSBuZXcgY29tbWFuZCB0byBiZSBleGVjdXRlZFxuICogYXQgdGhlIG5leHQgdGljayBldmVudC5cbiAqL1xuSnp0U2NyaXB0Q29udGV4dC5wcm90b3R5cGUuYWR2YW5jZUxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKCkpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kSW5kZXggKz0gMTtcbiAgICB9XG59O1xuXG5leHBvcnRzLkp6dFNjcmlwdENvbnRleHQgPSBKenRTY3JpcHRDb250ZXh0O1xuIiwiLyoqXG4gKiBKWlRTY3JpcHRcbiAqIENvcHlyaWdodCDCqSAyMDE0IE9yYW5nZWxpbmUgSW50ZXJhY3RpdmUsIEluYy5cbiAqIEBhdXRob3IgTWFyayBNY0ludHlyZVxuICovXG5cbi8qanNsaW50IG5vZGU6IHRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTGl0ZXJhbCA9IHJlcXVpcmUoJy4vcGFyc2VyJykuTGl0ZXJhbCxcbiAgICBBbHRlcm5hdGlvbiA9IHJlcXVpcmUoJy4vcGFyc2VyJykuQWx0ZXJuYXRpb24sXG4gICAgRW1wdHkgPSByZXF1aXJlKCcuL3BhcnNlcicpLkVtcHR5LFxuICAgIFNlcXVlbmNlID0gcmVxdWlyZSgnLi9wYXJzZXInKS5TZXF1ZW5jZSxcbiAgICBSZXBldGl0aW9uID0gcmVxdWlyZSgnLi9wYXJzZXInKS5SZXBldGl0aW9uLFxuICAgIFBhcnNlck51bWJlciA9IHJlcXVpcmUoJy4vcGFyc2VyJykuTnVtYmVyLFxuICAgIFdvcmQgPSByZXF1aXJlKCcuL3BhcnNlcicpLldvcmQsXG4gICAgTmV3TGluZSA9IHJlcXVpcmUoJy4vcGFyc2VyJykuTmV3TGluZSxcbiAgICBBc3NlbWJseSA9IHJlcXVpcmUoJy4vcGFyc2VyJykuQXNzZW1ibHksXG4gICAgUGFyc2VyU3RyaW5nID0gcmVxdWlyZSgnLi9wYXJzZXInKS5TdHJpbmcsXG4gICAgTGV4ZXIgPSByZXF1aXJlKCcuL2xleGVyJykuTGV4ZXIsXG4gICAgY29tbWFuZHMgPSByZXF1aXJlKCcuL2p6dC1zY3JpcHQtY29tbWFuZHMnKSxcbiAgICBDb2xvcnMgPSByZXF1aXJlKCcuL2dyYXBoaWNzJykuQ29sb3JzLFxuICAgIENvbnN0cnVjdG9yRXJyb3IgPSByZXF1aXJlKCcuL2Jhc2ljJykuQ29uc3RydWN0b3JFcnJvcixcbiAgICBzZXJpYWxpemVDb2xvciA9IHJlcXVpcmUoJy4vZ3JhcGhpY3MnKS5zZXJpYWxpemU7XG5cbi8qKlxuICogSnp0U2NyaXB0UGFyc2VyXG4gKi9cbmZ1bmN0aW9uIEp6dFNjcmlwdFBhcnNlcih2YWxpZGF0ZU9ubHkpIHtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBKenRTY3JpcHRQYXJzZXIpKSB7XG4gICAgICAgIHRocm93IENvbnN0cnVjdG9yRXJyb3I7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9wQWxsVG9rZW5zVW50aWwoYXNzZW1ibHksIHRva2VuTmFtZSwgdG9rZW5WYWx1ZSwgZGlzY2FyZEZlbmNlKSB7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICAgICAgdG9wID0gYXNzZW1ibHkucGVlaygpO1xuXG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXModG9rZW4sIHRva2VuTmFtZSwgdG9rZW5WYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuICYmIHRva2VuLm5hbWUgPT09IHRva2VuTmFtZS50b1VwcGVyQ2FzZSgpICYmIHRva2VuLnZhbHVlICYmIHRva2VuLnZhbHVlLnRvVXBwZXJDYXNlKCkgPT09IHRva2VuVmFsdWUudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICghbWF0Y2hlcyh0b3AsIHRva2VuTmFtZSwgdG9rZW5WYWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC51bnNoaWZ0KGFzc2VtYmx5LnBvcCgpKTtcbiAgICAgICAgICAgIHRvcCA9IGFzc2VtYmx5LnBlZWsoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaGVzKHRvcCwgdG9rZW5OYW1lLCB0b2tlblZhbHVlKSAmJiBkaXNjYXJkRmVuY2UpIHtcbiAgICAgICAgICAgIGFzc2VtYmx5LnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNob2ljZShwYXJzZXJPbmUsIHBhcnNlclR3bykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFsdGVybmF0aW9uKCk7XG4gICAgICAgIHJlc3VsdC5hZGQocGFyc2VyT25lKTtcbiAgICAgICAgcmVzdWx0LmFkZChwYXJzZXJUd28pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9wdGlvbmFsKHBhcnNlcikge1xuICAgICAgICByZXR1cm4gY2hvaWNlKHBhcnNlciwgbmV3IEVtcHR5KCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gQXNzZW1ibGVyIG9iamVjdCB3aXRoIGEgcHJvdmlkZWQgYXNzZW1ibGUgZnVuY3Rpb25cbiAgICAgKiBkZWZpbml0aW9uIGlmIHZhbGlkYXRlT25seSBpcyBub3Qgc2V0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFzc2VtYmxlcihhc3NlbWJsZXJGdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVPbmx5ID8gdW5kZWZpbmVkIDoge1xuICAgICAgICAgICAgYXNzZW1ibGU6IGFzc2VtYmxlckZ1bmN0aW9uXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlyZWN0aW9uIE1vZGlmaWVyIFBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSAnZGlyZWN0aW9uIG1vZGlmaWVyJyBwYXJzZXIuXG4gICAgICogQHJldHVybiBBICdkaXJlY3Rpb24gbW9kaWZpZXInIHBhcnNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVEaXJlY3Rpb25Nb2RpZmllclBhcnNlcigpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbk1vZGlmaWVyID0gbmV3IEFsdGVybmF0aW9uKCk7XG5cbiAgICAgICAgLy8gQWRkIGRpcmVjdGlvbiBtb2RpZmllciBvcHRpb25zXG4gICAgICAgIGRpcmVjdGlvbk1vZGlmaWVyLmFkZChuZXcgTGl0ZXJhbCgnQ1cnKSk7XG4gICAgICAgIGRpcmVjdGlvbk1vZGlmaWVyLmFkZChuZXcgTGl0ZXJhbCgnQ0NXJykpO1xuICAgICAgICBkaXJlY3Rpb25Nb2RpZmllci5hZGQobmV3IExpdGVyYWwoJ09QUCcpKTtcbiAgICAgICAgZGlyZWN0aW9uTW9kaWZpZXIuYWRkKG5ldyBMaXRlcmFsKCdSTkRQJykpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhc3NlbWJsZXJcbiAgICAgICAgZGlyZWN0aW9uTW9kaWZpZXIuYXNzZW1ibGVyID0gY3JlYXRlQXNzZW1ibGVyKGZ1bmN0aW9uIChhc3NlbWJseSkge1xuICAgICAgICAgICAgYXNzZW1ibHkucHVzaChjb21tYW5kcy5EaXJlY3Rpb25Nb2RpZmllclthc3NlbWJseS5wb3AoKS52YWx1ZS50b1VwcGVyQ2FzZSgpXSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBkaXJlY3Rpb25Nb2RpZmllcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXJlY3Rpb24gVGVybWluYWwgUGFyc2VyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhICdkaXJlY3Rpb24gdGVybWluYWwnIHBhcnNlci5cbiAgICAgKiBAcmV0dXJuIEEgJ2RpcmVjdGlvbiB0ZXJtaW5hbCcgcGFyc2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURpcmVjdGlvblRlcm1pbmFsUGFyc2VyKCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uVGVybWluYWwgPSBuZXcgQWx0ZXJuYXRpb24oKTtcblxuICAgICAgICAvLyBBZGQgZGlyZWN0aW9uIHRlcm1pbmFsIG9wdGlvbnNcbiAgICAgICAgLy8gRnV0dXJlIEltcHJvdmVtZW50OiBDYW4gd2UgZ2V0IHRoaXMgZnJvbSBiYXNpYy5qcz9cbiAgICAgICAgZGlyZWN0aW9uVGVybWluYWwuYWRkKG5ldyBMaXRlcmFsKCdTRUVLJykpO1xuICAgICAgICBkaXJlY3Rpb25UZXJtaW5hbC5hZGQobmV3IExpdGVyYWwoJ1NNQVJUJykpO1xuICAgICAgICBkaXJlY3Rpb25UZXJtaW5hbC5hZGQobmV3IExpdGVyYWwoJ0ZMT1cnKSk7XG4gICAgICAgIGRpcmVjdGlvblRlcm1pbmFsLmFkZChuZXcgTGl0ZXJhbCgnUkFORCcpKTtcbiAgICAgICAgZGlyZWN0aW9uVGVybWluYWwuYWRkKG5ldyBMaXRlcmFsKCdSQU5ERicpKTtcbiAgICAgICAgZGlyZWN0aW9uVGVybWluYWwuYWRkKG5ldyBMaXRlcmFsKCdSQU5EQicpKTtcbiAgICAgICAgZGlyZWN0aW9uVGVybWluYWwuYWRkKG5ldyBMaXRlcmFsKCdSTkRFVycpKTtcbiAgICAgICAgZGlyZWN0aW9uVGVybWluYWwuYWRkKG5ldyBMaXRlcmFsKCdSTkROUycpKTtcbiAgICAgICAgZGlyZWN0aW9uVGVybWluYWwuYWRkKG5ldyBMaXRlcmFsKCdSTkRORScpKTtcbiAgICAgICAgZGlyZWN0aW9uVGVybWluYWwuYWRkKG5ldyBMaXRlcmFsKCdOT1JUSCcpKTtcbiAgICAgICAgZGlyZWN0aW9uVGVybWluYWwuYWRkKG5ldyBMaXRlcmFsKCdFQVNUJykpO1xuICAgICAgICBkaXJlY3Rpb25UZXJtaW5hbC5hZGQobmV3IExpdGVyYWwoJ1NPVVRIJykpO1xuICAgICAgICBkaXJlY3Rpb25UZXJtaW5hbC5hZGQobmV3IExpdGVyYWwoJ1dFU1QnKSk7XG4gICAgICAgIGRpcmVjdGlvblRlcm1pbmFsLmFkZChuZXcgTGl0ZXJhbCgnTicpKTtcbiAgICAgICAgZGlyZWN0aW9uVGVybWluYWwuYWRkKG5ldyBMaXRlcmFsKCdFJykpO1xuICAgICAgICBkaXJlY3Rpb25UZXJtaW5hbC5hZGQobmV3IExpdGVyYWwoJ1MnKSk7XG4gICAgICAgIGRpcmVjdGlvblRlcm1pbmFsLmFkZChuZXcgTGl0ZXJhbCgnVycpKTtcblxuICAgICAgICAvLyBDcmVhdGUgYXNzZW1ibGVyXG4gICAgICAgIGRpcmVjdGlvblRlcm1pbmFsLmFzc2VtYmxlciA9IGNyZWF0ZUFzc2VtYmxlcihmdW5jdGlvbiAoYXNzZW1ibHkpIHtcbiAgICAgICAgICAgIGFzc2VtYmx5LnB1c2goY29tbWFuZHMuRGlyZWN0aW9uW2Fzc2VtYmx5LnBvcCgpLnZhbHVlLnRvVXBwZXJDYXNlKCldKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvblRlcm1pbmFsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpcmVjdGlvbiBQYXJzZXJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgJ2RpcmVjdGlvbicgcGFyc2VyLlxuICAgICAqIEByZXR1cm4gQSAnZGlyZWN0aW9uJyBwYXJzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRGlyZWN0aW9uUGFyc2VyKCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gbmV3IFNlcXVlbmNlKCksXG4gICAgICAgICAgICBtb2RpZmllcnMgPSBuZXcgUmVwZXRpdGlvbihjcmVhdGVEaXJlY3Rpb25Nb2RpZmllclBhcnNlcigpKTtcbiAgICAgICAgZGlyZWN0aW9uLmFkZChtb2RpZmllcnMpO1xuICAgICAgICBkaXJlY3Rpb24uYWRkKGNyZWF0ZURpcmVjdGlvblRlcm1pbmFsUGFyc2VyKCkpO1xuXG4gICAgICAgIC8vIEFkZCBhc3NlbWJsZXJcbiAgICAgICAgZGlyZWN0aW9uLmFzc2VtYmxlciA9IGNyZWF0ZUFzc2VtYmxlcihmdW5jdGlvbiAoYXNzZW1ibHkpIHtcblxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbkV4cHJlc3Npb24gPSBuZXcgY29tbWFuZHMuRGlyZWN0aW9uRXhwcmVzc2lvbihhc3NlbWJseS5wb3AoKSk7XG5cbiAgICAgICAgICAgIHdoaWxlIChhc3NlbWJseS5wZWVrKCkgJiYgYXNzZW1ibHkucGVlaygpLnR5cGUgPT09ICdtb2RpZmllcicpIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25FeHByZXNzaW9uLm1vZGlmaWVycy51bnNoaWZ0KGFzc2VtYmx5LnBvcCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXNzZW1ibHkucHVzaChkaXJlY3Rpb25FeHByZXNzaW9uKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvdW50YWJsZSBEaXJlY3Rpb24gUGFyc2VyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhICdjb3VudGFibGUgZGlyZWN0aW9uJyBwYXJzZXIuXG4gICAgICogQHJldHVybiBBICdjb3VudGFibGUgZGlyZWN0aW9uJyBwYXJzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ291bnRhYmxlRGlyZWN0aW9uUGFyc2VyKCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gbmV3IFNlcXVlbmNlKCk7XG4gICAgICAgIGRpcmVjdGlvbi5hZGQoY3JlYXRlRGlyZWN0aW9uUGFyc2VyKCkpO1xuICAgICAgICBkaXJlY3Rpb24uYWRkKG5ldyBQYXJzZXJOdW1iZXIoKSk7XG4gICAgICAgIGRpcmVjdGlvbi5hc3NlbWJsZXIgPSBjcmVhdGVBc3NlbWJsZXIoZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBhc3NlbWJseS5wb3AoKS52YWx1ZTtcbiAgICAgICAgICAgIGFzc2VtYmx5LnBlZWsoKS5jb3VudCA9IGNvdW50O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb2xvciBQYXJzZXJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgJ2NvbG9yJyBwYXJzZXIuXG4gICAgICogQHJldHVybiBBICdjb2xvcicgcGFyc2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbG9yUGFyc2VyKCkge1xuICAgICAgICB2YXIgY29sb3IgPSBuZXcgQWx0ZXJuYXRpb24oKTtcblxuICAgICAgICAvLyBBZGQgYWx0ZXJuYXRpb24gdmFsdWVzXG4gICAgICAgIGNvbG9yLmFkZChuZXcgTGl0ZXJhbCgnQmxhY2snKSk7XG4gICAgICAgIGNvbG9yLmFkZChuZXcgTGl0ZXJhbCgnQmx1ZScpKTtcbiAgICAgICAgY29sb3IuYWRkKG5ldyBMaXRlcmFsKCdHcmVlbicpKTtcbiAgICAgICAgY29sb3IuYWRkKG5ldyBMaXRlcmFsKCdDeWFuJykpO1xuICAgICAgICBjb2xvci5hZGQobmV3IExpdGVyYWwoJ1JlZCcpKTtcbiAgICAgICAgY29sb3IuYWRkKG5ldyBMaXRlcmFsKCdNYWdlbnRhJykpO1xuICAgICAgICBjb2xvci5hZGQobmV3IExpdGVyYWwoJ0Jyb3duJykpO1xuICAgICAgICBjb2xvci5hZGQobmV3IExpdGVyYWwoJ1doaXRlJykpO1xuICAgICAgICBjb2xvci5hZGQobmV3IExpdGVyYWwoJ0dyZXknKSk7XG4gICAgICAgIGNvbG9yLmFkZChuZXcgTGl0ZXJhbCgnQnJpZ2h0Qmx1ZScpKTtcbiAgICAgICAgY29sb3IuYWRkKG5ldyBMaXRlcmFsKCdCcmlnaHRHcmVlbicpKTtcbiAgICAgICAgY29sb3IuYWRkKG5ldyBMaXRlcmFsKCdCcmlnaHRDeWFuJykpO1xuICAgICAgICBjb2xvci5hZGQobmV3IExpdGVyYWwoJ0JyaWdodFJlZCcpKTtcbiAgICAgICAgY29sb3IuYWRkKG5ldyBMaXRlcmFsKCdCcmlnaHRNYWdlbnRhJykpO1xuICAgICAgICBjb2xvci5hZGQobmV3IExpdGVyYWwoJ1llbGxvdycpKTtcbiAgICAgICAgY29sb3IuYWRkKG5ldyBMaXRlcmFsKCdCcmlnaHRXaGl0ZScpKTtcblxuICAgICAgICAvLyBEZWZpbmUgYXNzZW1ibGVyXG4gICAgICAgIGNvbG9yLmFzc2VtYmxlciA9IHZhbGlkYXRlT25seSA/IHVuZGVmaW5lZCA6IHtcbiAgICAgICAgICAgIGFzc2VtYmxlOiBmdW5jdGlvbiAoYXNzZW1ibHkpIHtcbiAgICAgICAgICAgICAgICBhc3NlbWJseS5wdXNoKENvbG9yc1thc3NlbWJseS5wb3AoKS52YWx1ZS50b1VwcGVyQ2FzZSgpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaW5nIHBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSAndGhpbmcnIHBhcnNlci5cbiAgICAgKiBAcmV0dXJuIEEgJ3RoaW5nJyBwYXJzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVGhpbmdQYXJzZXIoKSB7XG4gICAgICAgIHZhciB0aGluZyA9IG5ldyBBbHRlcm5hdGlvbigpO1xuXG4gICAgICAgIC8vIEFkZCBhbHRlcm5hdGlvbiB2YWx1ZXNcbiAgICAgICAgLy8gRnV0dXJlIEltcHJvdmVtZW50OiBDYW4gd2UgZ2V0IHRoZXNlIGZyb20gdGhpbmdzIGRpcmVjdGx5P1xuICAgICAgICB0aGluZy5hZGQobmV3IExpdGVyYWwoJ0VtcHR5JykpO1xuICAgICAgICB0aGluZy5hZGQobmV3IExpdGVyYWwoJ0FjdGl2ZUJvbWInKSk7XG4gICAgICAgIHRoaW5nLmFkZChuZXcgTGl0ZXJhbCgnQW1tbycpKTtcbiAgICAgICAgdGhpbmcuYWRkKG5ldyBMaXRlcmFsKCdCZWFyJykpO1xuICAgICAgICB0aGluZy5hZGQobmV3IExpdGVyYWwoJ0JsaW5rZXInKSk7XG4gICAgICAgIHRoaW5nLmFkZChuZXcgTGl0ZXJhbCgnQmxpbmtXYWxsJykpO1xuICAgICAgICB0aGluZy5hZGQobmV3IExpdGVyYWwoJ0JvbWInKSk7XG4gICAgICAgIHRoaW5nLmFkZChuZXcgTGl0ZXJhbCgnQm91bGRlcicpKTtcbiAgICAgICAgdGhpbmcuYWRkKG5ldyBMaXRlcmFsKCdCcmVha2FibGVXYWxsJykpO1xuICAgICAgICB0aGluZy5hZGQobmV3IExpdGVyYWwoJ0J1bGxldCcpKTtcbiAgICAgICAgdGhpbmcuYWRkKG5ldyBMaXRlcmFsKCdDZW50aXBlZGUnKSk7XG4gICAgICAgIHRoaW5nLmFkZChuZXcgTGl0ZXJhbCgnQ29udmV5b3InKSk7XG4gICAgICAgIHRoaW5nLmFkZChuZXcgTGl0ZXJhbCgnRG9vcicpKTtcbiAgICAgICAgdGhpbmcuYWRkKG5ldyBMaXRlcmFsKCdEdXBsaWNhdG9yJykpO1xuICAgICAgICB0aGluZy5hZGQobmV3IExpdGVyYWwoJ0V4cGxvc2lvbicpKTtcbiAgICAgICAgdGhpbmcuYWRkKG5ldyBMaXRlcmFsKCdGYWtlV2FsbCcpKTtcbiAgICAgICAgdGhpbmcuYWRkKG5ldyBMaXRlcmFsKCdGb3Jlc3QnKSk7XG4gICAgICAgIHRoaW5nLmFkZChuZXcgTGl0ZXJhbCgnR2VtJykpO1xuICAgICAgICB0aGluZy5hZGQobmV3IExpdGVyYWwoJ0hlYXJ0JykpO1xuICAgICAgICB0aGluZy5hZGQobmV3IExpdGVyYWwoJ0ludmlzaWJsZVdhbGwnKSk7XG4gICAgICAgIHRoaW5nLmFkZChuZXcgTGl0ZXJhbCgnS2V5JykpO1xuICAgICAgICB0aGluZy5hZGQobmV3IExpdGVyYWwoJ0xhdmEnKSk7XG4gICAgICAgIHRoaW5nLmFkZChuZXcgTGl0ZXJhbCgnTGluZVdhbGwnKSk7XG4gICAgICAgIHRoaW5nLmFkZChuZXcgTGl0ZXJhbCgnTGlvbicpKTtcbiAgICAgICAgdGhpbmcuYWRkKG5ldyBMaXRlcmFsKCdQYXNzYWdlJykpO1xuICAgICAgICB0aGluZy5hZGQobmV3IExpdGVyYWwoJ1BsYXllcicpKTtcbiAgICAgICAgdGhpbmcuYWRkKG5ldyBMaXRlcmFsKCdQdXNoZXInKSk7XG4gICAgICAgIHRoaW5nLmFkZChuZXcgTGl0ZXJhbCgnUmljb2NoZXQnKSk7XG4gICAgICAgIHRoaW5nLmFkZChuZXcgTGl0ZXJhbCgnUml2ZXInKSk7XG4gICAgICAgIHRoaW5nLmFkZChuZXcgTGl0ZXJhbCgnUnVmZmlhbicpKTtcbiAgICAgICAgdGhpbmcuYWRkKG5ldyBMaXRlcmFsKCdTaWducG9zdCcpKTtcbiAgICAgICAgdGhpbmcuYWRkKG5ldyBMaXRlcmFsKCdTbGlkZXJFdycpKTtcbiAgICAgICAgdGhpbmcuYWRkKG5ldyBMaXRlcmFsKCdTbGlkZXJOcycpKTtcbiAgICAgICAgdGhpbmcuYWRkKG5ldyBMaXRlcmFsKCdTbmFrZScpKTtcbiAgICAgICAgdGhpbmcuYWRkKG5ldyBMaXRlcmFsKCdTb2xpZFdhbGwnKSk7XG4gICAgICAgIHRoaW5nLmFkZChuZXcgTGl0ZXJhbCgnU3BpZGVyJykpO1xuICAgICAgICB0aGluZy5hZGQobmV3IExpdGVyYWwoJ1NwaWRlcldlYicpKTtcbiAgICAgICAgdGhpbmcuYWRkKG5ldyBMaXRlcmFsKCdTcGlubmluZ0d1bicpKTtcbiAgICAgICAgdGhpbmcuYWRkKG5ldyBMaXRlcmFsKCdUZWxlcG9ydGVyJykpO1xuICAgICAgICB0aGluZy5hZGQobmV3IExpdGVyYWwoJ1RleHQnKSk7XG4gICAgICAgIHRoaW5nLmFkZChuZXcgTGl0ZXJhbCgnVGhyb3dpbmdTdGFyJykpO1xuICAgICAgICB0aGluZy5hZGQobmV3IExpdGVyYWwoJ1RpZ2VyJykpO1xuICAgICAgICB0aGluZy5hZGQobmV3IExpdGVyYWwoJ1RvcmNoJykpO1xuICAgICAgICB0aGluZy5hZGQobmV3IExpdGVyYWwoJ1dhbGwnKSk7XG4gICAgICAgIHRoaW5nLmFkZChuZXcgTGl0ZXJhbCgnV2F0ZXInKSk7XG5cbiAgICAgICAgLy8gRGVmaW5lIGFzc2VtYmxlclxuICAgICAgICB0aGluZy5hc3NlbWJsZXIgPSB2YWxpZGF0ZU9ubHkgPyB1bmRlZmluZWQgOiB7XG4gICAgICAgICAgICBhc3NlbWJsZTogZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICAgICAgYXNzZW1ibHkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGFzc2VtYmx5LnBvcCgpLnZhbHVlLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gdGhpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sb3JmdWwgVGhpbmcgUGFyc2VyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhICdjb2xvcmZ1bCB0aGluZycgcGFyc2VyLlxuICAgICAqIEByZXR1cm4gQSAnY29sb3JmdWwgdGhpbmcnIHBhcnNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb2xvcmZ1bFRoaW5nUGFyc2VyKCkge1xuICAgICAgICB2YXIgY29sb3JmdWxUaGluZyA9IG5ldyBTZXF1ZW5jZSgpO1xuXG4gICAgICAgIC8vIEFkZCBzZXF1ZW5jZSBpdGVtc1xuICAgICAgICBjb2xvcmZ1bFRoaW5nLmFkZChjcmVhdGVDb2xvclBhcnNlcigpKTtcbiAgICAgICAgY29sb3JmdWxUaGluZy5hZGQoY3JlYXRlVGhpbmdQYXJzZXIoKSk7XG5cbiAgICAgICAgLy8gRGVmaW5lIGFzc2VtYmxlclxuICAgICAgICBjb2xvcmZ1bFRoaW5nLmFzc2VtYmxlciA9IHZhbGlkYXRlT25seSA/IHVuZGVmaW5lZCA6IHtcbiAgICAgICAgICAgIGFzc2VtYmxlOiBmdW5jdGlvbiAoYXNzZW1ibHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhpbmcgPSBhc3NlbWJseS5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGluZy5jb2xvciA9IHNlcmlhbGl6ZUNvbG9yKHVuZGVmaW5lZCwgYXNzZW1ibHkucG9wKCkpO1xuICAgICAgICAgICAgICAgIGFzc2VtYmx5LnB1c2godGhpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBjb2xvcmZ1bFRoaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdCBFeHByZXNzaW9uIFBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBOb3QgZXhwcmVzc2lvbiBwYXJzZXIuXG4gICAgICogQHJldHVybiBBIG5vdCBleHByZXNzaW9uIHBhcnNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVOb3RFeHByZXNzaW9uUGFyc2VyKGV4cHJlc3Npb25QYXJzZXIpIHtcbiAgICAgICAgdmFyIG5vdEV4cHJlc3Npb24gPSBuZXcgU2VxdWVuY2UoKTtcblxuICAgICAgICAvLyBBZGQgbm90IGV4cHJlc3Npb24gcGFyc2VyIGVsZW1lbnRzXG4gICAgICAgIG5vdEV4cHJlc3Npb24uYWRkRGlzY2FyZChuZXcgTGl0ZXJhbCgnTm90JykpO1xuICAgICAgICBub3RFeHByZXNzaW9uLmFkZChleHByZXNzaW9uUGFyc2VyKTtcblxuICAgICAgICAvLyBEZWZpbmUgYXNzZW1ibGVyXG4gICAgICAgIG5vdEV4cHJlc3Npb24uYXNzZW1ibGVyID0gY3JlYXRlQXNzZW1ibGVyKGZ1bmN0aW9uIChhc3NlbWJseSkge1xuICAgICAgICAgICAgYXNzZW1ibHkucHVzaChuZXcgY29tbWFuZHMuTm90RXhwcmVzc2lvbihhc3NlbWJseS5wb3AoKSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbm90RXhwcmVzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGphY2VudCBFeHByZXNzaW9uIFBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gYWRqYWNlbnQgZXhwcmVzc2lvbiBwYXJzZXJcbiAgICAgKiBAcmV0dXJuIEFuIGFkamFjZW50IGV4cHJlc3Npb24gcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRqYWNlbnRFeHByZXNzaW9uUGFyc2VyKCkge1xuICAgICAgICB2YXIgYWRqYWNlbnRFeHByZXNzaW9uID0gbmV3IExpdGVyYWwoJ0FkamFjZW50Jyk7XG4gICAgICAgIGFkamFjZW50RXhwcmVzc2lvbi5kaXNjYXJkID0gdHJ1ZTtcbiAgICAgICAgYWRqYWNlbnRFeHByZXNzaW9uLmFzc2VtYmxlciA9IGNyZWF0ZUFzc2VtYmxlcihmdW5jdGlvbiAoYXNzZW1ibHkpIHtcbiAgICAgICAgICAgIGFzc2VtYmx5LnB1c2gobmV3IGNvbW1hbmRzLkFkamFjZW50RXhwcmVzc2lvbigpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhZGphY2VudEV4cHJlc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmxvY2tlZCBFeHByZXNzaW9uIFBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBibG9ja2VkIGV4cHJlc3Npb24gcGFyc2VyXG4gICAgICogQHJldHVybiBBIGJsb2NrZWQgZXhwcmVzc2lvbiBwYXJzZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCbG9ja2VkRXhwcmVzc2lvblBhcnNlcigpIHtcbiAgICAgICAgdmFyIGJsb2NrZWRFeHByZXNzaW9uID0gbmV3IFNlcXVlbmNlKCk7XG4gICAgICAgIGJsb2NrZWRFeHByZXNzaW9uLmFkZERpc2NhcmQobmV3IExpdGVyYWwoJ0Jsb2NrZWQnKSk7XG4gICAgICAgIGJsb2NrZWRFeHByZXNzaW9uLmFkZChjcmVhdGVEaXJlY3Rpb25QYXJzZXIoKSk7XG4gICAgICAgIGJsb2NrZWRFeHByZXNzaW9uLmFzc2VtYmxlciA9IGNyZWF0ZUFzc2VtYmxlcihmdW5jdGlvbiAoYXNzZW1ibHkpIHtcbiAgICAgICAgICAgIGFzc2VtYmx5LnB1c2gobmV3IGNvbW1hbmRzLkJsb2NrZWRFeHByZXNzaW9uKGFzc2VtYmx5LnBvcCgpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYmxvY2tlZEV4cHJlc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpZ25lZCBFeHByZXNzaW9uIFBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gYWxpZ25lZCBleHByZXNzaW9uIHBhcnNlci5cbiAgICAgKiBAcmV0dXJuIEFuIGFsaWduZWQgZXhwcmVzc2lvbiBwYXJzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQWxpZ25lZEV4cHJlc3Npb25QYXJzZXIoKSB7XG4gICAgICAgIHZhciBhbGlnbmVkRXhwcmVzc2lvbiA9IG5ldyBTZXF1ZW5jZSgpO1xuICAgICAgICBhbGlnbmVkRXhwcmVzc2lvbi5hZGREaXNjYXJkKG5ldyBMaXRlcmFsKCdBbGlnbmVkJykpO1xuICAgICAgICBhbGlnbmVkRXhwcmVzc2lvbi5hZGQoY3JlYXRlRGlyZWN0aW9uUGFyc2VyKCkpO1xuICAgICAgICBhbGlnbmVkRXhwcmVzc2lvbi5hc3NlbWJsZXIgPSBjcmVhdGVBc3NlbWJsZXIoZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICBhc3NlbWJseS5wdXNoKG5ldyBjb21tYW5kcy5BbGlnbmVkRXhwcmVzc2lvbihhc3NlbWJseS5wb3AoKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFsaWduZWRFeHByZXNzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlZXAgRXhwcmVzc2lvbiBQYXJzZXJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgcGVlcCBleHByZXNzaW9uIHBhcnNlci5cbiAgICAgKiBAcmV0dXJuIEEgcGVlcCBleHByZXNzaW9uIHBhcnNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBlZXBFeHByZXNzaW9uUGFyc2VyKCkge1xuICAgICAgICB2YXIgcGVlcEV4cHJlc3Npb24gPSBuZXcgU2VxdWVuY2UoKTtcbiAgICAgICAgcGVlcEV4cHJlc3Npb24uYWRkRGlzY2FyZChuZXcgTGl0ZXJhbCgnUGVlcCcpKTtcbiAgICAgICAgcGVlcEV4cHJlc3Npb24uYWRkKG9wdGlvbmFsKG5ldyBQYXJzZXJOdW1iZXIoKSkpO1xuICAgICAgICBwZWVwRXhwcmVzc2lvbi5hc3NlbWJsZXIgPSBjcmVhdGVBc3NlbWJsZXIoZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICB2YXIgY291bnQgPSBhc3NlbWJseS5wZWVrKCkgJiYgYXNzZW1ibHkucGVlaygpLm5hbWUgPT09ICdOVU1CRVInID8gYXNzZW1ibHkucG9wKCkudmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBhc3NlbWJseS5wdXNoKG5ldyBjb21tYW5kcy5QZWVwRXhwcmVzc2lvbihjb3VudCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBlZXBFeHByZXNzaW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4aXN0cyBFeHByZXNzaW9uIFBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gZXhpc3RzIGV4cHJlc3Npb24gcGFyc2VyLlxuICAgICAqIEByZXR1cm4gQW4gZXhpc3RzIGV4cHJlc3Npb24gcGFyc2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4aXN0c0V4cHJlc3Npb25QYXJzZXIoKSB7XG4gICAgICAgIHZhciBleGlzdHNFeHByZXNzaW9uID0gbmV3IFNlcXVlbmNlKCk7XG4gICAgICAgIGV4aXN0c0V4cHJlc3Npb24uYWRkRGlzY2FyZChuZXcgTGl0ZXJhbCgnRXhpc3RzJykpO1xuICAgICAgICBleGlzdHNFeHByZXNzaW9uLmFkZChvcHRpb25hbChuZXcgUGFyc2VyTnVtYmVyKCkpKTtcbiAgICAgICAgZXhpc3RzRXhwcmVzc2lvbi5hZGQoY2hvaWNlKGNyZWF0ZVRoaW5nUGFyc2VyKCksIGNyZWF0ZUNvbG9yZnVsVGhpbmdQYXJzZXIoKSkpO1xuICAgICAgICBleGlzdHNFeHByZXNzaW9uLmFzc2VtYmxlciA9IGNyZWF0ZUFzc2VtYmxlcihmdW5jdGlvbiAoYXNzZW1ibHkpIHtcbiAgICAgICAgICAgIHZhciB0aGluZ1RlbXBsYXRlID0gYXNzZW1ibHkucG9wKCksXG4gICAgICAgICAgICAgICAgY291bnQgPSBhc3NlbWJseS5wZWVrKCkgJiYgYXNzZW1ibHkucGVlaygpLm5hbWUgPT09ICdOVU1CRVInID8gYXNzZW1ibHkucG9wKCkudmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBhc3NlbWJseS5wdXNoKG5ldyBjb21tYW5kcy5FeGlzdHNFeHByZXNzaW9uKHRoaW5nVGVtcGxhdGUsIGNvdW50KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXhpc3RzRXhwcmVzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0aW5nIEV4cHJlc3Npb24gUGFyc2VyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIHRlc3RpbmcgZXhwcmVzc2lvbiBwYXJzZXIuXG4gICAgICogQHJldHVybiBBIHRlc3RpbmcgZXhwcmVzc2lvbiBwYXJzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVGVzdGluZ0V4cHJlc3Npb25QYXJzZXIoKSB7XG4gICAgICAgIHZhciB0ZXN0aW5nRXhwcmVzc2lvbiA9IG5ldyBTZXF1ZW5jZSgpLFxuICAgICAgICAgICAgb3BlcmF0b3IgPSBuZXcgQWx0ZXJuYXRpb24oKTtcbiAgICAgICAgb3BlcmF0b3IuYWRkKG5ldyBMaXRlcmFsKCc8JykpO1xuICAgICAgICBvcGVyYXRvci5hZGQobmV3IExpdGVyYWwoJzw9JykpO1xuICAgICAgICBvcGVyYXRvci5hZGQobmV3IExpdGVyYWwoJz4nKSk7XG4gICAgICAgIG9wZXJhdG9yLmFkZChuZXcgTGl0ZXJhbCgnPj0nKSk7XG4gICAgICAgIG9wZXJhdG9yLmFkZChuZXcgTGl0ZXJhbCgnPScpKTtcbiAgICAgICAgdGVzdGluZ0V4cHJlc3Npb24uYWRkKG5ldyBXb3JkKCkpO1xuICAgICAgICB0ZXN0aW5nRXhwcmVzc2lvbi5hZGQob3BlcmF0b3IpO1xuICAgICAgICB0ZXN0aW5nRXhwcmVzc2lvbi5hZGQobmV3IFBhcnNlck51bWJlcigpKTtcbiAgICAgICAgdGVzdGluZ0V4cHJlc3Npb24uYXNzZW1ibGVyID0gY3JlYXRlQXNzZW1ibGVyKGZ1bmN0aW9uIChhc3NlbWJseSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXNzZW1ibHkucG9wKCkudmFsdWUsXG4gICAgICAgICAgICAgICAgb3BlcmFuZCA9IGFzc2VtYmx5LnBvcCgpLnZhbHVlLFxuICAgICAgICAgICAgICAgIGNvdW50ZXIgPSBhc3NlbWJseS5wb3AoKS52YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgYXNzZW1ibHkucHVzaChuZXcgY29tbWFuZHMuVGVzdGluZ0V4cHJlc3Npb24oY291bnRlciwgb3BlcmFuZCwgdmFsdWUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ZXN0aW5nRXhwcmVzc2lvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHByZXNzaW9uIFBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYW4gZXhwcmVzc2lvbiBwYXJzZXIuXG4gICAgICogQHJldHVybiBBbiBleHByZXNzaW9uIHBhcnNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVFeHByZXNzaW9uUGFyc2VyKCkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IG5ldyBBbHRlcm5hdGlvbigpO1xuICAgICAgICBleHByZXNzaW9uLmFkZChjcmVhdGVOb3RFeHByZXNzaW9uUGFyc2VyKGV4cHJlc3Npb24pKTtcbiAgICAgICAgZXhwcmVzc2lvbi5hZGQoY3JlYXRlQWRqYWNlbnRFeHByZXNzaW9uUGFyc2VyKCkpO1xuICAgICAgICBleHByZXNzaW9uLmFkZChjcmVhdGVCbG9ja2VkRXhwcmVzc2lvblBhcnNlcigpKTtcbiAgICAgICAgZXhwcmVzc2lvbi5hZGQoY3JlYXRlQWxpZ25lZEV4cHJlc3Npb25QYXJzZXIoKSk7XG4gICAgICAgIGV4cHJlc3Npb24uYWRkKGNyZWF0ZVBlZXBFeHByZXNzaW9uUGFyc2VyKCkpO1xuICAgICAgICBleHByZXNzaW9uLmFkZChjcmVhdGVFeGlzdHNFeHByZXNzaW9uUGFyc2VyKCkpO1xuICAgICAgICBleHByZXNzaW9uLmFkZChjcmVhdGVUZXN0aW5nRXhwcmVzc2lvblBhcnNlcigpKTtcbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGFiZWwgUGFyc2VyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBsYWJlbCBwYXJzZXJcbiAgICAgKiBAcmV0dXJuIEEgbGFiZWwgcGFyc2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUxhYmVsUGFyc2VyKCkge1xuICAgICAgICB2YXIgbGFiZWwgPSBuZXcgU2VxdWVuY2UoKTtcblxuICAgICAgICAvLyBBZGQgc2VxdWVuY2UgaXRlbXNcbiAgICAgICAgbGFiZWwuYWRkRGlzY2FyZChuZXcgTGl0ZXJhbCgnOicpKTtcbiAgICAgICAgbGFiZWwuYWRkKG5ldyBXb3JkKCkpO1xuICAgICAgICBsYWJlbC5hZGREaXNjYXJkKG5ldyBOZXdMaW5lKCkpO1xuXG4gICAgICAgIC8vIERlZmluZSBhc3NlbWJsZXJcbiAgICAgICAgbGFiZWwuYXNzZW1ibGVyID0gY3JlYXRlQXNzZW1ibGVyKGZ1bmN0aW9uIChhc3NlbWJseSkge1xuICAgICAgICAgICAgYXNzZW1ibHkucHVzaChuZXcgY29tbWFuZHMuTGFiZWwoYXNzZW1ibHkucG9wKCkudmFsdWUudG9VcHBlckNhc2UoKSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbGFiZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmVjb21lIFN0YXRlbWVudCBQYXJzZXJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3ICdiZWNvbWUnIHN0YXRlbWVudCBwYXJzZXJcbiAgICAgKiBAcmV0dXJuIEEgJ2JlY29tZScgc3RhdGVtZW50IHBhcnNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCZWNvbWVTdGF0ZW1lbnRQYXJzZXIoKSB7XG4gICAgICAgIHZhciBiZWNvbWUgPSBuZXcgU2VxdWVuY2UoKTtcblxuICAgICAgICAvLyBBZGQgc2VxdWVuY2UgdG9rZW5zXG4gICAgICAgIGJlY29tZS5hZGREaXNjYXJkKG5ldyBMaXRlcmFsKCdCZWNvbWUnKSk7XG4gICAgICAgIGJlY29tZS5hZGQoY2hvaWNlKGNyZWF0ZUNvbG9yZnVsVGhpbmdQYXJzZXIoKSwgY3JlYXRlVGhpbmdQYXJzZXIoKSkpO1xuXG4gICAgICAgIC8vIERlZmluZSBhc3NlbWJsZXJcbiAgICAgICAgYmVjb21lLmFzc2VtYmxlciA9IGNyZWF0ZUFzc2VtYmxlcihmdW5jdGlvbiAoYXNzZW1ibHkpIHtcbiAgICAgICAgICAgIGFzc2VtYmx5LnB1c2gobmV3IGNvbW1hbmRzLkJlY29tZUNvbW1hbmQoYXNzZW1ibHkucG9wKCkpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGJlY29tZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgU3RhdGVtZW50IFBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgJ2NoYW5nZScgc3RhdGVtZW50IHBhcnNlclxuICAgICAqIEByZXR1cm4gQSAnY2hhbmdlJyBzdGF0ZW1lbnQgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ2hhbmdlU3RhdGVtZW50UGFyc2VyKCkge1xuICAgICAgICB2YXIgY2hhbmdlID0gbmV3IFNlcXVlbmNlKCk7XG5cbiAgICAgICAgLy8gQWRkIHNlcXVlbmNlIHRva2Vuc1xuICAgICAgICBjaGFuZ2UuYWRkRGlzY2FyZChuZXcgTGl0ZXJhbCgnQ2hhbmdlJykpO1xuICAgICAgICBjaGFuZ2UuYWRkKGNob2ljZShjcmVhdGVDb2xvcmZ1bFRoaW5nUGFyc2VyKCksIGNyZWF0ZVRoaW5nUGFyc2VyKCkpKTtcbiAgICAgICAgY2hhbmdlLmFkZChjaG9pY2UoY3JlYXRlQ29sb3JmdWxUaGluZ1BhcnNlcigpLCBjcmVhdGVUaGluZ1BhcnNlcigpKSk7XG5cbiAgICAgICAgLy8gRGVmaW5lIGFzc2VtYmxlclxuICAgICAgICBjaGFuZ2UuYXNzZW1ibGVyID0gY3JlYXRlQXNzZW1ibGVyKGZ1bmN0aW9uIChhc3NlbWJseSkge1xuICAgICAgICAgICAgdmFyIHRvVGVtcGxhdGUgPSBhc3NlbWJseS5wb3AoKTtcbiAgICAgICAgICAgIGFzc2VtYmx5LnB1c2gobmV3IGNvbW1hbmRzLkNoYW5nZUNvbW1hbmQoYXNzZW1ibHkucG9wKCksIHRvVGVtcGxhdGUpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFyIFN0YXRlbWVudCBQYXJzZXJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3ICdjaGFyJyBzdGF0ZW1lbnQgcGFyc2VyLlxuICAgICAqIEByZXR1cm4gQSAnY2hhcicgc3RhdGVtZW50IHBhcnNlclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNoYXJTdGF0ZW1lbnRQYXJzZXIoKSB7XG4gICAgICAgIHZhciBjaGFyID0gbmV3IFNlcXVlbmNlKCk7XG5cbiAgICAgICAgLy8gQWRkIHNlcXVlbmNlIHRva2Vuc1xuICAgICAgICBjaGFyLmFkZERpc2NhcmQobmV3IExpdGVyYWwoJ0NoYXInKSk7XG4gICAgICAgIGNoYXIuYWRkKG5ldyBQYXJzZXJOdW1iZXIoKSk7XG5cbiAgICAgICAgLy8gRGVmaW5lIGFzc2VtYmxlclxuICAgICAgICBjaGFyLmFzc2VtYmxlciA9IGNyZWF0ZUFzc2VtYmxlcihmdW5jdGlvbiAoYXNzZW1ibHkpIHtcbiAgICAgICAgICAgIGFzc2VtYmx5LnB1c2gobmV3IGNvbW1hbmRzLkNoYXJDb21tYW5kKGFzc2VtYmx5LnBvcCgpLnZhbHVlKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBjaGFyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpZSBTdGF0ZW1lbnQgUGFyc2VyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyAnZGllJyBzdGF0ZW1lbnQgcGFyc2VyLlxuICAgICAqIEByZXR1cm4gQSAnZGllJyBzdGF0ZW1lbnQgcGFyc2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZURpZVN0YXRlbWVudFBhcnNlcigpIHtcbiAgICAgICAgdmFyIGRpZSA9IG5ldyBTZXF1ZW5jZSgpO1xuXG4gICAgICAgIC8vIEFkZCBzZXF1ZW5jZSB0b2tlbnNcbiAgICAgICAgZGllLmFkZERpc2NhcmQobmV3IExpdGVyYWwoJ0RpZScpKTtcbiAgICAgICAgZGllLmFkZChvcHRpb25hbChuZXcgTGl0ZXJhbCgnTWFnbmV0aWNhbGx5JykpKTtcblxuICAgICAgICAvLyBEZWZpbmUgYXNzZW1ibGVyXG4gICAgICAgIGRpZS5hc3NlbWJsZXIgPSBjcmVhdGVBc3NlbWJsZXIoZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICB2YXIgbmV4dFRva2VuID0gYXNzZW1ibHkucGVlaygpO1xuICAgICAgICAgICAgaWYgKG5leHRUb2tlbiAmJiBuZXh0VG9rZW4ubmFtZSA9PT0gJ1dPUkQnICYmIG5leHRUb2tlbi52YWx1ZS50b1VwcGVyQ2FzZSgpID09PSAnTUFHTkVUSUNBTExZJykge1xuICAgICAgICAgICAgICAgIGFzc2VtYmx5LnBvcCgpO1xuICAgICAgICAgICAgICAgIGFzc2VtYmx5LnB1c2gobmV3IGNvbW1hbmRzLkRpZUNvbW1hbmQodHJ1ZSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NlbWJseS5wdXNoKG5ldyBjb21tYW5kcy5EaWVDb21tYW5kKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gZGllO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuZCBTdGF0ZW1lbnQgUGFyc2VyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyAnZW5kJyBzdGF0ZW1lbnQgcGFyc2VyLlxuICAgICAqIEByZXR1cm4gQSAnZW5kJyBzdGF0ZW1lbnQgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRW5kU3RhdGVtZW50UGFyc2VyKCkge1xuICAgICAgICB2YXIgZW5kU3RhdGVtZW50ID0gbmV3IExpdGVyYWwoJ0VuZCcpO1xuXG4gICAgICAgIC8vIEFkZCBzZXF1ZW5jZSB0b2tlbnNcbiAgICAgICAgZW5kU3RhdGVtZW50LmRpc2NhcmQgPSB0cnVlO1xuXG4gICAgICAgIC8vIERlZmluZSBhc3NlbWJsZXJcbiAgICAgICAgZW5kU3RhdGVtZW50LmFzc2VtYmxlciA9IGNyZWF0ZUFzc2VtYmxlcihmdW5jdGlvbiAoYXNzZW1ibHkpIHtcbiAgICAgICAgICAgIGFzc2VtYmx5LnB1c2gobmV3IGNvbW1hbmRzLkVuZENvbW1hbmQoKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBlbmRTdGF0ZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR28gU3RhdGVtZW50IFBhcnNlclxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyAnZ28nIHN0YXRlbWVudCBwYXJzZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFthbGlhc10gLSBBbiBvcHRpb25hbCBhbGlhcyB0byB1c2UgZm9yIHRoZSBwYXJzZXIgaW5zdGVhZCBvZiBHT1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlZnVsXSAtIFdoZXRoZXIgb3Igbm90IHRoaXMgcGFyc2VyIHNob3VsZCByZXN1bHQgaW4gYSBmb3JjZWZ1bCBtb3ZlIGNvbW1hbmRcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtIEEgJ2dvJyBzdGF0ZW1lbnQgcGFyc2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUdvU3RhdGVtZW50UGFyc2VyKGFsaWFzLCBmb3JjZWZ1bCkge1xuXG4gICAgICAgIHZhciBnbyA9IG5ldyBTZXF1ZW5jZSgpLFxuICAgICAgICAgICAgc3Vic2VxdWVudERpcmVjdGlvbnMgPSBuZXcgU2VxdWVuY2UoKSxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IGNob2ljZShjcmVhdGVEaXJlY3Rpb25QYXJzZXIoKSwgY3JlYXRlQ291bnRhYmxlRGlyZWN0aW9uUGFyc2VyKCkpO1xuXG4gICAgICAgIC8vIEZvcmNlZnVsIGRlZmF1bHRzIHRvIHRydWVcbiAgICAgICAgZm9yY2VmdWwgPSBmb3JjZWZ1bCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZvcmNlZnVsO1xuXG4gICAgICAgIHN1YnNlcXVlbnREaXJlY3Rpb25zLmFkZERpc2NhcmQobmV3IExpdGVyYWwoJywnKSk7XG4gICAgICAgIHN1YnNlcXVlbnREaXJlY3Rpb25zLmFkZChkaXJlY3Rpb24pO1xuXG4gICAgICAgIC8vIEFkZCBzZXF1ZW5jZSB0b2tlbnNcbiAgICAgICAgZ28uYWRkKG5ldyBMaXRlcmFsKGFsaWFzIHx8ICdHbycpKTtcbiAgICAgICAgZ28uYWRkKGRpcmVjdGlvbik7XG4gICAgICAgIGdvLmFkZChuZXcgUmVwZXRpdGlvbihzdWJzZXF1ZW50RGlyZWN0aW9ucykpO1xuXG4gICAgICAgIC8vIERlZmluZSBhc3NlbWJsZXJcbiAgICAgICAgZ28uYXNzZW1ibGVyID0gY3JlYXRlQXNzZW1ibGVyKGZ1bmN0aW9uIChhc3NlbWJseSkge1xuXG4gICAgICAgICAgICB2YXIgaW5kZXgsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBleHByZXNzaW9ucyA9IHBvcEFsbFRva2Vuc1VudGlsKGFzc2VtYmx5LCAnV09SRCcsIGFsaWFzIHx8ICdHTycsIHRydWUpO1xuXG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBleHByZXNzaW9ucy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uID0gZXhwcmVzc2lvbnNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGFzc2VtYmx5LnB1c2gobmV3IGNvbW1hbmRzLk1vdmVDb21tYW5kKGV4cHJlc3Npb24sIGZvcmNlZnVsKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGdvO1xuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZSBTdGF0ZW1lbnQgUGFyc2VyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyAnZ2l2ZScgc3RhdGVtZW50IHBhcnNlci5cbiAgICAgKiBAcmV0dXJuIEEgJ2dpdmUnIHN0YXRlbWVudCBwYXJzZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVHaXZlU3RhdGVtZW50UGFyc2VyKCkge1xuICAgICAgICB2YXIgZ2l2ZSA9IG5ldyBTZXF1ZW5jZSgpO1xuXG4gICAgICAgIC8vIEFkZCBzZXF1ZW5jZSB0b2tlbnNcbiAgICAgICAgZ2l2ZS5hZGREaXNjYXJkKG5ldyBMaXRlcmFsKCdHaXZlJykpO1xuICAgICAgICBnaXZlLmFkZChuZXcgUGFyc2VyTnVtYmVyKCkpO1xuICAgICAgICBnaXZlLmFkZChuZXcgV29yZCgpKTtcblxuICAgICAgICAvLyBEZWZpbmUgYXNzZW1ibGVyXG4gICAgICAgIGdpdmUuYXNzZW1ibGVyID0gY3JlYXRlQXNzZW1ibGVyKGZ1bmN0aW9uIChhc3NlbWJseSkge1xuICAgICAgICAgICAgYXNzZW1ibHkucHVzaChuZXcgY29tbWFuZHMuR2l2ZUNvbW1hbmQoYXNzZW1ibHkucG9wKCkudmFsdWUsIGFzc2VtYmx5LnBvcCgpLnZhbHVlKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBnaXZlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElmIFN0YXRlbWVudCBQYXJzZXJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3ICdpZicgc3RhdGVtZW50IHBhcnNlclxuICAgICAqIEByZXR1cm4gQW4gJ2lmJyBzdGF0ZW1lbnQgcGFyc2VyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSWZTdGF0ZW1lbnRQYXJzZXIoKSB7XG4gICAgICAgIHZhciBpZlN0YXRlbWVudCA9IG5ldyBTZXF1ZW5jZSgpO1xuXG4gICAgICAgIC8vIEFkZCBzZXF1ZW5jZSB0b2tlbnNcbiAgICAgICAgaWZTdGF0ZW1lbnQuYWRkRGlzY2FyZChuZXcgTGl0ZXJhbCgnSWYnKSk7XG4gICAgICAgIGlmU3RhdGVtZW50LmFkZChjcmVhdGVFeHByZXNzaW9uUGFyc2VyKCkpO1xuICAgICAgICBpZlN0YXRlbWVudC5hZGQobmV3IFdvcmQoKSk7XG5cbiAgICAgICAgLy8gRGVmaW5lIGFzc2VtYmxlclxuICAgICAgICBpZlN0YXRlbWVudC5hc3NlbWJsZXIgPSBjcmVhdGVBc3NlbWJsZXIoZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICBhc3NlbWJseS5wdXNoKG5ldyBjb21tYW5kcy5JZkNvbW1hbmQoYXNzZW1ibHkucG9wKCkudmFsdWUudG9VcHBlckNhc2UoKSwgYXNzZW1ibHkucG9wKCkpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGlmU3RhdGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvY2sgU3RhdGVtZW50IFBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgJ2xvY2snIHN0YXRtZW50IHBhcnNlci5cbiAgICAgKiBAcmV0dXJuIEEgJ2xvY2snIHN0YXRlbWVudCBwYXJzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9ja1N0YXRlbWVudFBhcnNlcigpIHtcblxuICAgICAgICAvLyBDcmVhdGUgbG9jayBwYXJzZXJcbiAgICAgICAgdmFyIGxvY2sgPSBuZXcgTGl0ZXJhbCgnTG9jaycpO1xuICAgICAgICBsb2NrLmRpc2NhcmQgPSB0cnVlO1xuXG4gICAgICAgIC8vIERlZmluZSBhc3NlbWJsZXJcbiAgICAgICAgbG9jay5hc3NlbWJsZXIgPSBjcmVhdGVBc3NlbWJsZXIoZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICBhc3NlbWJseS5wdXNoKG5ldyBjb21tYW5kcy5Mb2NrQ29tbWFuZCgpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGxheSBTdGF0ZW1lbnQgUGFyc2VyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyAncGxheScgc3RhdGVtZW50IHBhc2VyLlxuICAgICAqIEByZXR1cm4gQSAncGxheScgc3RhdGVtZW50IHBhcnNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQbGF5U3RhdGVtZW50UGFyc2VyKCkge1xuICAgICAgICB2YXIgcGxheSA9IG5ldyBTZXF1ZW5jZSgpO1xuXG4gICAgICAgIC8vIEFkZCBwbGF5IGl0ZW1zXG4gICAgICAgIHBsYXkuYWRkRGlzY2FyZChuZXcgTGl0ZXJhbCgnUGxheScpKTtcbiAgICAgICAgcGxheS5hZGQobmV3IFBhcnNlclN0cmluZygpKTtcblxuICAgICAgICAvLyBEZWZpbmUgYXNzZW1ibGVyXG4gICAgICAgIHBsYXkuYXNzZW1ibGVyID0gY3JlYXRlQXNzZW1ibGVyKGZ1bmN0aW9uIChhc3NlbWJseSkge1xuICAgICAgICAgICAgYXNzZW1ibHkucHVzaChuZXcgY29tbWFuZHMuUGxheUNvbW1hbmQoYXNzZW1ibHkucG9wKCkudmFsdWUpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBsYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHV0IFN0YXRlbWVudCBQYXJzZXJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgbmV3ICdwdXQnIHN0YXRlbWVudCBwYXJzZXIuXG4gICAgICogQHJldHVybiBBICdwdXQnIHN0YXRlbWVudCBwYXNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQdXRTdGF0ZW1lbnRQYXJzZXIoKSB7XG4gICAgICAgIHZhciBwdXQgPSBuZXcgU2VxdWVuY2UoKTtcblxuICAgICAgICAvLyBBZGQgcHV0IGl0ZW1zXG4gICAgICAgIHB1dC5hZGREaXNjYXJkKG5ldyBMaXRlcmFsKCdQdXQnKSk7XG4gICAgICAgIHB1dC5hZGQoY3JlYXRlRGlyZWN0aW9uUGFyc2VyKCkpO1xuICAgICAgICBwdXQuYWRkKGNob2ljZShjcmVhdGVUaGluZ1BhcnNlcigpLCBjcmVhdGVDb2xvcmZ1bFRoaW5nUGFyc2VyKCkpKTtcblxuICAgICAgICAvLyBEZWZpbmUgYXNzZW1ibGVyXG4gICAgICAgIHB1dC5hc3NlbWJsZXIgPSBjcmVhdGVBc3NlbWJsZXIoZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICBhc3NlbWJseS5wdXNoKG5ldyBjb21tYW5kcy5QdXRDb21tYW5kKGFzc2VtYmx5LnBvcCgpLCBhc3NlbWJseS5wb3AoKSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbCBTdGF0ZW1lbnQgUGFyc2VyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhICdzY3JvbGwnIHN0YXRlbWVudCBwYXNlci5cbiAgICAgKiBAcmV0dXJuIEEgJ3Njcm9sbCcgc3RhdG1lbnQgcGFzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlU2Nyb2xsU3RhdGVtZW50UGFyc2VyKCkge1xuICAgICAgICB2YXIgc2Nyb2xsID0gbmV3IFNlcXVlbmNlKCk7XG5cbiAgICAgICAgLy8gQWRkIHNjcm9sbCBzZXF1ZW5jZSBpdGVtc1xuICAgICAgICBzY3JvbGwuYWRkRGlzY2FyZChuZXcgTGl0ZXJhbCgnU2Nyb2xsJykpO1xuICAgICAgICBzY3JvbGwuYWRkKG9wdGlvbmFsKG5ldyBMaXRlcmFsKCdCb2xkJykpKTtcbiAgICAgICAgc2Nyb2xsLmFkZChuZXcgUGFyc2VyU3RyaW5nKCkpO1xuICAgICAgICBzY3JvbGwuYWRkKG9wdGlvbmFsKG5ldyBXb3JkKCkpKTtcblxuICAgICAgICAvLyBEZWZpbmUgYXNzZW1ibGVyXG4gICAgICAgIHNjcm9sbC5hc3NlbWJsZXIgPSBjcmVhdGVBc3NlbWJsZXIoZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICB2YXIganVtcExhYmVsID0gYXNzZW1ibHkucGVlaygpLm5hbWUgPT09ICdXT1JEJyA/IGFzc2VtYmx5LnBvcCgpLnZhbHVlLnRvVXBwZXJDYXNlKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdGV4dCA9IGFzc2VtYmx5LnBvcCgpLnZhbHVlLFxuICAgICAgICAgICAgICAgIGJvbGRPcHRpb24gPSBhc3NlbWJseS5wZWVrKCkgJiYgYXNzZW1ibHkucGVlaygpLm5hbWUgPT09ICdXT1JEJyAmJiBhc3NlbWJseS5wZWVrKCkudmFsdWUudG9VcHBlckNhc2UoKSA9PT0gJ0JPTEQnID8gYXNzZW1ibHkucG9wKCkgOiBmYWxzZTtcbiAgICAgICAgICAgIGFzc2VtYmx5LnB1c2gobmV3IGNvbW1hbmRzLlNjcm9sbENvbW1hbmQodGV4dCwgISFib2xkT3B0aW9uLCBqdW1wTGFiZWwpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNjcm9sbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZW5kIFN0YXRlbWVudCBQYXJzZXJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgJ3NlbmQnIHN0YXRlbWVudCBwYXJzZXJcbiAgICAgKiBAcmV0dXJuIEEgJ3NlbmQnIHN0YXRlbWVudCBwYXNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVTZW5kU3RhdGVtZW50UGFyc2VyKCkge1xuICAgICAgICB2YXIgc2VuZCA9IG5ldyBTZXF1ZW5jZSgpO1xuXG4gICAgICAgIC8vIEFkZCBzZW5kIHNlcXVlbmNlIGl0ZW1zXG4gICAgICAgIHNlbmQuYWRkKG5ldyBMaXRlcmFsKCdTZW5kJykpO1xuICAgICAgICBzZW5kLmFkZChvcHRpb25hbChuZXcgV29yZCgpKSk7XG4gICAgICAgIHNlbmQuYWRkKG5ldyBXb3JkKCkpO1xuXG4gICAgICAgIC8vIERlZmluZSBhc3NlbWJsZXJcbiAgICAgICAgc2VuZC5hc3NlbWJsZXIgPSBjcmVhdGVBc3NlbWJsZXIoZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHBvcEFsbFRva2Vuc1VudGlsKGFzc2VtYmx5LCAnV09SRCcsICdTRU5EJywgdHJ1ZSksXG4gICAgICAgICAgICAgICAgbGFiZWwgPSBwYXJhbWV0ZXJzLnBvcCgpLnZhbHVlLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgcmVjaXBpZW50ID0gcGFyYW1ldGVycy5sZW5ndGggPiAwID8gcGFyYW1ldGVycy5wb3AoKS52YWx1ZS50b1VwcGVyQ2FzZSgpIDogJ1NFTEYnO1xuICAgICAgICAgICAgYXNzZW1ibHkucHVzaChuZXcgY29tbWFuZHMuU2VuZENvbW1hbmQocmVjaXBpZW50LCBsYWJlbCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgU3RhdGVtZW50IFBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSAnc2V0JyBzdGF0ZW1lbnQgcGFzZXJcbiAgICAgKiBAcmV0dXJuIEEgJ3NldCcgc3RhdGVtZW50IHBhcnNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVTZXRTdGF0ZW1lbnRQYXJzZXIoKSB7XG4gICAgICAgIHZhciBzZXQgPSBuZXcgU2VxdWVuY2UoKTtcblxuICAgICAgICAvLyBBZGQgc2V0IHNlcXVlbmNlIGl0ZW1zXG4gICAgICAgIHNldC5hZGREaXNjYXJkKG5ldyBMaXRlcmFsKCdTZXQnKSk7XG4gICAgICAgIHNldC5hZGQob3B0aW9uYWwobmV3IFBhcnNlck51bWJlcigpKSk7XG4gICAgICAgIHNldC5hZGQobmV3IFdvcmQoKSk7XG5cbiAgICAgICAgLy8gRGVmaW5lIGFzc2VtYmxlclxuICAgICAgICBzZXQuYXNzZW1ibGVyID0gY3JlYXRlQXNzZW1ibGVyKGZ1bmN0aW9uIChhc3NlbWJseSkge1xuICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSBhc3NlbWJseS5wb3AoKS52YWx1ZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gYXNzZW1ibHkucGVlaygpICYmIGFzc2VtYmx5LnBlZWsoKS5uYW1lID09PSAnTlVNQkVSJyA/IGFzc2VtYmx5LnBvcCgpLnZhbHVlIDogMTtcbiAgICAgICAgICAgIGFzc2VtYmx5LnB1c2gobmV3IGNvbW1hbmRzLlNldENvbW1hbmQoY291bnRlciwgdmFsdWUpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlIFN0YXRlbWVudCBQYXJzZXJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgJ3Rha2UnIHN0YXRlbWVudCBwYXJzZXIuXG4gICAgICogQHJldHVybiBBICd0YWtlJyBzdGF0ZW1lbnQgcGFyc2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVRha2VTdGF0ZW1lbnRQYXJzZXIoKSB7XG4gICAgICAgIHZhciB0YWtlID0gbmV3IFNlcXVlbmNlKCk7XG5cbiAgICAgICAgLy8gQWRkIHRha2Ugc2VxdWVuY2UgaXRlbXNcbiAgICAgICAgdGFrZS5hZGREaXNjYXJkKG5ldyBMaXRlcmFsKCdUYWtlJykpO1xuICAgICAgICB0YWtlLmFkZChuZXcgUGFyc2VyTnVtYmVyKCkpO1xuICAgICAgICB0YWtlLmFkZChuZXcgV29yZCgpKTtcbiAgICAgICAgdGFrZS5hZGQob3B0aW9uYWwobmV3IFdvcmQoKSkpO1xuXG4gICAgICAgIC8vIERlZmluZSBhc3NlbWJsZXJcbiAgICAgICAgdGFrZS5hc3NlbWJsZXIgPSBjcmVhdGVBc3NlbWJsZXIoZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICB2YXIgdG9rZW4xID0gYXNzZW1ibHkucG9wKCkudmFsdWUudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICB0b2tlbjIgPSBhc3NlbWJseS5wZWVrKCkubmFtZSA9PT0gJ1dPUkQnID8gYXNzZW1ibHkucG9wKCkudmFsdWUudG9VcHBlckNhc2UoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBjb3VudCA9ICsoYXNzZW1ibHkucG9wKCkudmFsdWUpO1xuICAgICAgICAgICAgYXNzZW1ibHkucHVzaChuZXcgY29tbWFuZHMuVGFrZUNvbW1hbmQodG9rZW4yIHx8IHRva2VuMSwgY291bnQsIHRva2VuMiA/IHRva2VuMSA6IHVuZGVmaW5lZCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdGFrZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaHJvd1N0YXIgU3RhdGVtZW50IFBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSAndGhyb3dzdGFyJyBzdGF0ZW1lbnQgcGFyc2VyLlxuICAgICAqIEByZXR1cm4gQSAndGhyb3dzdGFyJyBzdGF0bWVudCBwYXJzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlVGhyb3dTdGFyU3RhdGVtZW50UGFyc2VyKCkge1xuICAgICAgICB2YXIgdGhyb3dTdGFyID0gbmV3IFNlcXVlbmNlKCk7XG5cbiAgICAgICAgLy8gQWRkIHRocm93c3RhciBzZXF1ZW5jZSBpdGVtc1xuICAgICAgICB0aHJvd1N0YXIuYWRkRGlzY2FyZChuZXcgTGl0ZXJhbCgnVGhyb3dTdGFyJykpO1xuICAgICAgICB0aHJvd1N0YXIuYWRkKGNyZWF0ZURpcmVjdGlvblBhcnNlcigpKTtcblxuICAgICAgICAvLyBEZWZpbmUgYXNzZW1ibGVyXG4gICAgICAgIHRocm93U3Rhci5hc3NlbWJsZXIgPSBjcmVhdGVBc3NlbWJsZXIoZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICBhc3NlbWJseS5wdXNoKG5ldyBjb21tYW5kcy5UaHJvd1N0YXJDb21tYW5kKGFzc2VtYmx5LnBvcCgpKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0aHJvd1N0YXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9yY2ggU3RhdGVtZW50IFBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSAndG9yY2gnIHN0YXRlbWVudCBwYXJzZXIuXG4gICAgICogQHJldHVybiBBICd0b3JjaCcgc3RhdGVtZW50IHBhcnNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVUb3JjaFN0YXRlbWVudFBhcnNlcigpIHtcbiAgICAgICAgdmFyIHRvcmNoID0gbmV3IFNlcXVlbmNlKCk7XG5cbiAgICAgICAgLy8gQWRkIHRvcmNoIHNlcXVlbmNlIGl0ZW1zXG4gICAgICAgIHRvcmNoLmFkZERpc2NhcmQobmV3IExpdGVyYWwoJ1RvcmNoJykpO1xuICAgICAgICB0b3JjaC5hZGQob3B0aW9uYWwobmV3IFBhcnNlck51bWJlcigpKSk7XG5cbiAgICAgICAgLy8gRGVmaW5lIGFzc2VtYmxlclxuICAgICAgICB0b3JjaC5hc3NlbWJsZXIgPSBjcmVhdGVBc3NlbWJsZXIoZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gYXNzZW1ibHkucGVlaygpICYmIGFzc2VtYmx5LnBlZWsoKS5uYW1lID09PSAnTlVNQkVSJyA/IGFzc2VtYmx5LnBvcCgpLnZhbHVlIDogMDtcbiAgICAgICAgICAgIGFzc2VtYmx5LnB1c2gobmV3IGNvbW1hbmRzLlRvcmNoQ29tbWFuZChyYWRpdXMpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRvcmNoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmUgU3RhdGVtZW50IFBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSAncmVzdG9yZScgc3RhdGVtZW50IHBhcnNlci5cbiAgICAgKiBAcmV0dXJuIEEgJ3Jlc3RvcmUnIHN0YXRlbWVudCBwYXJzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUmVzdG9yZVN0YXRlbWVudFBhcnNlcigpIHtcbiAgICAgICAgdmFyIHJlc3RvcmUgPSBuZXcgU2VxdWVuY2UoKTtcblxuICAgICAgICAvLyBBZGQgcmVzdG9yZSBzZXF1ZW5jZSBpdGVtc1xuICAgICAgICByZXN0b3JlLmFkZERpc2NhcmQobmV3IExpdGVyYWwoJ1Jlc3RvcmUnKSk7XG4gICAgICAgIHJlc3RvcmUuYWRkKG5ldyBXb3JkKCkpO1xuXG4gICAgICAgIC8vIERlZmluZSBhc3NlbWJsZXJcbiAgICAgICAgcmVzdG9yZS5hc3NlbWJsZXIgPSBjcmVhdGVBc3NlbWJsZXIoZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICBhc3NlbWJseS5wdXNoKG5ldyBjb21tYW5kcy5SZXN0b3JlQ29tbWFuZChhc3NlbWJseS5wb3AoKS52YWx1ZS50b1VwcGVyQ2FzZSgpKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN0b3JlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNheSBTdGF0ZW1lbnQgUGFyc2VyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhICdzYXknIHN0YXRlbWVudCBwYXJzZXIuXG4gICAgICogQHJldHVybiBBICdzYXknIHN0YXRlbWVudCBwYXJzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlU2F5U3RhdGVtZW50UGFyc2VyKCkge1xuICAgICAgICB2YXIgc2F5ID0gbmV3IFNlcXVlbmNlKCk7XG5cbiAgICAgICAgLy8gQWRkIHNheSBzZXF1ZW5jZSBpdGVtc1xuICAgICAgICBzYXkuYWRkRGlzY2FyZChuZXcgTGl0ZXJhbCgnU2F5JykpO1xuICAgICAgICBzYXkuYWRkKG5ldyBQYXJzZXJTdHJpbmcoKSk7XG5cbiAgICAgICAgLy8gRGVmaW5lIGFzc2VtYmxlclxuICAgICAgICBzYXkuYXNzZW1ibGVyID0gY3JlYXRlQXNzZW1ibGVyKGZ1bmN0aW9uIChhc3NlbWJseSkge1xuICAgICAgICAgICAgYXNzZW1ibHkucHVzaChuZXcgY29tbWFuZHMuU2F5Q29tbWFuZChhc3NlbWJseS5wb3AoKS52YWx1ZSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2F5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob290IFN0YXRlbWVudCBQYXJzZXJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgJ3Nob290JyBzdGF0ZW1lbnQgcGFyc2VyLlxuICAgICAqIEByZXR1cm4gQSAnc2hvb3QnIHN0YXRlbWVudCBwYXJzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlU2hvb3RTdGF0ZW1lbnRQYXJzZXIoKSB7XG4gICAgICAgIHZhciBzaG9vdCA9IG5ldyBTZXF1ZW5jZSgpO1xuXG4gICAgICAgIC8vIEFkZCBzaG9vdCBzZXF1ZW5jZSBpdGVtc1xuICAgICAgICBzaG9vdC5hZGREaXNjYXJkKG5ldyBMaXRlcmFsKCdTaG9vdCcpKTtcbiAgICAgICAgc2hvb3QuYWRkKGNyZWF0ZURpcmVjdGlvblBhcnNlcigpKTtcblxuICAgICAgICAvLyBEZWZpbmUgYXNzZW1ibGVyXG4gICAgICAgIHNob290LmFzc2VtYmxlciA9IGNyZWF0ZUFzc2VtYmxlcihmdW5jdGlvbiAoYXNzZW1ibHkpIHtcbiAgICAgICAgICAgIGFzc2VtYmx5LnB1c2gobmV3IGNvbW1hbmRzLlNob290Q29tbWFuZChhc3NlbWJseS5wb3AoKSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gc2hvb3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhbmQgU3RhdGVtZW50IFBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSAnc3RhbmQnIHN0YXRlbWVudCBwYXJzZXIuXG4gICAgICogQHJldHVybiBBICdzdGFuZCcgc3RhdGVtZW50IHBhcnNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVTdGFuZFN0YXRlbWVudFBhcnNlcigpIHtcbiAgICAgICAgdmFyIHN0YW5kID0gbmV3IExpdGVyYWwoJ1N0YW5kJyk7XG4gICAgICAgIHN0YW5kLmRpc2NhcmQgPSB0cnVlO1xuICAgICAgICBzdGFuZC5hc3NlbWJsZXIgPSBjcmVhdGVBc3NlbWJsZXIoZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICBhc3NlbWJseS5wdXNoKG5ldyBjb21tYW5kcy5TdGFuZENvbW1hbmQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RhbmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5sb2NrIFN0YXRlbWVudCBQYXJzZXJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuICd1bmxvY2snIHN0YXRlbWVudCBwYXJzZXIuXG4gICAgICogQHJldHVybiBBbiAndW5sb2NrJyBzdGF0ZW1lbnQgcGFyc2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVVubG9ja1N0YXRlbWVudFBhcnNlcigpIHtcbiAgICAgICAgdmFyIHVubG9jayA9IG5ldyBMaXRlcmFsKCdVbmxvY2snKTtcbiAgICAgICAgdW5sb2NrLmRpc2NhcmQgPSB0cnVlO1xuICAgICAgICB1bmxvY2suYXNzZW1ibGVyID0gY3JlYXRlQXNzZW1ibGVyKGZ1bmN0aW9uIChhc3NlbWJseSkge1xuICAgICAgICAgICAgYXNzZW1ibHkucHVzaChuZXcgY29tbWFuZHMuVW5sb2NrQ29tbWFuZCgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1bmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmljdG9yeSBTdGF0ZW1lbnQgUGFyc2VyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhICd2aWN0b3J5JyBzdGF0ZW1lbnQgcGFyc2VyLlxuICAgICAqIEByZXR1cm4gQSAndmljdG9yeScgc3RhdGVtZW50IHBhcnNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVWaWN0b3J5U3RhdGVtZW50UGFyc2VyKCkge1xuICAgICAgICB2YXIgdmljdG9yeSA9IG5ldyBMaXRlcmFsKCdWaWN0b3J5Jyk7XG4gICAgICAgIHZpY3RvcnkuZGlzY2FyZCA9IHRydWU7XG4gICAgICAgIHZpY3RvcnkuYXNzZW1ibGVyID0gY3JlYXRlQXNzZW1ibGVyKGZ1bmN0aW9uIChhc3NlbWJseSkge1xuICAgICAgICAgICAgYXNzZW1ibHkucHVzaChuZXcgY29tbWFuZHMuVmljdG9yeUNvbW1hbmQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdmljdG9yeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXYWl0IFN0YXRlbWVudCBQYXJzZXJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgJ3dhaXQnIHN0YXRlbWVudCBwYXJzZXIuXG4gICAgICogQHJldHVybiBBICd3YWl0JyBzdGF0ZW1lbnQgcGFyc2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVdhaXRTdGF0ZW1lbnRQYXJzZXIoKSB7XG4gICAgICAgIHZhciB3YWl0ID0gbmV3IFNlcXVlbmNlKCk7XG5cbiAgICAgICAgLy8gQWRkIHdhaXQgc2VxdWVuY2UgaXRlbXNcbiAgICAgICAgd2FpdC5hZGREaXNjYXJkKG5ldyBMaXRlcmFsKCdXYWl0JykpO1xuICAgICAgICB3YWl0LmFkZChvcHRpb25hbChuZXcgUGFyc2VyTnVtYmVyKCkpKTtcblxuICAgICAgICAvLyBEZWZpbmUgYXNzZW1ibGVyXG4gICAgICAgIHdhaXQuYXNzZW1ibGVyID0gY3JlYXRlQXNzZW1ibGVyKGZ1bmN0aW9uIChhc3NlbWJseSkge1xuICAgICAgICAgICAgdmFyIGN5Y2xlcyA9IGFzc2VtYmx5LnBlZWsoKSAmJiBhc3NlbWJseS5wZWVrKCkubmFtZSA9PT0gJ05VTUJFUicgPyBhc3NlbWJseS5wb3AoKS52YWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGFzc2VtYmx5LnB1c2gobmV3IGNvbW1hbmRzLldhaXRDb21tYW5kKGN5Y2xlcykpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdhaXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2FsayBTdGF0ZW1lbnQgUGFyc2VyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhICd3YWxrJyBzdGF0ZW1lbnQgcGFyc2VyLlxuICAgICAqIEByZXR1cm4gQSAnd2Fsaycgc3RhdGVtZW50IHBhcnNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVXYWxrU3RhdGVtZW50UGFyc2VyKCkge1xuICAgICAgICB2YXIgd2FsayA9IG5ldyBTZXF1ZW5jZSgpO1xuICAgICAgICB3YWxrLmFkZERpc2NhcmQobmV3IExpdGVyYWwoJ1dhbGsnKSk7XG4gICAgICAgIHdhbGsuYWRkKGNyZWF0ZURpcmVjdGlvblBhcnNlcigpKTtcbiAgICAgICAgd2Fsay5hc3NlbWJsZXIgPSBjcmVhdGVBc3NlbWJsZXIoZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgICAgICAgICBhc3NlbWJseS5wdXNoKG5ldyBjb21tYW5kcy5XYWxrQ29tbWFuZChhc3NlbWJseS5wb3AoKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdhbGs7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogWmFwIFN0YXRlbWVudCBQYXJzZXJcbiAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgJ3phcCcgc3RhdGVtZW50IHBhcnNlci5cbiAgICAgKiBAcmV0dXJuIEEgJ3phcCcgc3RhdGVtZW50IHBhcnNlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVaYXBTdGF0ZW1lbnRQYXJzZXIoKSB7XG4gICAgICAgIHZhciB6YXAgPSBuZXcgU2VxdWVuY2UoKTtcbiAgICAgICAgemFwLmFkZERpc2NhcmQobmV3IExpdGVyYWwoJ1phcCcpKTtcbiAgICAgICAgemFwLmFkZChuZXcgV29yZCgpKTtcbiAgICAgICAgemFwLmFzc2VtYmxlciA9IGNyZWF0ZUFzc2VtYmxlcihmdW5jdGlvbiAoYXNzZW1ibHkpIHtcbiAgICAgICAgICAgIGFzc2VtYmx5LnB1c2gobmV3IGNvbW1hbmRzLlphcENvbW1hbmQoYXNzZW1ibHkucG9wKCkudmFsdWUudG9VcHBlckNhc2UoKSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHphcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGF0ZW1lbnQgUGFyc2VyXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBzdGF0ZW1lbnQgcGFyc2VyLlxuICAgICAqIEByZXR1cm4gQSBzdGF0ZW1lbnQgcGFyc2VyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVN0YXRlbWVudFBhcnNlcigpIHtcbiAgICAgICAgdmFyIHN0YXRlbWVudCA9IG5ldyBTZXF1ZW5jZSgpLFxuICAgICAgICAgICAgc3RhdGVtZW50T3B0aW9ucyA9IG5ldyBBbHRlcm5hdGlvbigpO1xuXG4gICAgICAgIC8vIEFkZCBzdGF0ZW1lbnQgaXRlbXNcbiAgICAgICAgc3RhdGVtZW50T3B0aW9ucy5hZGQoY3JlYXRlQmVjb21lU3RhdGVtZW50UGFyc2VyKCkpO1xuICAgICAgICBzdGF0ZW1lbnRPcHRpb25zLmFkZChjcmVhdGVDaGFuZ2VTdGF0ZW1lbnRQYXJzZXIoKSk7XG4gICAgICAgIHN0YXRlbWVudE9wdGlvbnMuYWRkKGNyZWF0ZUNoYXJTdGF0ZW1lbnRQYXJzZXIoKSk7XG4gICAgICAgIHN0YXRlbWVudE9wdGlvbnMuYWRkKGNyZWF0ZURpZVN0YXRlbWVudFBhcnNlcigpKTtcbiAgICAgICAgc3RhdGVtZW50T3B0aW9ucy5hZGQoY3JlYXRlRW5kU3RhdGVtZW50UGFyc2VyKCkpO1xuICAgICAgICBzdGF0ZW1lbnRPcHRpb25zLmFkZChjcmVhdGVHb1N0YXRlbWVudFBhcnNlcigpKTtcbiAgICAgICAgc3RhdGVtZW50T3B0aW9ucy5hZGQoY3JlYXRlR2l2ZVN0YXRlbWVudFBhcnNlcigpKTtcbiAgICAgICAgc3RhdGVtZW50T3B0aW9ucy5hZGQoY3JlYXRlSWZTdGF0ZW1lbnRQYXJzZXIoKSk7XG4gICAgICAgIHN0YXRlbWVudE9wdGlvbnMuYWRkKGNyZWF0ZUxvY2tTdGF0ZW1lbnRQYXJzZXIoKSk7XG4gICAgICAgIHN0YXRlbWVudE9wdGlvbnMuYWRkKGNyZWF0ZVBsYXlTdGF0ZW1lbnRQYXJzZXIoKSk7XG4gICAgICAgIHN0YXRlbWVudE9wdGlvbnMuYWRkKGNyZWF0ZVB1dFN0YXRlbWVudFBhcnNlcigpKTtcbiAgICAgICAgc3RhdGVtZW50T3B0aW9ucy5hZGQoY3JlYXRlU2Nyb2xsU3RhdGVtZW50UGFyc2VyKCkpO1xuICAgICAgICBzdGF0ZW1lbnRPcHRpb25zLmFkZChjcmVhdGVTZW5kU3RhdGVtZW50UGFyc2VyKCkpO1xuICAgICAgICBzdGF0ZW1lbnRPcHRpb25zLmFkZChjcmVhdGVTZXRTdGF0ZW1lbnRQYXJzZXIoKSk7XG4gICAgICAgIHN0YXRlbWVudE9wdGlvbnMuYWRkKGNyZWF0ZVRha2VTdGF0ZW1lbnRQYXJzZXIoKSk7XG4gICAgICAgIHN0YXRlbWVudE9wdGlvbnMuYWRkKGNyZWF0ZVRocm93U3RhclN0YXRlbWVudFBhcnNlcigpKTtcbiAgICAgICAgc3RhdGVtZW50T3B0aW9ucy5hZGQoY3JlYXRlVG9yY2hTdGF0ZW1lbnRQYXJzZXIoKSk7XG4gICAgICAgIHN0YXRlbWVudE9wdGlvbnMuYWRkKGNyZWF0ZUdvU3RhdGVtZW50UGFyc2VyKCdUcnknLCBmYWxzZSkpO1xuICAgICAgICBzdGF0ZW1lbnRPcHRpb25zLmFkZChjcmVhdGVSZXN0b3JlU3RhdGVtZW50UGFyc2VyKCkpO1xuICAgICAgICBzdGF0ZW1lbnRPcHRpb25zLmFkZChjcmVhdGVTYXlTdGF0ZW1lbnRQYXJzZXIoKSk7XG4gICAgICAgIHN0YXRlbWVudE9wdGlvbnMuYWRkKGNyZWF0ZVNob290U3RhdGVtZW50UGFyc2VyKCkpO1xuICAgICAgICBzdGF0ZW1lbnRPcHRpb25zLmFkZChjcmVhdGVTdGFuZFN0YXRlbWVudFBhcnNlcigpKTtcbiAgICAgICAgc3RhdGVtZW50T3B0aW9ucy5hZGQoY3JlYXRlVW5sb2NrU3RhdGVtZW50UGFyc2VyKCkpO1xuICAgICAgICBzdGF0ZW1lbnRPcHRpb25zLmFkZChjcmVhdGVWaWN0b3J5U3RhdGVtZW50UGFyc2VyKCkpO1xuICAgICAgICBzdGF0ZW1lbnRPcHRpb25zLmFkZChjcmVhdGVXYWl0U3RhdGVtZW50UGFyc2VyKCkpO1xuICAgICAgICBzdGF0ZW1lbnRPcHRpb25zLmFkZChjcmVhdGVXYWxrU3RhdGVtZW50UGFyc2VyKCkpO1xuICAgICAgICBzdGF0ZW1lbnRPcHRpb25zLmFkZChjcmVhdGVaYXBTdGF0ZW1lbnRQYXJzZXIoKSk7XG4gICAgICAgIHN0YXRlbWVudC5hZGQoc3RhdGVtZW50T3B0aW9ucyk7XG4gICAgICAgIHN0YXRlbWVudC5hZGREaXNjYXJkKG5ldyBOZXdMaW5lKCkpO1xuXG4gICAgICAgIHJldHVybiBzdGF0ZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSnp0U2NyaXB0IFBhcnNlclxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBuZXcgSnp0U2NyaXB0IHBhcnNlci5cbiAgICAgKiBAcmV0dXJuIEEgSlpUIHNjcmlwdCBwYXJzZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlSnp0U2NyaXB0UGFyc2VyKCkge1xuXG4gICAgICAgIHZhciBwcm9ncmFtLFxuICAgICAgICAgICAgbGluZSA9IG5ldyBBbHRlcm5hdGlvbigpO1xuICAgICAgICBsaW5lLmFkZChjcmVhdGVMYWJlbFBhcnNlcigpKTtcbiAgICAgICAgbGluZS5hZGQoY3JlYXRlU3RhdGVtZW50UGFyc2VyKCkpO1xuICAgICAgICBsaW5lLmFkZERpc2NhcmQobmV3IE5ld0xpbmUoKSk7XG4gICAgICAgIHByb2dyYW0gPSBuZXcgUmVwZXRpdGlvbihsaW5lKTtcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG5cbiAgICB9XG5cbiAgICB0aGlzLnBhcnNlciA9IGNyZWF0ZUp6dFNjcmlwdFBhcnNlcigpO1xuXG59XG5cbkp6dFNjcmlwdFBhcnNlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoc2NyaXB0KSB7XG5cbiAgICB2YXIgbGV4ZXIsXG4gICAgICAgIHRva2VucyxcbiAgICAgICAgYXNzZW1ibHksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIC8vIElmIG91ciBzY3JpcHQgZG9lc24ndCBhbHJlYWR5IGVuZCBpbiBhIG5ld2xpbmUsIGFkZCBpdCBub3dcbiAgICBpZiAoc2NyaXB0LmNoYXJBdChzY3JpcHQubGVuZ3RoIC0gMSkgIT09ICdcXG4nKSB7XG4gICAgICAgIHNjcmlwdCArPSAnXFxuJztcbiAgICB9XG5cbiAgICBsZXhlciA9IG5ldyBMZXhlcihzY3JpcHQpO1xuICAgIHRva2VucyA9IGxleGVyLnRva2VuaXplQWxsKCk7XG4gICAgYXNzZW1ibHkgPSBuZXcgQXNzZW1ibHkodG9rZW5zKTtcbiAgICByZXN1bHQgPSB0aGlzLnBhcnNlci5jb21wbGV0ZU1hdGNoKGFzc2VtYmx5KTtcblxuICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyAnQ2F0ZXN0cm9waGljIHNjcmlwdCBlcnJvci4gTm8gcmVzdWx0Lic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC5zdGFjaztcblxufTtcblxuZXhwb3J0cy5KenRTY3JpcHRQYXJzZXIgPSBKenRTY3JpcHRQYXJzZXI7XG4iLCIvKipcbiAqIEpaVFNjcmlwdFxuICogQ29weXJpZ2h0IMKpIDIwMTQgT3JhbmdlbGluZSBJbnRlcmFjdGl2ZSwgSW5jLlxuICogQGF1dGhvciBNYXJrIE1jSW50eXJlXG4gKi9cblxuLypqc2xpbnQgbm9kZTp0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNvbW1hbmRzID0gcmVxdWlyZSgnLi9qenQtc2NyaXB0LWNvbW1hbmRzJyksXG4gICAgSnp0U2NyaXB0UGFyc2VyID0gcmVxdWlyZSgnLi9qenQtc2NyaXB0LXBhcnNlcicpLkp6dFNjcmlwdFBhcnNlcixcbiAgICBzY3JpcHRQYXJzZXIgPSBuZXcgSnp0U2NyaXB0UGFyc2VyKCksXG4gICAgQ29uc3RydWN0b3JFcnJvciA9IHJlcXVpcmUoJy4vYmFzaWMnKS5Db25zdHJ1Y3RvckVycm9yLFxuICAgIEdhbWVTdGF0ZSA9IHJlcXVpcmUoJy4vZ2FtZS1zdGF0ZScpLkdhbWVTdGF0ZTtcblxuLyoqXG4gKiBKenRTY3JpcHRcbiAqL1xuZnVuY3Rpb24gSnp0U2NyaXB0KG5hbWUsIHJhd1NjcmlwdCwgY29tcGlsZUltbWVkaWF0ZWx5KSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSnp0U2NyaXB0KSkge1xuICAgICAgICB0aHJvdyBDb25zdHJ1Y3RvckVycm9yO1xuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5yYXdTY3JpcHQgPSByYXdTY3JpcHQ7XG4gICAgdGhpcy5sYWJlbEluZGljaWVzID0ge307XG4gICAgdGhpcy5jb21tYW5kcyA9IFtdO1xuXG4gICAgaWYgKGNvbXBpbGVJbW1lZGlhdGVseSkge1xuICAgICAgICB0aGlzLmNvbXBpbGUoKTtcbiAgICB9XG5cbn1cblxuSnp0U2NyaXB0LnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGluZGV4LFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICBjb21tYW5kU3RhY2sgPSBzY3JpcHRQYXJzZXIucGFyc2UodGhpcy5yYXdTY3JpcHQpO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHByb3ZpZGVkIGxhYmVsIHRvIHRoaXMgSnp0U2NyaXB0IHRvIGJlIGFzc29jaWF0ZWQgd2l0aCBhIHByb3ZpZGVkXG4gICAgICogY29tbWFuZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYWJlbCBBIG5hbWUgb2YgYSBsYWJlbFxuICAgICAqIEBwYXJhbSBjb21tYW5kSW5kZXggQSBudW1lcmljIGluZGV4XG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkTGFiZWwob3duZXIsIGxhYmVsLCBjb21tYW5kSW5kZXgpIHtcbiAgICAgICAgLy8gSWYgbm8gY29tbWFuZCBpbmRleCB3YXMgcHJvdmlkZWQsIHVzZSB0aGUgY3VycmVudCBjb21tYW5kIHBvc2l0aW9uXG4gICAgICAgIGNvbW1hbmRJbmRleCA9IGNvbW1hbmRJbmRleCA9PT0gdW5kZWZpbmVkID8gb3duZXIuY29tbWFuZHMubGVuZ3RoIDogY29tbWFuZEluZGV4O1xuXG4gICAgICAgIC8vIEhhdmUgd2Ugc2VlbiB0aGlzIGxhYmVsIGJlZm9yZT9cbiAgICAgICAgaWYgKG93bmVyLmxhYmVsSW5kaWNpZXMuaGFzT3duUHJvcGVydHkobGFiZWwubmFtZSkpIHtcblxuICAgICAgICAgICAgLy8gVGhlIGxhYmVsIGFscmVhZHkgZXhpc3RzLCBzbyBwdXNoIHRoZSBuZXcgbGFiZWxcbiAgICAgICAgICAgIC8vIHRvIHRoZSBzdGFja1xuICAgICAgICAgICAgb3duZXIubGFiZWxJbmRpY2llc1tsYWJlbC5uYW1lXS5wdXNoKGNvbW1hbmRJbmRleCk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gV2UndmUgZ290IGEgbmV3IGxhYmVsXG4gICAgICAgICAgICBvd25lci5sYWJlbEluZGljaWVzW2xhYmVsLm5hbWVdID0gW2NvbW1hbmRJbmRleF07XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFB1dCB0aGUgY29tbWFuZHMgaW50byBvdXIgdGFyZ2V0XG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgY29tbWFuZFN0YWNrLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuXG4gICAgICAgIC8vIEdyYWIgb3VyIG5leHQgZWxlbWVudFxuICAgICAgICBlbGVtZW50ID0gY29tbWFuZFN0YWNrW2luZGV4XTtcblxuICAgICAgICAvLyBXaGF0IGRvIHdlIGhhdmUsIGV4YWN0bHk/XG4gICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgY29tbWFuZHMuTGFiZWwpIHtcblxuICAgICAgICAgICAgLy8gSXQncyBhIGxhYmVsLiBBZGQgaXQuXG4gICAgICAgICAgICBhZGRMYWJlbCh0aGlzLCBlbGVtZW50KTtcblxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LmV4ZWN1dGUgPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICAgICAgLy8gV2UndmUgZ290IGFuIGV4ZWN1dGFibGUgaXRlbVxuICAgICAgICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKGVsZW1lbnQpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIFdlJ3ZlIGdvdCBzb21ldGhpbmcgZWxzZS4gU29tZXRoaW5nLi4uIHVuZXhwZWN0ZWQhXG4gICAgICAgICAgICB0aHJvdyAnQ2F0ZXN0cm9waGljIHNjcmlwdCBlcnJvci4gVW5leHBlY3RlZCBvYmplY3QgaW4gY29tbWFuZCBzdGFjay4nO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuSnp0U2NyaXB0LnByb3RvdHlwZS5nZXRDb21tYW5kID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuY29tbWFuZHNbaW5kZXhdO1xufTtcblxuSnp0U2NyaXB0LnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICByYXdTY3JpcHQ6IHRoaXMucmF3U2NyaXB0XG4gICAgfTtcbn07XG5cbmV4cG9ydHMuSnp0U2NyaXB0ID0gSnp0U2NyaXB0O1xuIiwiLyoqXG4gKiBKWlQgTGV4ZXJcbiAqIENvcHlyaWdodCDCqSAyMDE0IE9yYW5nZWxpbmUgSW50ZXJhY3RpdmUsIEluYy5cbiAqIEBhdXRob3IgTWFyayBNY0ludHlyZVxuICovXG5cbi8qanNsaW50IG5vZGU6dHJ1ZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDb25zdHJ1Y3RvckVycm9yID0gcmVxdWlyZSgnLi9iYXNpYycpLkNvbnN0cnVjdG9yRXJyb3I7XG5cbmZ1bmN0aW9uIGlzTmV3TGluZShjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gY2hhcmFjdGVyID09PSAnXFxyJyB8fCBjaGFyYWN0ZXIgPT09ICdcXG4nO1xufVxuXG5mdW5jdGlvbiBpc1doaXRlU3BhY2UoY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3RlciA9PT0gJyAnIHx8IGNoYXJhY3RlciA9PT0gJ1xcdCcgfHwgY2hhcmFjdGVyID09PSAnXFxyJztcbn1cblxuZnVuY3Rpb24gaXNBbHBoYShjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gKGNoYXJhY3RlciA+PSAnYScgJiYgY2hhcmFjdGVyIDw9ICd6JykgfHwgKGNoYXJhY3RlciA+PSAnQScgJiYgY2hhcmFjdGVyIDw9ICdaJykgfHwgY2hhcmFjdGVyID09PSAnXyc7XG59XG5cbmZ1bmN0aW9uIGlzTnVtZXJpYyhjaGFyYWN0ZXIpIHtcbiAgICByZXR1cm4gKGNoYXJhY3RlciA+PSAnMCcgJiYgY2hhcmFjdGVyIDw9ICc5Jyk7XG59XG5cbmZ1bmN0aW9uIGlzQWxwaGFOdW1lcmljKGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBpc0FscGhhKGNoYXJhY3RlcikgfHwgaXNOdW1lcmljKGNoYXJhY3Rlcik7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBMZXhlciBpbnN0YW5jZVxuICogQHBhcmFtIGlucHV0U3RyaW5nIElucHV0IHRleHQgdG8gYmUgbGV4ZWRcbiAqIEBwYXJhbSBza2lwQ29tbWVudHMgV2hldGhlciBvciBub3QgdG8gc2tpcCBjb21tZW50cyBmcm9tIHRoZSB0b2tlbiBzdHJlYW0gKGRlZmF1bHQgaXMgdHJ1ZSlcbiAqL1xuZnVuY3Rpb24gTGV4ZXIoaW5wdXRTdHJpbmcsIHNraXBDb21tZW50cykge1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExleGVyKSkge1xuICAgICAgICB0aHJvdyBDb25zdHJ1Y3RvckVycm9yO1xuICAgIH1cblxuICAgIHRoaXMuc2tpcENvbW1lbnRzID0gc2tpcENvbW1lbnRzICE9PSB1bmRlZmluZWQgPyBza2lwQ29tbWVudHMgOiB0cnVlO1xuICAgIHRoaXMuc2V0SW5wdXQoaW5wdXRTdHJpbmcpO1xuXG59XG5cbkxleGVyLnByb3RvdHlwZS5zZXRJbnB1dCA9IGZ1bmN0aW9uIChpbnB1dFN0cmluZykge1xuXG4gICAgdGhpcy5wb3NpdGlvbiA9IDA7XG4gICAgdGhpcy5idWZmZXIgPSBpbnB1dFN0cmluZztcbiAgICB0aGlzLmJ1ZmZlckxlbmd0aCA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLmxpbmUgPSAxO1xuICAgIHRoaXMuY29sdW1uID0gMTtcblxufTtcblxuTGV4ZXIucHJvdG90eXBlLnRva2VuaXplQWxsID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICB0b2tlbiA9IHRoaXMubmV4dFRva2VuKCk7XG4gICAgd2hpbGUgKHRva2VuKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRva2VuKTtcbiAgICAgICAgdG9rZW4gPSB0aGlzLm5leHRUb2tlbigpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG5cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBuZXh0IHRva2VuIGluIG91ciBpbnB1dCBzdHJlYW0gYW5kIHJldHVybnMgaXQuIElmIG5vIHRva2VucyBhcmUgbGVmdCxcbiAqIHVuZGVmaW5lZCBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcmV0dXJuIGEgbmV4dCB0b2tlbiBvciB1bmRlZmluZWRcbiAqL1xuTGV4ZXIucHJvdG90eXBlLm5leHRUb2tlbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBjLFxuICAgICAgICB0b2tlbixcbiAgICAgICAgbmV4dDtcblxuICAgIC8vIENvbnN1bWUgbm9uLXRva2VucyBmaXJzdFxuICAgIHRoaXMuY29uc3VtZU5vblRva2VucygpO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgbm90aGluZyBsZWZ0IHRvIHJldHVybiwgZXhpdCB3aXRob3V0IGEgcmV0dXJuIHZhbHVlXG4gICAgaWYgKHRoaXMucG9zaXRpb24gPj0gdGhpcy5idWZmZXJMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGMgPSB0aGlzLmdldENoYXJhY3RlcigpO1xuXG4gICAgLy8gQ29tbWVudFxuICAgIGlmIChjID09PSAnLycgJiYgdGhpcy5nZXRDaGFyYWN0ZXIoMSkgPT09ICcvJykge1xuICAgICAgICB0b2tlbiA9IHRoaXMuY3JlYXRlQ29tbWVudFRva2VuKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNraXBDb21tZW50cyA/IHRoaXMubmV4dFRva2VuKCkgOiB0b2tlbjtcbiAgICB9XG5cbiAgICAvLyBTdHJpbmdcbiAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTdHJpbmdUb2tlbigpO1xuICAgIH1cblxuICAgIC8vIE9wZXJhdG9yXG4gICAgaWYgKGMgPT09ICc8JyB8fCBjID09PSAnPicgfHwgYyA9PT0gJz0nIHx8IGMgPT09ICc6Jykge1xuXG4gICAgICAgIG5leHQgPSB0aGlzLmdldENoYXJhY3RlcigxKTtcbiAgICAgICAgaWYgKG5leHQgPT09ICc9JyAmJiBjICE9PSAnPScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKCdPUEVSQVRPUicsIGMgKyBuZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKCdPUEVSQVRPUicsIGMpO1xuXG4gICAgfVxuXG4gICAgLy8gUHVuY3R1YXRpb25cbiAgICBpZiAoYyA9PT0gJywnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKCdQVU5DVFVBVElPTicsIGMpO1xuICAgIH1cblxuICAgIC8vIE5ldyBMaW5lXG4gICAgaWYgKGlzTmV3TGluZShjKSkge1xuICAgICAgICB0b2tlbiA9IHRoaXMuY3JlYXRlVG9rZW4oJ05FV0xJTkUnLCAnW05ldyBMaW5lXScsIDEpO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IDE7XG4gICAgICAgIHRoaXMubGluZSArPSAxO1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgfVxuXG4gICAgLy8gTnVtYmVyIFRva2VuXG4gICAgaWYgKGlzTnVtZXJpYyhjKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVOdW1iZXJUb2tlbigpO1xuICAgIH1cblxuICAgIC8vIFdvcmQgVG9rZW5cbiAgICBpZiAoaXNBbHBoYShjKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVXb3JkVG9rZW4oKTtcbiAgICB9XG5cbiAgICB0aHJvdyAnVW5yZWNvZ25pemVkIHRva2VuIG9uIGxpbmUgJyArIHRoaXMubGluZSArICcsIGNvbHVtbiAnICsgdGhpcy5jb2x1bW47XG5cblxufTtcblxuLyoqXG4gKiBHZXRzIGEgY2hhcmFjdGVyIGZyb20gb3VyIGlucHV0IHN0cmluZyB3aXRoIGFuIG9wdGlvbmFsIG9mZnNldC5cbiAqXG4gKiBAcGFyYW0gQW4gb3B0aW9uYWwgbnVtZXJpY2FsIG9mZnNldFxuICogQHJldHVybiBhIHNpbmdsZSBjaGFyYWN0ZXIgZnJvbSBvdXIgaW5wdXQgc3RyaW5nXG4gKi9cbkxleGVyLnByb3RvdHlwZS5nZXRDaGFyYWN0ZXIgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG5cbiAgICB2YXIgcG9zaXRpb24gPSBvZmZzZXQgPT09IHVuZGVmaW5lZCA/IHRoaXMucG9zaXRpb24gOiB0aGlzLnBvc2l0aW9uICsgb2Zmc2V0O1xuICAgIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gdGhpcy5idWZmZXJMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLmNoYXJBdChwb3NpdGlvbik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb21tZW50IHRva2VuXG4gKi9cbkxleGVyLnByb3RvdHlwZS5jcmVhdGVDb21tZW50VG9rZW4gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdG9rZW4sXG4gICAgICAgIGVuZFBvc2l0aW9uO1xuXG4gICAgLy8gVGhlIGVuZCBwb3NpdGlvbiBpcyBvdXIgcG9zaXRpb24gcGx1cyB0aGUgbGVuZ3RoIG9mIHRoZSBjb21tZW50IGNoYXJhY3RlcnNcbiAgICBlbmRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gKyAnLy8nLmxlbmd0aDtcblxuICAgIC8vIExvb3AgdW50aWwgdGhlIGZpcnN0IG5ldyBsaW5lXG4gICAgd2hpbGUgKGVuZFBvc2l0aW9uIDwgdGhpcy5idWZmZXJMZW5ndGggJiYgIWlzTmV3TGluZSh0aGlzLmJ1ZmZlci5jaGFyQXQoZW5kUG9zaXRpb24pKSkge1xuICAgICAgICBlbmRQb3NpdGlvbiArPSAxO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBvdXIgdG9rZW5cbiAgICB0b2tlbiA9IHRoaXMuY3JlYXRlVG9rZW4oJ0NPTU1FTlQnLCB0aGlzLmJ1ZmZlci5zdWJzdHJpbmcodGhpcy5wb3NpdGlvbiArICcvLycubGVuZ3RoLCBlbmRQb3NpdGlvbiksIGVuZFBvc2l0aW9uIC0gdGhpcy5wb3NpdGlvbik7XG5cbiAgICAvLyBSZXR1cm4gb3VyIHRva2VuXG4gICAgcmV0dXJuIHRva2VuO1xuXG59O1xuXG5MZXhlci5wcm90b3R5cGUuY3JlYXRlU3RyaW5nVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdG9rZW4sXG4gICAgICAgIGMsXG4gICAgICAgIHJlc3VsdCA9ICcnLFxuICAgICAgICBlbmRQb3NpdGlvbjtcblxuICAgIC8vIFRoZSBlbmQgcG9zaXRpb24gaXMgb3VyIHBvc2l0aW9uIHBsdXMgdGhlIGxlbmd0aCBvZiBvdXIgc3RyaW5nIGNoYXJhY3RlclxuICAgIGVuZFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbiArIDE7XG5cbiAgICAvLyBMb29wIHVudGlsIHdlIGdldCBhIG5vbi1lc2NhcGVkIHN0cmluZyB0ZXJtaW5hbFxuICAgIHdoaWxlIChlbmRQb3NpdGlvbiA8IHRoaXMuYnVmZmVyTGVuZ3RoKSB7XG5cbiAgICAgICAgLy8gR3JhYiB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgYyA9IHRoaXMuYnVmZmVyLmNoYXJBdChlbmRQb3NpdGlvbik7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIG91ciBuZXh0IGNoYXJhY3RlciBzZXF1ZW5jZVxuICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnICYmIHRoaXMuYnVmZmVyLmNoYXJBdChlbmRQb3NpdGlvbiArIDEpID09PSAnXCInKSB7XG5cbiAgICAgICAgICAgIC8vIFdlJ3ZlIGVuY291bnRlcmQgYW4gZXNjYXBlZCBxdW90ZVxuICAgICAgICAgICAgcmVzdWx0ICs9ICdcIic7XG4gICAgICAgICAgICBlbmRQb3NpdGlvbiArPSAyO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gJ1xcXFwnICYmIHRoaXMuYnVmZmVyLmNoYXJBdChlbmRQb3NpdGlvbiArIDEpID09PSAnbicpIHtcblxuICAgICAgICAgICAgLy8gV2UndmUgZW5jb3VudGVyZWQgYW4gZXNjYXBlZCBuZXdsaW5lXG4gICAgICAgICAgICByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICBlbmRQb3NpdGlvbiArPSAyO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhbiBlbmQgcXVvdGUgb3VyIHN0cmluZyBpcyBvdmVyXG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgIGVuZFBvc2l0aW9uICs9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE5ld2xpbmVzIGFyZSBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoaXNOZXdMaW5lKGMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ1VudGVybWluYXRlZCBzdHJpbmcgbGl0ZXJhbCBvbiBsaW5lICcgKyB0aGlzLmxpbmUgKyAnLCBjb2x1bW4gJyArIHRoaXMuY29sdW1uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHQgKz0gYztcbiAgICAgICAgICAgIGVuZFBvc2l0aW9uICs9IDE7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG91ciB0b2tlblxuICAgIHRva2VuID0gdGhpcy5jcmVhdGVUb2tlbignU1RSSU5HJywgcmVzdWx0LCBlbmRQb3NpdGlvbiAtIHRoaXMucG9zaXRpb24pO1xuXG4gICAgcmV0dXJuIHRva2VuO1xuXG59O1xuXG5MZXhlci5wcm90b3R5cGUuY3JlYXRlTnVtYmVyVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgZW5kUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uO1xuICAgIHdoaWxlIChlbmRQb3NpdGlvbiA8IHRoaXMuYnVmZmVyTGVuZ3RoICYmIGlzTnVtZXJpYyh0aGlzLmJ1ZmZlci5jaGFyQXQoZW5kUG9zaXRpb24pKSkge1xuICAgICAgICBlbmRQb3NpdGlvbiArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKCdOVU1CRVInLCArKHRoaXMuYnVmZmVyLnN1YnN0cmluZyh0aGlzLnBvc2l0aW9uLCBlbmRQb3NpdGlvbikpLCBlbmRQb3NpdGlvbiAtIHRoaXMucG9zaXRpb24pO1xuXG59O1xuXG5MZXhlci5wcm90b3R5cGUuY3JlYXRlV29yZFRva2VuID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGVuZFBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICB3aGlsZSAoZW5kUG9zaXRpb24gPCB0aGlzLmJ1ZmZlckxlbmd0aCAmJiBpc0FscGhhTnVtZXJpYyh0aGlzLmJ1ZmZlci5jaGFyQXQoZW5kUG9zaXRpb24pKSkge1xuICAgICAgICBlbmRQb3NpdGlvbiArPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKCdXT1JEJywgdGhpcy5idWZmZXIuc3Vic3RyaW5nKHRoaXMucG9zaXRpb24sIGVuZFBvc2l0aW9uKSk7XG5cbn07XG5cbi8qKlxuICogQ29uc3VtZXMgd2hpdGVzcGFjZSBmcm9tIG91ciBpbnB1dCBzdHJpbmdcbiAqL1xuTGV4ZXIucHJvdG90eXBlLmNvbnN1bWVOb25Ub2tlbnMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBMb29wIHRocm91Z2ggb3VyIGNoYXJhY3RlcnMuLi5cbiAgICB3aGlsZSAodGhpcy5wb3NpdGlvbiA8IHRoaXMuYnVmZmVyTGVuZ3RoKSB7XG5cbiAgICAgICAgaWYgKCFpc1doaXRlU3BhY2UodGhpcy5nZXRDaGFyYWN0ZXIoKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucG9zaXRpb24gKz0gMTtcbiAgICAgICAgdGhpcy5jb2x1bW4gKz0gMTtcblxuICAgIH1cblxufTtcblxuTGV4ZXIucHJvdG90eXBlLmNyZWF0ZVRva2VuID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCByZWFsTGVuZ3RoKSB7XG5cbiAgICByZWFsTGVuZ3RoID0gcmVhbExlbmd0aCA9PT0gdW5kZWZpbmVkID8gdmFsdWUubGVuZ3RoIDogcmVhbExlbmd0aDtcblxuICAgIHZhciB0b2tlbiA9IHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLnBvc2l0aW9uXG4gICAgfTtcblxuICAgIHRoaXMucG9zaXRpb24gKz0gcmVhbExlbmd0aDtcbiAgICB0aGlzLmNvbHVtbiArPSByZWFsTGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRva2VuO1xuXG59O1xuXG5leHBvcnRzLkxleGVyID0gTGV4ZXI7XG4iLCIvKipcbiAqIEpaVCBQYXJzZXJcbiAqIENvcHlyaWdodCDCqSAyMDE0IE9yYW5nZWxpbmUgSW50ZXJhY3RpdmUsIEluYy5cbiAqIEBhdXRob3IgTWFyayBNY0ludHlyZVxuICovXG5cbi8qanNsaW50IG5vZGU6IHRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29uc3RydWN0b3JFcnJvciA9IHJlcXVpcmUoJy4vYmFzaWMnKS5Db25zdHJ1Y3RvckVycm9yO1xuXG4vKlxuICogQXNzZW1ibHlcbiAqL1xuZnVuY3Rpb24gQXNzZW1ibHkodG9rZW5zKSB7XG5cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQXNzZW1ibHkpKSB7XG4gICAgICAgIHRocm93IENvbnN0cnVjdG9yRXJyb3I7XG4gICAgfVxuXG4gICAgdGhpcy50b2tlbnMgPSB0b2tlbnM7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5zdGFjayA9IFtdO1xuICAgIHRoaXMudGFyZ2V0ID0gdW5kZWZpbmVkO1xuXG59XG5cbkFzc2VtYmx5LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEFzc2VtYmx5KCk7XG4gICAgcmVzdWx0LnRva2VucyA9IHRoaXMudG9rZW5zLnNsaWNlKDApO1xuICAgIHJlc3VsdC5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgcmVzdWx0LnN0YWNrID0gdGhpcy5zdGFjay5zbGljZSgwKTtcbiAgICByZXN1bHQudGFyZ2V0ID0gdGhpcy50YXJnZXQgPyB0aGlzLnRhcmdldC5jbG9uZSgpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5Bc3NlbWJseS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5pbmRleF07XG59O1xuXG5Bc3NlbWJseS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xufTtcblxuQXNzZW1ibHkucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjay5wb3AoKTtcbn07XG5cbkFzc2VtYmx5LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goaXRlbSk7XG59O1xuXG5Bc3NlbWJseS5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4ID49IHRoaXMudG9rZW5zLmxlbmd0aDtcbn07XG5cbkFzc2VtYmx5LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnRva2Vuc1t0aGlzLmluZGV4XTtcbiAgICB0aGlzLmluZGV4ICs9IDE7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qXG4gKiBQYXJzZXJcbiAqL1xuZnVuY3Rpb24gUGFyc2VyKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXJzZXIpKSB7XG4gICAgICAgIHRocm93IENvbnN0cnVjdG9yRXJyb3I7XG4gICAgfVxuICAgIHRoaXMuYXNzZW1ibGVyID0gdW5kZWZpbmVkO1xufVxuXG5QYXJzZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXTtcbn07XG5cblBhcnNlci5wcm90b3R5cGUuYmVzdE1hdGNoID0gZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMubWF0Y2hBbmRBc3NlbWJsZShbYXNzZW1ibHldKTtcbiAgICByZXR1cm4gdGhpcy5maW5kQmVzdEFzc2VtYmx5KHJlc3VsdCk7XG59O1xuXG5QYXJzZXIucHJvdG90eXBlLmNvbXBsZXRlTWF0Y2ggPSBmdW5jdGlvbiAoYXNzZW1ibHkpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5iZXN0TWF0Y2goYXNzZW1ibHkpLFxuICAgICAgICB0b2tlbjtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0LmlzRG9uZSgpKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgdG9rZW4gPSByZXN1bHQuY3VycmVudCgpO1xuICAgIHRocm93ICdVbmV4cGVjdGVkIHRva2VuIFxcJycgKyB0b2tlbi52YWx1ZSArICdcXCcgb24gbGluZSAnICsgdG9rZW4ubGluZSArICcsIGNvbHVtbiAnICsgdG9rZW4uY29sdW1uO1xufTtcblxuUGFyc2VyLnByb3RvdHlwZS5tYXRjaEFuZEFzc2VtYmxlID0gZnVuY3Rpb24gKGFzc2VtYmxpZXMpIHtcblxuICAgIHZhciByZXN1bHQgPSB0aGlzLm1hdGNoKGFzc2VtYmxpZXMpLFxuICAgICAgICBpbmRleDtcblxuICAgIC8vIElmIHdlJ3ZlIGdvdCBhbiBhc3NlbWJsZXIsIGhhdmUgaXQgYXNzZW1ibGVcbiAgICBpZiAodGhpcy5hc3NlbWJsZXIpIHtcblxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCByZXN1bHQubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VtYmxlci5hc3NlbWJsZShyZXN1bHRbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblBhcnNlci5wcm90b3R5cGUuZmluZEJlc3RBc3NlbWJseSA9IGZ1bmN0aW9uIChhc3NlbWJsaWVzKSB7XG5cbiAgICB2YXIgYmVzdEFzc2VtYmx5LFxuICAgICAgICBpbmRleCxcbiAgICAgICAgYXNzZW1ibHk7XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhc3NlbWJsaWVzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuXG4gICAgICAgIGFzc2VtYmx5ID0gYXNzZW1ibGllc1tpbmRleF07XG5cbiAgICAgICAgaWYgKCFiZXN0QXNzZW1ibHkpIHtcbiAgICAgICAgICAgIGJlc3RBc3NlbWJseSA9IGFzc2VtYmx5O1xuICAgICAgICB9IGVsc2UgaWYgKGFzc2VtYmx5LmluZGV4ID4gYmVzdEFzc2VtYmx5LmluZGV4KSB7XG4gICAgICAgICAgICBiZXN0QXNzZW1ibHkgPSBhc3NlbWJseTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiZXN0QXNzZW1ibHk7XG5cbn07XG5cblBhcnNlci5wcm90b3R5cGUuY2xvbmVBc3NlbWJsaWVzID0gZnVuY3Rpb24gKGFzc2VtYmxpZXMpIHtcblxuICAgIHZhciByZXN1bHQgPSBbXSwgaW5kZXgsIGFzc2VtYmx5O1xuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgYXNzZW1ibGllcy5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgYXNzZW1ibHkgPSBhc3NlbWJsaWVzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0LnB1c2goYXNzZW1ibHkuY2xvbmUoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcblxufTtcblxuLypcbiAqIFJlcGV0aXRpb25cbiAqL1xuZnVuY3Rpb24gUmVwZXRpdGlvbihzdWJQYXJzZXIpIHtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXBldGl0aW9uKSkge1xuICAgICAgICB0aHJvdyBDb25zdHJ1Y3RvckVycm9yO1xuICAgIH1cblxuICAgIGlmICghc3ViUGFyc2VyKSB7XG4gICAgICAgIHRocm93ICdTdWJwYXJzZXIgaXMgcmVxdWlyZWQuJztcbiAgICB9XG4gICAgdGhpcy5zdWJQYXJzZXIgPSBzdWJQYXJzZXI7XG4gICAgdGhpcy5hc3NlbWJsZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wcmVBc3NlbWJsZXIgPSB1bmRlZmluZWQ7XG59XG5SZXBldGl0aW9uLnByb3RvdHlwZSA9IG5ldyBQYXJzZXIoKTtcblJlcGV0aXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVwZXRpdGlvbjtcblxuUmVwZXRpdGlvbi5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAoYXNzZW1ibGllcykge1xuXG4gICAgdmFyIGluZGV4LCBhc3NlbWJseSwgcmVzdWx0O1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIHByZWFzc2VtYmVyLCBhc3NlbWJsZSBub3dcbiAgICBpZiAodGhpcy5wcmVBc3NlbWJsZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhc3NlbWJsaWVzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgYXNzZW1ibHkgPSBhc3NlbWJsaWVzW2luZGV4XTtcbiAgICAgICAgICAgIHRoaXMucHJlQXNzZW1ibGVyLmFzc2VtYmxlKGFzc2VtYmx5KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdCA9IHRoaXMuY2xvbmVBc3NlbWJsaWVzKGFzc2VtYmxpZXMpO1xuICAgIHdoaWxlIChhc3NlbWJsaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYXNzZW1ibGllcyA9IHRoaXMuc3ViUGFyc2VyLm1hdGNoQW5kQXNzZW1ibGUoYXNzZW1ibGllcyk7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoYXNzZW1ibGllcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcblxufTtcblxuLypcbiAqIEVtcHR5XG4gKi9cbmZ1bmN0aW9uIEVtcHR5KCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFbXB0eSkpIHtcbiAgICAgICAgdGhyb3cgQ29uc3RydWN0b3JFcnJvcjtcbiAgICB9XG4gICAgdGhpcy5hc3NlbWJsZXIgPSB1bmRlZmluZWQ7XG59XG5FbXB0eS5wcm90b3R5cGUgPSBuZXcgUGFyc2VyKCk7XG5FbXB0eS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFbXB0eTtcblxuRW1wdHkucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKGFzc2VtYmxpZXMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZUFzc2VtYmxpZXMoYXNzZW1ibGllcyk7XG59O1xuXG4vKlxuICogQ29sbGVjdGlvblBhcnNlclxuICovXG5mdW5jdGlvbiBDb2xsZWN0aW9uUGFyc2VyKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDb2xsZWN0aW9uUGFyc2VyKSkge1xuICAgICAgICB0aHJvdyBDb25zdHJ1Y3RvckVycm9yO1xuICAgIH1cbiAgICB0aGlzLmFzc2VtYmxlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN1YlBhcnNlcnMgPSBbXTtcbn1cbkNvbGxlY3Rpb25QYXJzZXIucHJvdG90eXBlID0gbmV3IFBhcnNlcigpO1xuQ29sbGVjdGlvblBhcnNlci5jb25zdHJ1Y3RvciA9IENvbGxlY3Rpb25QYXJzZXI7XG5cbkNvbGxlY3Rpb25QYXJzZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChzdWJQYXJzZXIpIHtcbiAgICB0aGlzLnN1YlBhcnNlcnMucHVzaChzdWJQYXJzZXIpO1xufTtcblxuQ29sbGVjdGlvblBhcnNlci5wcm90b3R5cGUuYWRkRGlzY2FyZCA9IGZ1bmN0aW9uIChzdWJQYXJzZXIpIHtcbiAgICBzdWJQYXJzZXIuZGlzY2FyZCA9IHRydWU7XG4gICAgdGhpcy5zdWJQYXJzZXJzLnB1c2goc3ViUGFyc2VyKTtcbn07XG5cbi8qXG4gKiBTZXF1ZW5jZVxuICovXG5mdW5jdGlvbiBTZXF1ZW5jZSgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2VxdWVuY2UpKSB7XG4gICAgICAgIHRocm93IENvbnN0cnVjdG9yRXJyb3I7XG4gICAgfVxuICAgIHRoaXMuYXNzZW1ibGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3ViUGFyc2VycyA9IFtdO1xufVxuU2VxdWVuY2UucHJvdG90eXBlID0gbmV3IENvbGxlY3Rpb25QYXJzZXIoKTtcblNlcXVlbmNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNlcXVlbmNlO1xuXG5TZXF1ZW5jZS5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAoYXNzZW1ibGllcykge1xuXG4gICAgdmFyIHN0YXJ0ZWQgPSBmYWxzZSxcbiAgICAgICAgcHJldmlvdXNSZXN1bHQgPSBhc3NlbWJsaWVzLFxuICAgICAgICByZXN1bHQgPSBhc3NlbWJsaWVzLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgc3ViUGFyc2VyO1xuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5zdWJQYXJzZXJzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuXG4gICAgICAgIHN1YlBhcnNlciA9IHRoaXMuc3ViUGFyc2Vyc1tpbmRleF07XG5cbiAgICAgICAgcmVzdWx0ID0gc3ViUGFyc2VyLm1hdGNoQW5kQXNzZW1ibGUocmVzdWx0KTtcbiAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGVybWluZVRva2VuRXJyb3IocHJldmlvdXNSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBwcmV2aW91c1Jlc3VsdCA9IHJlc3VsdDtcblxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblNlcXVlbmNlLnByb3RvdHlwZS5kZXRlcm1pbmVUb2tlbkVycm9yID0gZnVuY3Rpb24gKHByZXZpb3VzUmVzdWx0KSB7XG5cbiAgICB2YXIgYmVzdCA9IHRoaXMuZmluZEJlc3RBc3NlbWJseShwcmV2aW91c1Jlc3VsdCksXG4gICAgICAgIHRva2VuO1xuXG4gICAgaWYgKGJlc3QuY3VycmVudCgpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgJ1Rva2VuIGV4cGVjdGVkJztcbiAgICB9XG5cbiAgICB0b2tlbiA9IGJlc3QuY3VycmVudCgpO1xuICAgIHRocm93ICdVbmV4cGVjdGVkIHRva2VuIFxcJycgKyB0b2tlbi52YWx1ZSArICdcXCcgb24gbGluZSAnICsgdG9rZW4ubGluZSArICcsIGNvbHVtbiAnICsgdG9rZW4uY29sdW1uO1xuXG59O1xuXG4vKlxuICogQWx0ZXJuYXRpb25cbiAqL1xuZnVuY3Rpb24gQWx0ZXJuYXRpb24oKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFsdGVybmF0aW9uKSkge1xuICAgICAgICB0aHJvdyBDb25zdHJ1Y3RvckVycm9yO1xuICAgIH1cbiAgICB0aGlzLmFzc2VtYmxlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnN1YlBhcnNlcnMgPSBbXTtcbn1cbkFsdGVybmF0aW9uLnByb3RvdHlwZSA9IG5ldyBDb2xsZWN0aW9uUGFyc2VyKCk7XG5BbHRlcm5hdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBbHRlcm5hdGlvbjtcblxuQWx0ZXJuYXRpb24ucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKGFzc2VtYmxpZXMpIHtcblxuICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgZXJyb3IsXG4gICAgICAgIHN1YlBhcnNlcixcbiAgICAgICAgYWx0ZXJuYXRpb25SZXN1bHQsXG4gICAgICAgIGluZGV4O1xuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5zdWJQYXJzZXJzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICBzdWJQYXJzZXIgPSB0aGlzLnN1YlBhcnNlcnNbaW5kZXhdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYWx0ZXJuYXRpb25SZXN1bHQgPSBzdWJQYXJzZXIubWF0Y2hBbmRBc3NlbWJsZShhc3NlbWJsaWVzKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoYWx0ZXJuYXRpb25SZXN1bHQpO1xuICAgICAgICB9IGNhdGNoICh0b2tlbkVycm9yKSB7XG4gICAgICAgICAgICBlcnJvciA9IHRva2VuRXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA8PSAwICYmIGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcblxufTtcblxuLypcbiAqIFRlcm1pbmFsXG4gKi9cbmZ1bmN0aW9uIFRlcm1pbmFsKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUZXJtaW5hbCkpIHtcbiAgICAgICAgdGhyb3cgQ29uc3RydWN0b3JFcnJvcjtcbiAgICB9XG4gICAgdGhpcy5hc3NlbWJsZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kaXNjYXJkID0gZmFsc2U7XG59XG5UZXJtaW5hbC5wcm90b3R5cGUgPSBuZXcgUGFyc2VyKCk7XG5UZXJtaW5hbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXJtaW5hbDtcblxuXG5UZXJtaW5hbC5wcm90b3R5cGUucXVhbGlmaWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuVGVybWluYWwucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKGFzc2VtYmxpZXMpIHtcblxuICAgIHZhciByZXN1bHQgPSBbXSwgaW5kZXgsIGFzc2VtYmx5LCBhc3NlbWJseVJlc3VsdDtcblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGFzc2VtYmxpZXMubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgIGFzc2VtYmx5ID0gYXNzZW1ibGllc1tpbmRleF07XG4gICAgICAgIGFzc2VtYmx5UmVzdWx0ID0gdGhpcy5tYXRjaEFzc2VtYmx5KGFzc2VtYmx5KTtcbiAgICAgICAgaWYgKGFzc2VtYmx5UmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFzc2VtYmx5UmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG5cbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5tYXRjaEFzc2VtYmx5ID0gZnVuY3Rpb24gKGFzc2VtYmx5KSB7XG5cbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICB0b2tlbjtcblxuICAgIGlmIChhc3NlbWJseS5pc0RvbmUoKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnF1YWxpZmllcyhhc3NlbWJseS5jdXJyZW50KCkpKSB7XG5cbiAgICAgICAgcmVzdWx0ID0gYXNzZW1ibHkuY2xvbmUoKTtcblxuICAgICAgICB0b2tlbiA9IHJlc3VsdC5uZXh0KCk7XG4gICAgICAgIGlmICghdGhpcy5kaXNjYXJkKSB7XG4gICAgICAgICAgICByZXN1bHQuc3RhY2sucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuXG59O1xuXG4vKlxuICogIE51bWJlclxuICovXG5mdW5jdGlvbiBOdW1iZXIoKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE51bWJlcikpIHtcbiAgICAgICAgdGhyb3cgQ29uc3RydWN0b3JFcnJvcjtcbiAgICB9XG4gICAgdGhpcy5hc3NlbWJsZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kaXNjYXJkID0gZmFsc2U7XG59XG5OdW1iZXIucHJvdG90eXBlID0gbmV3IFRlcm1pbmFsKCk7XG5cbk51bWJlci5wcm90b3R5cGUucXVhbGlmaWVzID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgcmV0dXJuIHRva2VuLm5hbWUgPT09ICdOVU1CRVInICYmICFpc05hTih0b2tlbi52YWx1ZSk7XG59O1xuXG4vKlxuICogTGl0ZXJhbFxuICovXG5mdW5jdGlvbiBMaXRlcmFsKGxpdGVyYWxWYWx1ZSwgY2FzZVNlbnNpdGl2ZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBMaXRlcmFsKSkge1xuICAgICAgICB0aHJvdyBDb25zdHJ1Y3RvckVycm9yO1xuICAgIH1cbiAgICB0aGlzLmFzc2VtYmxlciA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPSBjYXNlU2Vuc2l0aXZlO1xuICAgIHRoaXMubGl0ZXJhbFZhbHVlID0gbGl0ZXJhbFZhbHVlO1xuICAgIHRoaXMuZGlzY2FyZCA9IGZhbHNlO1xuICAgIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgICB0aGlzLmxpdGVyYWxWYWx1ZSA9IHRoaXMubGl0ZXJhbFZhbHVlLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG59XG5MaXRlcmFsLnByb3RvdHlwZSA9IG5ldyBUZXJtaW5hbCgpO1xuTGl0ZXJhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaXRlcmFsO1xuXG5MaXRlcmFsLnByb3RvdHlwZS5xdWFsaWZpZXMgPSBmdW5jdGlvbiAodG9rZW4pIHtcblxuICAgIHZhciB2YWx1ZSA9IHRva2VuLnZhbHVlO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIXRoaXMuY2FzZVNlbnNpdGl2ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubGl0ZXJhbFZhbHVlID09PSB2YWx1ZTtcblxufTtcblxuLypcbiAqIFdvcmRcbiAqL1xuZnVuY3Rpb24gV29yZCgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV29yZCkpIHtcbiAgICAgICAgdGhyb3cgQ29uc3RydWN0b3JFcnJvcjtcbiAgICB9XG4gICAgdGhpcy5hc3NlbWJsZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kaXNjYXJkID0gZmFsc2U7XG59XG5Xb3JkLnByb3RvdHlwZSA9IG5ldyBUZXJtaW5hbCgpO1xuV29yZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXb3JkO1xuV29yZC5wcm90b3R5cGUucXVhbGlmaWVzID0gZnVuY3Rpb24gKHRva2VuKSB7XG5cbiAgICBpZiAodG9rZW4ubmFtZSA9PT0gJ1dPUkQnKSB7XG4gICAgICAgIHJldHVybiBpc05hTihwYXJzZUludCh0b2tlbi52YWx1ZSwgMTApKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG5cbn07XG5cbi8qXG4gKiBTdHJpbmdcbiAqL1xuZnVuY3Rpb24gU3RyaW5nKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XG4gICAgICAgIHRocm93IENvbnN0cnVjdG9yRXJyb3I7XG4gICAgfVxuICAgIHRoaXMuYXNzZW1ibGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZGlzY2FyZCA9IGZhbHNlO1xufVxuU3RyaW5nLnByb3RvdHlwZSA9IG5ldyBUZXJtaW5hbCgpO1xuU3RyaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN0cmluZztcblN0cmluZy5wcm90b3R5cGUucXVhbGlmaWVzID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgcmV0dXJuIHRva2VuLm5hbWUgPT09ICdTVFJJTkcnO1xufTtcblxuLypcbiAqIE5ld0xpbmVcbiAqL1xuZnVuY3Rpb24gTmV3TGluZSgpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTmV3TGluZSkpIHtcbiAgICAgICAgdGhyb3cgQ29uc3RydWN0b3JFcnJvcjtcbiAgICB9XG4gICAgdGhpcy5hc3NlbWJsZXIgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kaXNjYXJkID0gZmFsc2U7XG59XG5OZXdMaW5lLnByb3RvdHlwZSA9IG5ldyBUZXJtaW5hbCgpO1xuTmV3TGluZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOZXdMaW5lO1xuTmV3TGluZS5wcm90b3R5cGUucXVhbGlmaWVzID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgcmV0dXJuIHRva2VuLm5hbWUgPT09ICdORVdMSU5FJztcbn07XG5cbmV4cG9ydHMuQWx0ZXJuYXRpb24gPSBBbHRlcm5hdGlvbjtcbmV4cG9ydHMuQXNzZW1ibHkgPSBBc3NlbWJseTtcbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyO1xuZXhwb3J0cy5SZXBldGl0aW9uID0gUmVwZXRpdGlvbjtcbmV4cG9ydHMuQ29sbGVjdGlvblBhcnNlciA9IENvbGxlY3Rpb25QYXJzZXI7XG5leHBvcnRzLlNlcXVlbmNlID0gU2VxdWVuY2U7XG5leHBvcnRzLkVtcHR5ID0gRW1wdHk7XG5leHBvcnRzLlRlcm1pbmFsID0gVGVybWluYWw7XG5leHBvcnRzLkxpdGVyYWwgPSBMaXRlcmFsO1xuZXhwb3J0cy5OZXdMaW5lID0gTmV3TGluZTtcbmV4cG9ydHMuTnVtYmVyID0gTnVtYmVyO1xuZXhwb3J0cy5TdHJpbmcgPSBTdHJpbmc7XG5leHBvcnRzLldvcmQgPSBXb3JkO1xuIiwiLyoqXG4gKiBKWlQgVGhpbmdzXG4gKiBDb3B5cmlnaHQgwqkgMjAxNCBPcmFuZ2VsaW5lIEludGVyYWN0aXZlLCBJbmMuXG4gKiBAYXV0aG9yIE1hcmsgTWNJbnR5cmVcbiAqL1xuXG4vKmpzbGludCBub2RlOiB0cnVlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvaW50ID0gcmVxdWlyZSgnLi9iYXNpYycpLlBvaW50LFxuICAgIENvbG9ycyA9IHJlcXVpcmUoJy4vZ3JhcGhpY3MnKS5Db2xvcnMsXG4gICAgQ3ljbGluZ0NvbG9yID0gcmVxdWlyZSgnLi9ncmFwaGljcycpLkN5Y2xpbmdDb2xvcixcbiAgICBkZXNlcmlhbGl6ZUZvcmVncm91bmQgPSByZXF1aXJlKCcuL2dyYXBoaWNzJykuZGVzZXJpYWxpemVGb3JlZ3JvdW5kLFxuICAgIGRlc2VyaWFsaXplQmFja2dyb3VuZCA9IHJlcXVpcmUoJy4vZ3JhcGhpY3MnKS5kZXNlcmlhbGl6ZUJhY2tncm91bmQsXG4gICAgc2VyaWFsaXplQ29sb3IgPSByZXF1aXJlKCcuL2dyYXBoaWNzJykuc2VyaWFsaXplLFxuICAgIHV0aWxpdGllcyA9IHJlcXVpcmUoJy4vYmFzaWMnKS51dGlsaXRpZXMsXG4gICAgRGlyZWN0aW9uID0gcmVxdWlyZSgnLi9iYXNpYycpLkRpcmVjdGlvbixcbiAgICBHYW1lU3RhdGUgPSByZXF1aXJlKCcuL2dhbWUtc3RhdGUnKS5HYW1lU3RhdGUsXG4gICAgSnp0U2NyaXB0Q29udGV4dCA9IHJlcXVpcmUoJy4vanp0LXNjcmlwdC1jb250ZXh0JykuSnp0U2NyaXB0Q29udGV4dCxcbiAgICBEZWxheWVkRXZlbnRTY2hlZHVsZXIgPSByZXF1aXJlKCcuL2Jhc2ljJykuRGVsYXllZEV2ZW50U2NoZWR1bGVyLFxuICAgIGkxOG4gPSByZXF1aXJlKCcuL2kxOG4nKSxcbiAgICBUaGluZ0ZhY3RvcnkgPSB7fSxcbiAgICBNT1ZFX0FDVElPTiA9IDAsXG4gICAgU0hPT1RfQUNUSU9OID0gMSxcbiAgICBUT1JDSF9UVEwgPSA2MDAwMCxcbiAgICBNQVhfVE9SQ0hfU1RSRU5HVEggPSA0O1xuXG4vKipcbiAqIERlZmluZXMgYSB0aGluZyBieSBhZGRpbmcgYSBwcm9wZXJ0eSB3aXRoIGl0cyBuYW1lZCBjb25zdHJ1Y3Rpb24gZnVuY3Rpb24uIEFkZGl0aW9uYWxseVxuICogYWRkcyBhICd0eXBlJyBwcm9wZXJ0eSB0byB0aGUgZnVuY3Rpb24gc28gaXQgY2FuIGJlIHNlcmlhbGl6ZWQgZXZlbiBhZnRlciBtaW5pZmljYXRpb24uXG4gKi9cbmV4cG9ydHMudGhpbmdzID0ge307XG5mdW5jdGlvbiBkZWZpbmVUaGluZyhuYW1lLCB0aGluZ0Z1bmN0aW9uKSB7XG4gICAgZXhwb3J0cy50aGluZ3NbbmFtZV0gPSB0aGluZ0Z1bmN0aW9uO1xuICAgIHRoaW5nRnVuY3Rpb24udHlwZSA9IG5hbWU7XG59XG5cbi8qXG4gKiBUaGluZyByZXByZXNlbnRzIGEgc2luZ2xlICd0aGluZycgdGhhdCBjYW4gYmUgYXNzb2NpYXRlZCB3aXRoIGEgQm9hcmQuIFRoaXMgY2FuXG4gKiByYW5nZSBmcm9tIHBsYXllcnMsIHRvIHdhbGxzLCB0byBTY3JpcHRhYmxlcy4gRWFjaCBUaGluZyBoYXMgYSBsb2NhdGlvbixcbiAqIHNwcml0ZSBpbmRleCwgYW5kIGZvcmVncm91bmQgYW5kIGJhY2tncm91bmQgY29sb3IuIEVhY2ggVGhpbmcgc2hvdWxkIGFsc29cbiAqIGJlIGFibGUgdG8gaGFuZGxlIGl0cyBvd24gc2VyaWFsaXphdGlvbiBhbmQgZGVzZXJpYWxpemF0aW9uLiBUaGluZ3MgbWF5IGFsc29cbiAqIHJlY2VpdmUgbWVzc2FnZXMgYW5kIHRha2UgYWN0aW9ucyBhY2NvcmRpbmdseSwgZWl0aGVyIGFsdGVyaW5nIGl0cyBvd24gc3RhdGVcbiAqIG9yIG1ha2luZyByZXF1ZXN0cyB0byBpdHMgb3duZXIgQm9hcmQuXG4gKlxuICogQHBhcmFtIGJvYXJkIEEgQm9hcmQgaW5zdGFuY2UgdG8gXCJvd25cIiB0aGlzIFRoaW5nLlxuICovXG5mdW5jdGlvbiBUaGluZyhib2FyZCkge1xuICAgIHRoaXMuc3ByaXRlSW5kZXggPSA2MztcbiAgICB0aGlzLmJvYXJkID0gYm9hcmQ7XG4gICAgdGhpcy5wb2ludCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuWWVsbG93O1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy50eXBlID0gdGhpcy5jb25zdHJ1Y3Rvci50eXBlO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhpcyBUaGluZyB0byBhbiBvYmplY3QgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQHJldHVybiBBIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiB0aGlzIFRoaW5nLlxuICovXG5UaGluZy5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICByZXN1bHQudHlwZSA9IHRoaXMuY29uc3RydWN0b3IudHlwZTtcbiAgICByZXN1bHQuY29sb3IgPSBzZXJpYWxpemVDb2xvcih0aGlzLmJhY2tncm91bmQsIHRoaXMuZm9yZWdyb3VuZCk7XG4gICAgaWYgKHRoaXMudW5kZXIpIHtcbiAgICAgICAgcmVzdWx0LnVuZGVyID0gdGhpcy51bmRlci5zZXJpYWxpemUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRGVzZXJpYWxpemVzIGEgZ2l2ZW4gZGF0YSBvYmplY3QgYW5kIHVwZGF0ZSdzIHRoaXMgVGhpbmcncyBzdGF0ZSB0b1xuICogdGhhdCBkYXRhLlxuICpcbiAqIEBwYXJhbSBkYXRhIEFuIG9iamVjdCB0byBiZSBkZXNlcmlhbGl6ZWQgaW50byB0aGlzIFRoaW5nLlxuICovXG5UaGluZy5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgaWYgKGRhdGEuY29sb3IpIHtcbiAgICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gZGVzZXJpYWxpemVGb3JlZ3JvdW5kKGRhdGEuY29sb3IpO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBkZXNlcmlhbGl6ZUJhY2tncm91bmQoZGF0YS5jb2xvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLmZvcmVncm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yZWdyb3VuZCA9IENvbG9ycy5ZZWxsb3c7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnVuZGVyKSB7XG4gICAgICAgIHRoaXMudW5kZXIgPSBUaGluZ0ZhY3RvcnkuZGVzZXJpYWxpemUoZGF0YS51bmRlciwgdGhpcy5ib2FyZCk7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIFBsYXlzIGEgZ2l2ZW4gYXVkaW8gbm90YXRpb24uIFRoaXMgZnVuY3Rpb24gaXMgYSBjb252ZW5pZW50IHNob3J0aGFuZFxuICogZm9yIGEgZnVsbCBjYWxsIGNoYWluLlxuICpcbiAqIEBwYXJhbSBub3RhdGlvbiBBbiBhdWRpbyBub3RhdGlvbiB0byBwbGF5LlxuICogQHBhcmFtIHVuaW50ZXJydXB0YWJsZSBXaGV0aGVyIG9yIG5vdCB0aGlzIG5vdGF0aW9uIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSBhbm90aGVyLlxuICogQHBhcmFtIGRlZmVyIElmIHNldCwgd2UgZG8gbm90IGV2ZW4gc2NoZWR1bGUgb3VyIG5vdGF0aW9uIGlmIGFub3RoZXIgaXMgYWxyZWFkeSBwbGF5aW5nLlxuICovXG5UaGluZy5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uIChub3RhdGlvbiwgdW5pbnRlcnJ1cHRhYmxlLCBkZWZlcikge1xuXG4gICAgLypcbiAgICAgKiBEZWZlcnJpbmcgYXVkaW8gbWVhbnMgd2UgZG9uJ3QgZXZlbiBhdHRlbXB0IHRvIHBsYXkgc29tZXRoaW5nIGlmIGFub3RoZXJcbiAgICAgKiBpcyBhbHJlYWR5IHBsYXlpbmcuIFRoaXMgbm90IG9ubHkgc2F2ZXMgd2FzdGVkIHRpbWUgc2NoZWR1bGluZyBhdWRpb1xuICAgICAqIHRoYXQgd2lsbCBiZSBjYW5jZWxsZWQgYnkgYSBmdXR1cmUgc291bmQsIGJ1dCBhbHNvIGFsbG93cyBwcmV2aW91c2x5XG4gICAgICogdHJpZ2dlcmVkIHNvdW5kcyB0byB0YWtlIHByaW9yaXR5IGV2ZW4gaWYgdGhhdCBzb3VuZCB3YXNuJ3QgZGVjbGFyZWRcbiAgICAgKiB1bmludGVycnVwdGFibGUuXG4gICAgICovXG4gICAgaWYgKCFkZWZlciB8fCAhdGhpcy5ib2FyZC5nYW1lLnJlc291cmNlcy5hdWRpby5pc1BsYXlpbmcoKSkge1xuICAgICAgICB0aGlzLmJvYXJkLmdhbWUucmVzb3VyY2VzLmF1ZGlvLnBsYXkobm90YXRpb24sIHVuaW50ZXJydXB0YWJsZSk7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIEFkanVzdHMgYSBnYW1lIGNvdW50ZXIgYnkgYSBwcm92aWRlZCB2YWx1ZSBvZmZzZXQuIFRoaXMgb2Zmc2V0IG1heSBiZVxuICogcG9zaXRpdmUgKHRvIGluY3JlYXNlIHRoZSBjb3VudGVyKSwgb3IgbmVnYXRpdmUgKHRvIGRlY3JlYXNlIGl0KS5cbiAqXG4gKiBAcGFyYW0gY291bnRlciBBIG5hbWUgb2YgYSBjb3VudGVyXG4gKiBAcGFyYW0gdmFsdWUgQSB2YWx1ZSBieSB3aGljaCB0byBhZGp1c3QgYSBjb3VudGVyXG4gKi9cblRoaW5nLnByb3RvdHlwZS5hZGp1c3RDb3VudGVyID0gZnVuY3Rpb24gKGNvdW50ZXIsIHZhbHVlKSB7XG4gICAgdGhpcy5ib2FyZC5nYW1lLmFkanVzdENvdW50ZXIoY291bnRlciwgdmFsdWUpO1xufTtcblxuVGhpbmcucHJvdG90eXBlLnNldENvdW50ZXJWYWx1ZSA9IGZ1bmN0aW9uIChjb3VudGVyLCB2YWx1ZSkge1xuICAgIHRoaXMuYm9hcmQuZ2FtZS5zZXRDb3VudGVyVmFsdWUoY291bnRlciwgdmFsdWUpO1xufTtcblxuVGhpbmcucHJvdG90eXBlLmdldENvdW50ZXJWYWx1ZSA9IGZ1bmN0aW9uIChjb3VudGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuYm9hcmQuZ2FtZS5nZXRDb3VudGVyVmFsdWUoY291bnRlcik7XG59O1xuXG4vKipcbiAqIERlbGl2ZXJzIGEgcHJvdmlkZWQgbWVzc2FnZSB0byB0aGlzIFRoaW5nLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlTmFtZSBhIG5hbWUgb2YgYSBtZXNzYWdlIHRvIGRlbGl2ZXIuXG4gKi9cblRoaW5nLnByb3RvdHlwZS5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBSZWNlaXZlcyBhIHJlcXVlc3QgdG8gYmUgcHVzaGVkIGluIGEgZ2l2ZW4gZGlyZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBkaXJlY3Rpb24gQSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhpcyBUaGluZyBpcyByZXF1ZXN0ZWQgdG8gbW92ZS5cbiAqIEBwYXJhbSBwdXNoZXIgQSBUaGluZyB0aGF0IGlzIHJlcXVlc3RpbmcgdGhlIHB1c2guXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIHB1c2ggcmVzdWx0ZWQgaW4gYSB0ZWxlcG9ydGF0aW9uLCB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICovXG5UaGluZy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoaXMgVGhpbmcgZGVjbGFyZXMgaXRzZWxmIHRvIGJlIHN1cnJlbmRlcmFibGUgdG9cbiAqIGEgZ2l2ZW4gc2VuZGVyLlxuICpcbiAqIEEgVGhpbmcgdGhhdCBpcyBzdXJyZW5kZXJhYmxlIHdpbGwgYWxsb3cgYW5vdGhlciBUaGluZyB0byBvY2N1cHkgaXRzXG4gKiBzcGFjZSBvbiBhIGJvYXJkIGFuZCB3aWxsIGFncmVlIHRvIGJlICd1bmRlcicgdGhhdCBUaGluZy5cbiAqXG4gKiBAcGFyYW0gc2VuZGVyIEEgVGhpbmcgcmVxdWVzdGluZyBhIHN1cnJlbmRlclxuICogQHJldHVybiB0cnVlIGlmIHRoaXMgVGhpbmcgYWdyZWVzIHRvIHN1cnJlbmRlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5UaGluZy5wcm90b3R5cGUuaXNTdXJyZW5kZXJhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHdoZXRoZXIgb3Igbm90IHRoaXMgVGhpbmcgaW5zdGFuY2UgaXMgYmxvY2tlZCBpbiBhIGdpdmVuIGRpcmVjdGlvbi5cbiAqIEEgVGhpbmcgaXMgZGVmaW5lZCBhcyBibG9ja2VkIGlmIGEgdGlsZSBhcHBlYXJzIGF0IHRoYXQgZGlyZWN0aW9uIHRoYXQgaXMgb2NjdXBpZWRcbiAqIGFuZCBpcyBub3Qgd2lsbGluZyB0byBzdXJyZW5kZXIgaXRzIHBvc2l0aW9uIHRvIGFub3RoZXIgdGlsZS5cbiAqXG4gKiBAcGFyYW0gZGlyZWN0aW9uIEEgZGlyZWN0aW9uIGluIHdoaWNoIHRvIHRlc3QgaWYgdGhpcyBUaGluZyBpcyBibG9ja2VkXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhpcyBUaGluZyBpcyBibG9ja2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblRoaW5nLnByb3RvdHlwZS5pc0Jsb2NrZWQgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG5cbiAgICB2YXIgbmV3UG9pbnQgPSB0aGlzLnBvaW50LmFkZChkaXJlY3Rpb24pLFxuICAgICAgICBvYnN0YWNsZTtcblxuICAgIGlmICh0aGlzLmJvYXJkLmlzRnJlZShuZXdQb2ludCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmJvYXJkLmlzT3V0c2lkZShuZXdQb2ludCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgb2JzdGFjbGUgPSB0aGlzLmJvYXJkLmdldFRpbGUobmV3UG9pbnQpO1xuICAgIGlmIChvYnN0YWNsZSkge1xuICAgICAgICByZXR1cm4gIW9ic3RhY2xlLmlzU3VycmVuZGVyYWJsZSh0aGlzKTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHdoZXRoZXIgb3Igbm90IHRoaXMgVGhpbmcgaGFzIGEgbGluZSBvZiBzaWdodCB0byBhIFBsYXllciB3aXRoaW4gYSBwcm92aWRlZFxuICogZGlzdGFuY2UuIEEgbGluZSBvZiBzaWdodCBtYXkgYmUgYnJva2VuIGJ5IGFueSBUaGluZywgaW4gd2hpY2ggY2FzZSB0aGlzIGZ1bmN0aW9uXG4gKiByZXR1cm5zIGZhbHNlLlxuICpcbiAqIEBwYXJhbSBkaXN0YW5jZSBhIG51bWJlciBvZiB0aWxlcyBkZXRlcm1pbmluZyB0aGUgdmlzaWJpbGl0eSBkaXN0YW5jZVxuICogQHJldHVybiB0cnVlIGlmIHRoZXJlIGlzIGFuIHVuaW50ZXJydXB0ZWQgc3RyYWlnaHQgbGluZSBiZXR3ZWVuIHRoaXMgdGhpbmcgYW5kIGEgcGxheWVyLlxuICovXG5UaGluZy5wcm90b3R5cGUuaXNQbGF5ZXJWaXNpYmxlID0gZnVuY3Rpb24gKGRpc3RhbmNlKSB7XG5cbiAgICB2YXIgbGluZSA9IHV0aWxpdGllcy5nZW5lcmF0ZUxpbmVEYXRhKHRoaXMucG9pbnQsIHRoaXMuYm9hcmQucGxheWVyLnBvaW50KSxcbiAgICAgICAgbWUgPSB0aGlzLFxuICAgICAgICBjdXJyZW50UG9pbnQgPSB0aGlzLnBvaW50LFxuICAgICAgICByZXN1bHQgPSB0cnVlO1xuXG4gICAgZnVuY3Rpb24gaXNCbG9ja2VkKHBvaW50KSB7XG4gICAgICAgIHZhciB0aWxlID0gbWUuYm9hcmQuZ2V0VGlsZShwb2ludCk7XG4gICAgICAgIHJldHVybiB0aWxlICYmICh0aWxlICE9PSBtZSkgJiYgKHRpbGUudHlwZSAhPT0gJ1BsYXllcicpO1xuICAgIH1cblxuICAgIGlmIChsaW5lLnBvaW50cy5sZW5ndGggPiBkaXN0YW5jZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGluZS5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuXG4gICAgICAgIC8vIElmIHdlJ3JlIGRvaW5nIGEgZGlhZ25vYWwgc3RlcCwgdGVzdCBib3RoIHBhdGhzIHRvIHRoYXQgc3RlcFxuICAgICAgICBpZiAoY3VycmVudFBvaW50LnggIT09IHBvaW50LnggJiYgY3VycmVudFBvaW50LnkgIT09IHBvaW50LnkpIHtcblxuICAgICAgICAgICAgaWYgKGlzQmxvY2tlZChuZXcgUG9pbnQoY3VycmVudFBvaW50LngsIHBvaW50LnkpKSB8fCBpc0Jsb2NrZWQobmV3IFBvaW50KHBvaW50LngsIGN1cnJlbnRQb2ludC55KSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQmxvY2tlZChwb2ludCkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFBvaW50ID0gcG9pbnQ7XG5cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG5cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHdoZXRoZXIgb3Igbm90IHRoaXMgVGhpbmcgaW5zdGFuY2UgaXMgZGlyZWN0bHkgYWRqYWNlbnQgdG8gYSBQbGF5ZXIgVGhpbmcgaW5cbiAqIGEgcHJvdmlkZWQgZGlyZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBkaXJlY3Rpb24gQSBkaXJlY3Rpb24gaW4gd2hpY2ggdG8gdGVzdCBpZiB0aGlzIFRoaW5nIGlzIHBsYXllciBhZGphY2VudFxuICogQHJldHVybiB0cnVlIGlmIGEgUGxheWVyIHRoaW5nIGlzIGRpcmVjdGx5IGFkamFjZW50IGluIGEgZ2l2ZW4gZGlyZWN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblRoaW5nLnByb3RvdHlwZS5pc1BsYXllckFkamFjZW50ID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgIHZhciB0aWxlID0gdGhpcy5ib2FyZC5nZXRUaWxlKHRoaXMucG9pbnQuYWRkKGRpcmVjdGlvbikpO1xuICAgIHJldHVybiB0aWxlICYmIHRpbGUudHlwZSA9PT0gJ1BsYXllcic7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhpcyBUaGluZyBpcyBhbGlnbmVkIHRvIHRoZSBwbGF5ZXJcbiAqIHdpdGggYSBjZXJ0YWluIHNwcmVhZC5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgcGxheWVyIGlzIGFsaWduZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuVGhpbmcucHJvdG90eXBlLmlzUGxheWVyQWxpZ25lZCA9IGZ1bmN0aW9uIChzcHJlYWQsIGRpcmVjdGlvbikge1xuICAgIHJldHVybiB0aGlzLnBvaW50LmFsaWduZWQodGhpcy5ib2FyZC5wbGF5ZXIucG9pbnQsIHNwcmVhZCwgZGlyZWN0aW9uKTtcbn07XG5cbi8qKlxuICogTW92ZXMgdGhpcyBUaGluZyBpbiBhIHByb3ZpZGVkIERpcmVjdGlvbiBhbmQgcmV0dXJucyBpdHMgc3VjY2Vzcy5cbiAqXG4gKiBAcGFyYW0gZGlyZWN0aW9uIEEgRGlyZWN0aW9uIGluIHdoaWNoIHRvIG1vdmUgdGhpcyBUaGluZy5cbiAqIEBwYXJhbSB3ZWFrIElmIHRydWUsIHdlIHdpbGwgbW92ZSB3ZWFrbHkuXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhlIG1vdmUgd2FzIHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuVGhpbmcucHJvdG90eXBlLm1vdmUgPSBmdW5jdGlvbiAoZGlyZWN0aW9uLCB3ZWFrKSB7XG4gICAgcmV0dXJuIHRoaXMuYm9hcmQubW92ZVRpbGUodGhpcy5wb2ludCwgdGhpcy5wb2ludC5hZGQoZGlyZWN0aW9uKSwgd2Vhayk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgdGhpcyBUaGluZyBmcm9tIGl0cyBvd25lciBib2FyZC5cbiAqL1xuVGhpbmcucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJvYXJkLmRlbGV0ZVRpbGUodGhpcy5wb2ludCk7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhIHNwcml0ZSBpbmRleCB0byBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aGlzIFRoaW5nLlxuICpcbiAqIEByZXR1cm4gQSBzcHJpdGUgaW5kZXguXG4gKi9cblRoaW5nLnByb3RvdHlwZS5nZXRTcHJpdGVJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zcHJpdGVJbmRleDtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgVGhpbmcgdGhhdCBpcyBkaXJlY3RseSBhZGphY2VudCB0byB0aGlzIFRoaW5nIGluIGEgZ2l2ZW4gZGlyZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBkaXJlY3Rpb24gQSBkaXJlY3Rpb24gdG8gcmV0cmlldmUgYW5vdGhlciBUaGluZy5cbiAqIEByZXR1cm4gYSBUaGluZywgb3IgdW5kZWZpbmVkIGlmIG5vIHN1Y2ggVGhpbmcgZXhpc3RzLlxuICovXG5UaGluZy5wcm90b3R5cGUuZ2V0QWRqYWNlbnRUaGluZyA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5ib2FyZC5nZXRUaWxlKHRoaXMucG9pbnQuYWRkKGRpcmVjdGlvbikpO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgd2hldGhlciBvciBub3QgdGhpcyBUaGluZyBoYXMgdGhlIHNhbWUgdHlwZSBhbmQgY29sb3IgYXMgcHJvdmlkZWQuXG4gKlxuICogQHBhcmFtIHR5cGUgYSBjYXNlLWluc2Vuc2l0aXZlIHNlcmlhbGl6YWJsZSB0eXBlIG5hbWVcbiAqIEBwYXJhbSBjb2xvciBBbiBvcHRpb25hbCBjb2xvclxuICogQHJldHVybiB0cnVlIGlmIHRoaXMgVGhpbmcgaGFzIGEgbWF0Y2hpbmcgc2VyaWFsaXphYmxlIHR5cGUgYW5kIGNvbG9yIChpZiBwcm92aWRlZClcbiAqL1xuVGhpbmcucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSkge1xuXG4gICAgdmFyIHR5cGUgPSB0ZW1wbGF0ZS50eXBlLnRvVXBwZXJDYXNlKCksXG4gICAgICAgIGNvbG9yID0gdGVtcGxhdGUuY29sb3IgPyBkZXNlcmlhbGl6ZUZvcmVncm91bmQodGVtcGxhdGUuY29sb3IpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IudHlwZS50b1VwcGVyQ2FzZSgpID09PSB0eXBlKSB7XG5cbiAgICAgICAgcmV0dXJuIGNvbG9yID09PSB1bmRlZmluZWQgPyB0cnVlIDogY29sb3IgPT09IHRoaXMuZm9yZWdyb3VuZDtcblxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcblxufTtcblxuLyoqXG4gKiBEaXNwbGF5cyBhIHNob3J0LCBsb2NhbGl6YWJsZSBtZXNzYWdlIGV4YWN0bHkgb25jZS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZUtleSBBIGxvY2FsaXphdGlvbiBrZXkgZm9yIGEgbWVzc2FnZSB0byBkaXNwbGF5LlxuICovXG5UaGluZy5wcm90b3R5cGUub25lVGltZU1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZUtleSkge1xuXG4gICAgdGhpcy5ib2FyZC5nYW1lLm9uZVRpbWVNZXNzYWdlKG1lc3NhZ2VLZXkpO1xuXG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgVGhpbmcgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzIHRoaXMgVGhpbmcuXG4gKiBUaGlzIGNsb25lIGZ1bmN0aW9uIHdvcmtzIGJ5IHNlcmlhbGl6aW5nIHRoZSBjdXJyZW50IFRoaW5nIGFuZCBkZXNlcmlhbGl6aW5nXG4gKiB0aGUgZGF0YSBhcyBhIG5ldyBUaGluZywgYW5kIHNob3VsZCB3b3JrIGZvciBhbnkgc2VyaWFsaXphYmxlIFRoaW5nLlxuICpcbiAqIEByZXR1cm4gQSBjbG9uZSBvZiB0aGlzIFRoaW5nLlxuICovXG5UaGluZy5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNsb25lID0gdGhpcy5zZXJpYWxpemUoKTtcbiAgICByZXR1cm4gVGhpbmdGYWN0b3J5LmRlc2VyaWFsaXplKGNsb25lLCB0aGlzLmJvYXJkKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKlxuICogVXBkYXRlYWJsZSBUaGluZyBpcyBhIFRoaW5nIHRoYXQgY2FuIGJlIHVwZGF0ZWQgZHVyaW5nIGFuIGV4ZWN1dGlvbiBjeWNsZVxuICogb2YgaXRzIG93bmVyIGJvYXJkLiBVcGRhdGVhYmxlVGhpbmdzIG1heSB0YWtlIGRpZmZlcmVudCBhY3Rpb25zIGR1cmluZyB1cGRhdGVzLlxuICpcbiAqIEBwYXJhbSBib2FyZCBBIEJvYXJkIHRvIHdoaWNoIHRoaXMgVXBkYXRlYWJsZVRoaW5nIGJlbG9uZ3MuXG4gKi9cbmZ1bmN0aW9uIFVwZGF0ZWFibGVUaGluZyhib2FyZCkge1xuICAgIFRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMuY3ljbGVDb3VudCA9IDA7XG4gICAgdGhpcy5zcGVlZCA9IDM7XG59XG5VcGRhdGVhYmxlVGhpbmcucHJvdG90eXBlID0gbmV3IFRoaW5nKCk7XG5cbi8qKlxuICogU2VyaWFsaXplcyB0aGlzIFRoaW5nIHRvIGFuIG9iamVjdCBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKiBAcmV0dXJuIEEgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoaXMgVGhpbmcuXG4gKi9cblVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBUaGluZy5wcm90b3R5cGUuc2VyaWFsaXplLmNhbGwodGhpcykgfHwge307XG4gICAgcmVzdWx0LnNwZWVkID0gdGhpcy5zcGVlZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSBnaXZlbiBkYXRhIG9iamVjdCBhbmQgdXBkYXRlJ3MgdGhpcyBUaGluZydzIHN0YXRlIHRvXG4gKiB0aGF0IGRhdGEuXG4gKlxuICogQHBhcmFtIGRhdGEgQW4gb2JqZWN0IHRvIGJlIGRlc2VyaWFsaXplZCBpbnRvIHRoaXMgVGhpbmcuXG4gKi9cblVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIFRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIGlmIChkYXRhLnNwZWVkKSB7XG4gICAgICAgIHRoaXMuc3BlZWQgPSBkYXRhLnNwZWVkO1xuICAgIH1cbiAgICB0aGlzLmN5Y2xlQ291bnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnNwZWVkKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgRGlyZWN0aW9uIHRvd2FyZCB0aGlzIFVwZGF0ZWFibGVUaGluZydzIEJvYXJkJ3MgUGxheWVyLlxuICpcbiAqIEByZXR1cm4gYSBEaXJlY3Rpb24gdG93YXJkIGEgUGxheWVyLlxuICovXG5VcGRhdGVhYmxlVGhpbmcucHJvdG90eXBlLmdldFBsYXllckRpcmVjdGlvbiA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnQuZGlyZWN0aW9uVG8odGhpcy5ib2FyZC5wbGF5ZXIucG9pbnQsIGF4aXMpO1xufTtcblxuVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5nZXRTbWFydERpcmVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ib2FyZC5nZXRTbWFydERpcmVjdGlvbih0aGlzLnBvaW50KTtcbn07XG5cblVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuaW5mbHVlbmNlU21hcnRQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgYSBwb3NpdGlvbiBpbiBhIHByb3ZpZGVkIGRpcmVjdGlvbiBpcyBhdHRhY2thYmxlXG4gKiBieSB0aGlzIFVwZGF0ZWFibGVUaGluZy4gQXR0YWNrYWJsZSBwb3NpdGlvbnMgYXJlIGRlZmluZWQgYXMgZnJlZSBzcG90c1xuICogb3Igc3BvdHMgb2NjdXBpZWQgYnkgYSBwbGF5ZXIuXG4gKlxuICogcmV0dXJuIHRydWUgaWYgYSBwcm92aWRlZCBkaXJlY3Rpb24gaXMgYXR0YWNrYWJsZSwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cblVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuaXNBdHRhY2thYmxlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgIHJldHVybiAhdGhpcy5pc0Jsb2NrZWQoZGlyZWN0aW9uKSB8fCB0aGlzLmlzUGxheWVyQWRqYWNlbnQoZGlyZWN0aW9uKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGFuIEFycmF5IG9mIERpcmVjdGlvbnMgaW4gd2hpY2ggdGhpcyBVcGRhdGVhYmxlVGhpbmcgY2FuIGF0dGFjay5cbiAqIEFuIGF0dGFja2FibGUgZGlyZWN0aW9uIGlzIGRlZmluZWQgYXMgYW55IGRpcmVjdGlvbiB0aGF0IGlzIGZyZWUsIG9yIGlzXG4gKiBvY2N1cGllZCBieSB0aGUgcGxheWVyLlxuICpcbiAqIEByZXR1cm4gQW4gYXJyYXkgb2YgRGlyZWN0aW9uc1xuICovXG5VcGRhdGVhYmxlVGhpbmcucHJvdG90eXBlLmdldEF0dGFja2FibGVEaXJlY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICBpbnN0YW5jZSA9IHRoaXM7XG4gICAgRGlyZWN0aW9uLmVhY2goZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICBpZiAoaW5zdGFuY2UuaXNBdHRhY2thYmxlKGRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuXG59O1xuXG4vKipcbiAqIFJldHJpZXZzIGFuIEFycmF5IG9mIERpcmVjdGlvbnMgaW4gd2hpY2ggdGhpcyBVcGRhdGVhYmxlVGhpbmcgaXNcbiAqIGZyZWUgdG8gbW92ZSBvbiBpdHMgb3duZXIgQm9hcmQuXG4gKlxuICogQHJldHVybiBBbiBhcnJheSBvZiBEaXJlY3Rpb25zLlxuICovXG5VcGRhdGVhYmxlVGhpbmcucHJvdG90eXBlLmdldEZyZWVEaXJlY3Rpb25zID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgICBpbnN0YW5jZSA9IHRoaXM7XG5cbiAgICBEaXJlY3Rpb24uZWFjaChmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2UuaXNCbG9ja2VkKGRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG5cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGFuIEFycmF5IG9mIERpcmVjdGlvbnMgaW4gd2hpY2ggdGhpcyBVcGRhdGVhYmxlVGhpbmcgaXMgbm90IGZyZWVcbiAqIHRvIG1vdmUgb24gaXRzIG93bmVyIEJvYXJkLlxuICpcbiAqIEByZXR1cm4gQW4gYXJyYXkgb2YgRGlyZWN0aW9ucy5cbiAqL1xuVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5nZXRCbG9ja2VkRGlyZWN0aW9ucyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciByZXN1bHQgPSBbXSxcbiAgICAgICAgaW5zdGFuY2UgPSB0aGlzO1xuXG4gICAgRGlyZWN0aW9uLmVhY2goZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgICAgICBpZiAoaW5zdGFuY2UuaXNCbG9ja2VkKGRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG5cbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGlzIFVwZGF0ZWFibGVUaGluZyBmb3IgYSBzaW5nbGUgZXhlY3V0aW9uIGN5Y2xlLlxuICovXG5VcGRhdGVhYmxlVGhpbmcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICh0aGlzLmJvYXJkLmdhbWUuc3RhdGUgPT09IEdhbWVTdGF0ZS5HYW1lT3Zlcikge1xuICAgICAgICB0aGlzLmRvVGljaygpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jeWNsZUNvdW50ICs9IDE7XG5cbiAgICBpZiAodGhpcy5jeWNsZUNvdW50ID49IHRoaXMuc3BlZWQgKiB0aGlzLmJvYXJkLmdhbWUuQ1lDTEVfUkFURSkge1xuICAgICAgICB0aGlzLmN5Y2xlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmRvVGljaygpO1xuICAgIH1cblxufTtcblxuVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS51cGRhdGVPblJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoaXMgVXBkYXRlYWJsZVRoaW5nIG9uIGl0cyB0aWNrIHVwZGF0ZSBjeWNsZS5cbiAqL1xuVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5kb1RpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKlxuICogU2NyaXB0YWJsZSBUaGluZyBpcyBhbiBVcGRhdGVhYmxlVGhpbmcgY2FwYWJsZSBvZiBleGVjdXRpbmcgYSBTY3JpcHQgaW5zdGFuY2VcbiAqIGZvciBpdHMgdXBkYXRlIGN5Y2xlcy4gVGhpcyBTY3JpcHQgd2lsbCBiZSB1cGRhdGVkIGluIGEgU2NyaXB0Q29udGV4dCB1bmlxdWVcbiAqIHRvIHRoaXMgU2NyaXB0YWJsZS5cbiAqXG4gKiBAcGFyYW0gYm9hcmQgQW4gb3duZXIgYm9hcmQgZm9yIHRoaXMgU2NyaXB0YWJsZS5cbiAqL1xuZnVuY3Rpb24gU2NyaXB0YWJsZShib2FyZCkge1xuICAgIFVwZGF0ZWFibGVUaGluZy5jYWxsKHRoaXMsIGJvYXJkKTtcbiAgICB0aGlzLm5hbWUgPSAnVW5rbm93blNjcmlwdGFibGUnO1xuICAgIHRoaXMuc2NyaXB0Q29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IFtdO1xuICAgIHRoaXMud2Fsa0RpcmVjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMub3JpZW50YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IDE7XG4gICAgdGhpcy50b3JjaFJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnB1c2hhYmxlID0gZmFsc2U7XG59XG5TY3JpcHRhYmxlLnByb3RvdHlwZSA9IG5ldyBVcGRhdGVhYmxlVGhpbmcoKTtcblNjcmlwdGFibGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2NyaXB0YWJsZTtcblxuLyoqXG4gKiBTZXJpYWxpemVzIHRoaXMgVGhpbmcgdG8gYW4gb2JqZWN0IGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEByZXR1cm4gQSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhpcyBUaGluZy5cbiAqL1xuU2NyaXB0YWJsZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBVcGRhdGVhYmxlVGhpbmcucHJvdG90eXBlLnNlcmlhbGl6ZS5jYWxsKHRoaXMpIHx8IHt9O1xuXG4gICAgcmVzdWx0Lm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgcmVzdWx0LnNwcml0ZUluZGV4ID0gdGhpcy5zcHJpdGVJbmRleDtcbiAgICByZXN1bHQuc2NyaXB0ID0gdGhpcy5zY3JpcHROYW1lO1xuXG4gICAgdXRpbGl0aWVzLnN0b3JlT3B0aW9uKHJlc3VsdCwgJ3B1c2hhYmxlJywgdGhpcy5wdXNoYWJsZSwgZmFsc2UpO1xuXG4gICAgaWYgKHRoaXMudG9yY2hSYWRpdXMgPiAwKSB7XG4gICAgICAgIHJlc3VsdC50b3JjaFJhZGl1cyA9IHRoaXMudG9yY2hSYWRpdXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2NyaXB0Q29udGV4dCkge1xuXG4gICAgICAgIGlmICghKHRoaXMuc2NyaXB0Q29udGV4dC5pbkRlZmF1bHRTdGF0ZSgpKSkge1xuICAgICAgICAgICAgcmVzdWx0LnNjcmlwdENvbnRleHQgPSB0aGlzLnNjcmlwdENvbnRleHQuc2VyaWFsaXplKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZVF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5tZXNzYWdlUXVldWUgPSB0aGlzLm1lc3NhZ2VRdWV1ZS5zbGljZSgwKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsaXRpZXMuc3RvcmVPcHRpb24ocmVzdWx0LCAnd2Fsa0RpcmVjdGlvbicsIERpcmVjdGlvbi5nZXROYW1lKHRoaXMud2Fsa0RpcmVjdGlvbikpO1xuICAgICAgICB1dGlsaXRpZXMuc3RvcmVPcHRpb24ocmVzdWx0LCAnbG9ja2VkJywgdGhpcy5sb2NrZWQsIGZhbHNlKTtcbiAgICAgICAgdXRpbGl0aWVzLnN0b3JlT3B0aW9uKHJlc3VsdCwgJ29yaWVudGF0aW9uJywgRGlyZWN0aW9uLmdldE5hbWUodGhpcy5vcmllbnRhdGlvbikpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG5cbn07XG5cbi8qKlxuICogRGVzZXJpYWxpemVzIGEgZ2l2ZW4gZGF0YSBvYmplY3QgYW5kIHVwZGF0ZSdzIHRoaXMgVGhpbmcncyBzdGF0ZSB0b1xuICogdGhhdCBkYXRhLlxuICpcbiAqIEBwYXJhbSBkYXRhIEFuIG9iamVjdCB0byBiZSBkZXNlcmlhbGl6ZWQgaW50byB0aGlzIFRoaW5nLlxuICovXG5TY3JpcHRhYmxlLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZSB8fCAnVW5rbm93blNjcmlwdGFibGUnO1xuICAgIHRoaXMuc3ByaXRlSW5kZXggPSBkYXRhLnNwcml0ZUluZGV4ICE9PSB1bmRlZmluZWQgPyBkYXRhLnNwcml0ZUluZGV4IDogMTtcbiAgICB0aGlzLnNldFRvcmNoUmFkaXVzKGRhdGEudG9yY2hSYWRpdXMgIT09IHVuZGVmaW5lZCA/IGRhdGEudG9yY2hSYWRpdXMgOiAwKTtcbiAgICB0aGlzLnB1c2hhYmxlID0gZGF0YS5wdXNoYWJsZSAhPT0gdW5kZWZpbmVkID8gZGF0YS5wdXNoYWJsZSA6IGZhbHNlO1xuICAgIHRoaXMubG9ja2VkID0gZGF0YS5sb2NrZWQ7XG4gICAgaWYgKGRhdGEud2Fsa0RpcmVjdGlvbikge1xuICAgICAgICB0aGlzLndhbGtEaXJlY3Rpb24gPSBEaXJlY3Rpb24uZnJvbU5hbWUoZGF0YS53YWxrRGlyZWN0aW9uKTtcbiAgICB9XG4gICAgaWYgKGRhdGEub3JpZW50YXRpb24pIHtcbiAgICAgICAgdGhpcy5vcmllbnRhdGlvbiA9IERpcmVjdGlvbi5mcm9tTmFtZShkYXRhLm9yaWVudGF0aW9uKTtcbiAgICB9XG4gICAgdGhpcy5zY3JpcHROYW1lID0gZGF0YS5zY3JpcHQ7XG4gICAgdmFyIHNjcmlwdCA9IHRoaXMuYm9hcmQuZ2V0U2NyaXB0KHRoaXMuc2NyaXB0TmFtZSk7XG4gICAgaWYgKHNjcmlwdCkge1xuICAgICAgICB0aGlzLnNjcmlwdENvbnRleHQgPSBuZXcgSnp0U2NyaXB0Q29udGV4dChzY3JpcHQsIHRoaXMpO1xuICAgICAgICBpZiAoZGF0YS5zY3JpcHRDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnNjcmlwdENvbnRleHQuZGVzZXJpYWxpemUoZGF0YS5zY3JpcHRDb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEubWVzc2FnZVF1ZXVlKSAmJiBkYXRhLm1lc3NhZ2VRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZSA9IGRhdGEubWVzc2FnZVF1ZXVlLnNsaWNlKDApO1xuICAgICAgICB9XG5cbiAgICB9XG59O1xuXG4vKipcbiAqIERlbGl2ZXJzIGEgbWVzc2FnZSB0byB0aGlzIFNjcmlwdGFibGUuIFRoaXMgbWVzc2FnZSB3aWxsIGJlIHBhc3NlZFxuICogb24gdG8gaXRzIFNjcmlwdCBkdXJpbmcgaXRzIG5leHQgZXhlY3V0aW9uIGN5Y2xlIGlmIHRoaXMgU2NyaXB0YWJsZUluc3RhbmNlXG4gKiBpcyBub3QgaW4gYSBsb2NrZWQgc3RhdGUuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgQSBtZXNzYWdlIHRvIGJlIGRlbGl2ZXJlZCB0byB0aGlzIFNjcmlwdGFibGUuXG4gKi9cblNjcmlwdGFibGUucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblxuICAgIC8vIElmIHdlIGFyZSByZWFkeSB0byByZWNlaXZlIGEgbWVzc2FnZS4uLlxuICAgIGlmICghdGhpcy5sb2NrZWQpIHtcblxuICAgICAgICAvLyBXZSBkaXNhbGxvdyBkdXBsaWNhdGUgbWVzc2FnZXMgaW4gYSByb3dcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZVF1ZXVlW3RoaXMubWVzc2FnZVF1ZXVlLmxlbmd0aCAtIDFdICE9PSBtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cbi8qKlxuICogTW92ZXMgdGhpcyBUaGluZyBpbiBhIHByb3ZpZGVkIERpcmVjdGlvbiBhbmQgcmV0dXJucyBpdHMgc3VjY2Vzcy5cbiAqXG4gKiBAcGFyYW0gZGlyZWN0aW9uIEEgRGlyZWN0aW9uIGluIHdoaWNoIHRvIG1vdmUgdGhpcyBUaGluZy5cbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgbW92ZSB3YXMgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5TY3JpcHRhYmxlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgIHRoaXMub3JpZW50YXRpb24gPSBkaXJlY3Rpb247XG4gICAgcmV0dXJuIFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUubW92ZS5jYWxsKHRoaXMsIGRpcmVjdGlvbik7XG59O1xuXG4vKipcbiAqIFB1c2hlcyB0aGlzIFNjcmlwdGFibGUgaW4gYSBwcm92aWRlZCBEaXJlY3Rpb24uXG4gKi9cblNjcmlwdGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgaWYgKHRoaXMucHVzaGFibGUpIHtcbiAgICAgICAgdGhpcy5tb3ZlKGRpcmVjdGlvbik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNYWtlcyB0aGlzIFNjcmlwdGFibGUgd2FsayBpbiBpdHMgY3VycmVudCB3YWxraW5nIGRpcmVjdGlvbi5cbiAqIFNjcmlwdGFibGVzIGNhbiB3YWxrIHdoaWxlIGV4ZWN1dGluZyBvdGhlciBpbnN0cnVjdGlvbnMuIElmIHRoaXNcbiAqIFNjcmlwdGFibGUgd2Fsa3MgaW50byBhbiBvYnN0aWNsZSBhbmQgY2Fubm90IGNvbnRpbnVlIHdhbGtpbmcsXG4gKiBpdCB3aWxsIHJlY2VpdmUgYSAnVEhVRCcgbWVzc2FnZSBhbmQgaGFsdCBpdHMgd2Fsa2luZyBkaXJlY3Rpb24uXG4gKi9cblNjcmlwdGFibGUucHJvdG90eXBlLndhbGsgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMud2Fsa0RpcmVjdGlvbikge1xuXG4gICAgICAgIGlmICghdGhpcy5tb3ZlKHRoaXMud2Fsa0RpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoJ1RIVUQnKTtcbiAgICAgICAgfVxuXG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoaXMgU2NyaXB0YWJsZSBmb3IgYSBzaW5nbGUgZXhlY3V0aW9uIGN5Y2xlLCBpbmNsdWRpbmcgaXRzXG4gKiBhc3NvY2lhdGVkIFNjcmlwdC5cbiAqL1xuU2NyaXB0YWJsZS5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy53YWxrKCk7XG4gICAgaWYgKHRoaXMuc2NyaXB0Q29udGV4dCkge1xuICAgICAgICB0aGlzLnNjcmlwdENvbnRleHQuZXhlY3V0ZVRpY2soKTtcbiAgICB9XG5cbn07XG5cblNjcmlwdGFibGUucHJvdG90eXBlLnNldFRvcmNoUmFkaXVzID0gZnVuY3Rpb24gKHJhZGl1cykge1xuICAgIHRoaXMudG9yY2hSYWRpdXMgPSByYWRpdXM7XG59O1xuXG5TY3JpcHRhYmxlLnByb3RvdHlwZS5nZXRUb3JjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy50b3JjaFJhZGl1cyA+IDApIHtcbiAgICAgICAgcmV0dXJuIHV0aWxpdGllcy5nZW5lcmF0ZUNpcmNsZURhdGEodGhpcy5wb2ludCwgdGhpcy50b3JjaFJhZGl1cyk7XG4gICAgfVxufTtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBCVUlMVC1JTiBUSElOR1NcbiAqPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuIC8qKlxuICAqIEFjdGl2ZUJvbWIgaXMgYW4gVXBkYXRlYWJsZVRoaW5nIHRoYXQgY291bnRzIGRvd24gZnJvbSA5IHRvIDAgYmVmb3JlIGV4cGxvZGluZy5cbiAgKlxuICAqIEBwYXJhbSBib2FyZCBBIGJvYXJkIHRvIG93biB0aGlzIEFjdGl2ZUJvbWJcbiAgKi9cbmZ1bmN0aW9uIEFjdGl2ZUJvbWIoYm9hcmQpIHtcbiAgICBVcGRhdGVhYmxlVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy50aW1lVG9MaXZlID0gOTtcbiAgICB0aGlzLnNwZWVkID0gNjtcbiAgICB0aGlzLnNwcml0ZUluZGV4ID0gNTc7XG4gICAgdGhpcy5yYWRpdXMgPSA0O1xuICAgIHRoaXMuY29udmV5YWJsZSA9IHRydWU7XG59XG5BY3RpdmVCb21iLnByb3RvdHlwZSA9IG5ldyBVcGRhdGVhYmxlVGhpbmcoKTtcbkFjdGl2ZUJvbWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQWN0aXZlQm9tYjtcblxuQWN0aXZlQm9tYi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBVcGRhdGVhYmxlVGhpbmcucHJvdG90eXBlLnNlcmlhbGl6ZS5jYWxsKHRoaXMpO1xuICAgIHJlc3VsdC50aW1lVG9MaXZlID0gdGhpcy50aW1lVG9MaXZlO1xuICAgIHJlc3VsdC5yYWRpdXMgPSB0aGlzLnJhZGl1cztcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuQWN0aXZlQm9tYi5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuZGVzZXJpYWxpemUuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICB0aGlzLnRpbWVUb0xpdmUgPSBkYXRhLnRpbWVUb0xpdmUgfHwgOTtcbiAgICB0aGlzLnJhZGl1cyA9IGRhdGEucmFkaXVzIHx8IDQ7XG59O1xuXG5BY3RpdmVCb21iLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgIHRoaXMubW92ZShkaXJlY3Rpb24pO1xufTtcblxuQWN0aXZlQm9tYi5wcm90b3R5cGUuZ2V0U3ByaXRlSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDU3IC0gKDkgLSB0aGlzLnRpbWVUb0xpdmUpO1xufTtcblxuQWN0aXZlQm9tYi5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGV4cGxvc2lvbjtcbiAgICB0aGlzLnBsYXkodGhpcy50aW1lVG9MaXZlICUgMiA/ICc4JyA6ICc1Jyk7XG5cbiAgICB0aGlzLnRpbWVUb0xpdmUgLT0gMTtcbiAgICBpZiAodGhpcy50aW1lVG9MaXZlIDwgMCkge1xuICAgICAgICBleHBsb3Npb24gPSBuZXcgZXhwb3J0cy50aGluZ3MuRXhwbG9zaW9uKHRoaXMuYm9hcmQpO1xuICAgICAgICBleHBsb3Npb24ucmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gICAgICAgIHRoaXMuYm9hcmQucmVwbGFjZVRpbGUodGhpcy5wb2ludCwgZXhwbG9zaW9uKTtcbiAgICB9XG5cbn07XG5cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbi8qKlxuICogQW1tbyBpcyBhIFRoaW5nIHRoYXQgYWN0cyBhcyBhbiBpdGVtIGNhcGFibGUgb2YgaW5jcmVhc2luZyBhIEdhbWUncyAnYW1tbycgY291bnRlclxuICogYnkgZml2ZSB1bml0cyB3aGVuIGNvbGxlY3RlZC5cbiAqXG4gKiBAcGFyYW0gYm9hcmQgQSBib2FyZCB0byBvd24gdGhpcyBBbW1vIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEFtbW8oYm9hcmQpIHtcbiAgICBUaGluZy5jYWxsKHRoaXMsIGJvYXJkKTtcbiAgICB0aGlzLnNwcml0ZUluZGV4ID0gMTMyO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQ3lhbjtcbn1cbkFtbW8ucHJvdG90eXBlID0gbmV3IFRoaW5nKCk7XG5BbW1vLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFtbW87XG5cbkFtbW8ucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gVGhpbmcucHJvdG90eXBlLnNlcmlhbGl6ZS5jYWxsKHRoaXMpO1xuICAgIGRlbGV0ZSByZXN1bHQuY29sb3I7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkFtbW8ucHJvdG90eXBlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBUaGluZy5wcm90b3R5cGUuZGVzZXJpYWxpemUuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkN5YW47XG59O1xuXG4vKipcbiAqIFB1c2hlcyB0aGlzIEFtbW8gaW4gYSBwcm92aWRlZCBkaXJlY3Rpb24gb24gaXRzIG93bmVyIEJvYXJkLlxuICpcbiAqIEBwYXJhbSBkaXJlY3Rpb24gQSBkaXJlY3Rpb24gaW4gd2hpY2ggdG8gcHVzaCB0aGlzIEFtbW9cbiAqL1xuQW1tby5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICB0aGlzLm1vdmUoZGlyZWN0aW9uKTtcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwcm92aWRlZCBtZXNzYWdlIHRvIHRoaXMgQW1tbyBpbnN0YW5jZS4gSWYgYSBUT1VDSCBtZXNzYWdlIGlzIHJlY2VpdmVkXG4gKiB0aGVuIHRoaXMgQW1tbyBpbnN0YW5jZSB3aWxsIGJlIHJlbW92ZWQgYW5kIGluY3JlYXNlIHRoZSBHYW1lJ3MgJ2FtbW8nIGNvdW50ZXJcbiAqIGJ5IGZpdmUgdW5pdHMuXG4gKi9cbkFtbW8ucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZSA9PT0gJ1RPVUNIJykge1xuICAgICAgICB0aGlzLm9uZVRpbWVNZXNzYWdlKCdzdGF0dXMuYW1tbycpO1xuICAgICAgICB0aGlzLnBsYXkoJ3RjYyNkJyk7XG4gICAgICAgIHRoaXMuYWRqdXN0Q291bnRlcignQU1NTycsIDUpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH1cbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBCZWFyIHJlcHJlc2VudHMgYW4gVXBkYXRlYWJsZVRoaW5nIHRoYXQgd2lsbCBhdHRhY2sgYSBQbGF5ZXIgd2hlbiBpdCBpcyBhbGlnbmVkXG4gKiB2ZXJ0aWNhbGx5IG9yIGhvcml6b250YWxseSB3aXRoaW4gYSBkZWZpbmVkIHNlbnNpdGl2aXR5IHJhbmdlLlxuICpcbiAqIEBwYXJhbSBib2FyZCBBIEJvYXJkIHRvIG93biB0aGlzIEJlYXIuXG4gKi9cbmZ1bmN0aW9uIEJlYXIoYm9hcmQpIHtcbiAgICBVcGRhdGVhYmxlVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IDE1MztcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyb3duO1xuICAgIHRoaXMuc2Vuc2l0aXZpdHkgPSA5O1xuICAgIHRoaXMuc3BlZWQgPSAzO1xuICAgIHRoaXMuY29udmV5YWJsZSA9IHRydWU7XG59XG5CZWFyLnByb3RvdHlwZSA9IG5ldyBVcGRhdGVhYmxlVGhpbmcoKTtcbkJlYXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQmVhcjtcblxuLyoqXG4gKiBTZXJpYWxpemVzIHRoaXMgQmVhciB0byBhbiBPYmplY3QuXG4gKlxuICogQHJldHVybiBBIHNlcmlhbGl6ZWQgQmVhclxuICovXG5CZWFyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuc2VyaWFsaXplLmNhbGwodGhpcyk7XG4gICAgZGVsZXRlIHJlc3VsdC5jb2xvcjtcbiAgICByZXN1bHQuc2Vuc2l0aXZpdHkgPSB0aGlzLnNlbnNpdGl2aXR5O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERlc2VyaWFsaXplcyB0aGlzIEJlYXIgZnJvbSBhIHByb3ZpZGVkIGRhdGEgT2JqZWN0XG4gKlxuICogQHBhcmFtIGRhdGEgQSBkYXRhIEJlYXIgb2JqZWN0IHRvIGJlIGRlc2VyaWFsaXplZC5cbiAqL1xuQmVhci5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuZGVzZXJpYWxpemUuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyb3duO1xuICAgIHRoaXMuc2Vuc2l0aXZpdHkgPSBkYXRhLnNlbnNpdGl2aXR5IHx8IDk7XG59O1xuXG4vKipcbiAqIFB1c2hlcyB0aGlzIEJlYXIgaW4gYSBnaXZlbiBkaXJlY3Rpb24uIElmIHRoaXMgQmVhciBjYW5ub3QgYmUgcHVzaGVkLFxuICogaXQgd2lsbCBiZSBzcXVpc2hlZCBhbmQgcmVtb3ZlZCBmcm9tIGl0cyBvd25lciBCb2FyZC5cbiAqXG4gKiBAcGFyYW0gZGlyZWN0aW9uIEEgZGlyZWN0aW9uIGluIHdoaWNoIHRvIHB1c2ggdGhpcyBCZWFyLlxuICovXG5CZWFyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgcHVzaGVyKSB7XG5cbiAgICBpZiAocHVzaGVyLnR5cGUgPT09ICdSaXZlcicpIHtcbiAgICAgICAgdGhpcy5tb3ZlKGRpcmVjdGlvbiwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5tb3ZlKGRpcmVjdGlvbikpIHtcbiAgICAgICAgdGhpcy5wbGF5KCd0K2MtLS1jKysrK2MtLWMnKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogRGVsaXZlcnMgYSBwcm92aWRlZCBtZXNzYWdlIHRvIHRoaXMgVGhpbmcuIElmIGEgU0hPVCBtZXNzYWdlIGlzIHJlY2VpdmVkLFxuICogdGhlbiB0aGlzIEJlYXIgd2lsbCBiZSBkZWxldGVkIGZyb20gdGhlIGJvYXJkLiBJZiBhIFRPVUNIIG1lc3NhZ2UgaXNcbiAqIHJlY2VpdmVkLCB0aGVuIHRoZSBwbGF5ZXIgd2lsbCBiZSBzZW50IGEgU0hPVCBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlTmFtZSBhIG5hbWUgb2YgYSBtZXNzYWdlIHRvIGRlbGl2ZXIuXG4gKi9cbkJlYXIucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblxuICAgIGlmIChtZXNzYWdlID09PSAnU0hPVCcgfHwgbWVzc2FnZSA9PT0gJ0JPTUJFRCcpIHtcbiAgICAgICAgdGhpcy5wbGF5KCd0K2MtLS1jKysrK2MtLWMnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5hZGp1c3RDb3VudGVyKCdTQ09SRScsIDEwKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgPT09ICdUT1VDSCcpIHtcbiAgICAgICAgdGhpcy5ib2FyZC5wbGF5ZXIuc2VuZE1lc3NhZ2UoJ1NIT1QnKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGlzIEJlYXIgZm9yIGEgcHJvdmlkZWQgdGltZXN0YW1wLiBUaGlzIEJlYXIgd2lsbCBtb3ZlIGl0c2VsZiByYW5kb21seVxuICogZHVyaW5nIHVwZGF0ZXMuIElmIGEgUGxheWVyIGJsb2NrcyBpdHMgbW92ZW1lbnQsIHRoZW4gdGhlIHBsYXllciB3aWxsIGJlIHNlbnRcbiAqIGEgU0hPVCBtZXNzYWdlIGFuZCB0aGlzIEJlYXIgd2lsbCBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBib2FyZC5cbiAqL1xuQmVhci5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRoaW5nLFxuICAgICAgICBkaXJlY3Rpb247XG5cbiAgICBpZiAodGhpcy5pc1BsYXllckFsaWduZWQoMTAgLSB0aGlzLnNlbnNpdGl2aXR5KSkge1xuXG4gICAgICAgIC8vIFgtQXhpcyBhbHdheXMgZ2V0cyBwcmlvcml0eVxuICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLmdldFBsYXllckRpcmVjdGlvbigneCcpO1xuXG4gICAgICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IGFsaWduZWQgd2l0aCB0aGUgcGxheWVyLi4uXG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGlyZWN0aW9uID0gdGhpcy5nZXRQbGF5ZXJEaXJlY3Rpb24oJ3knKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaW5nID0gdGhpcy5ib2FyZC5nZXRUaWxlKHRoaXMucG9pbnQuYWRkKGRpcmVjdGlvbikpO1xuICAgICAgICBpZiAodGhpbmcgJiYgKHRoaW5nLnR5cGUgPT09ICdCcmVha2FibGVXYWxsJyB8fCB0aGluZy50eXBlID09PSAnUGxheWVyJykpIHtcbiAgICAgICAgICAgIHRoaW5nLnNlbmRNZXNzYWdlKCdTSE9UJyk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgYXR0ZW1wdCB0byBtb3ZlIGluIHRoZSBkaXJlY3Rpb24gb2YgYSByaXZlclxuICAgICAgICBpZiAodGhpbmcgJiYgdGhpbmcudHlwZSA9PT0gJ1JpdmVyJyAmJiB0aGluZy5kaXJlY3Rpb24gPT09IERpcmVjdGlvbi5vcHBvc2l0ZShkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1vdmUoZGlyZWN0aW9uLCB0cnVlKTtcbiAgICB9XG5cbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gQmxpbmtlcihib2FyZCkge1xuICAgIFVwZGF0ZWFibGVUaGluZy5jYWxsKHRoaXMsIGJvYXJkKTtcbiAgICB0aGlzLmRpcmVjdGlvbiA9IERpcmVjdGlvbi5Ob3J0aDtcbiAgICB0aGlzLnBlcmlvZCA9IDM7XG4gICAgdGhpcy5kZWxheSA9IDA7XG4gICAgdGhpcy5jdXJyZW50VGljayA9IDA7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IDIwNjtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLlllbGxvdztcbiAgICB0aGlzLmJsaW5rU3RhdGUgPSBmYWxzZTtcbn1cbkJsaW5rZXIucHJvdG90eXBlID0gbmV3IFVwZGF0ZWFibGVUaGluZygpO1xuQmxpbmtlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCbGlua2VyO1xuXG5CbGlua2VyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuc2VyaWFsaXplLmNhbGwodGhpcyk7XG4gICAgcmVzdWx0LnBlcmlvZCA9IHRoaXMucGVyaW9kO1xuICAgIHJlc3VsdC5kZWxheSA9IHRoaXMuZGVsYXk7XG4gICAgcmVzdWx0LmRpcmVjdGlvbiA9IERpcmVjdGlvbi5nZXRTaG9ydE5hbWUodGhpcy5kaXJlY3Rpb24pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5CbGlua2VyLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHRoaXMuY3ljbGVDb3VudCA9IDA7XG4gICAgdGhpcy5wZXJpb2QgPSBkYXRhLnBlcmlvZCB8fCAzO1xuICAgIHRoaXMuZGVsYXkgPSBkYXRhLmRlbGF5IHx8IDA7XG4gICAgdGhpcy5jdXJyZW50VGljayA9IHRoaXMucGVyaW9kIC0gdGhpcy5kZWxheSAtIDE7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBkYXRhLmRpcmVjdGlvbiA/IERpcmVjdGlvbi5mcm9tTmFtZShkYXRhLmRpcmVjdGlvbikgOiBEaXJlY3Rpb24uTm9ydGg7XG59O1xuXG5CbGlua2VyLnByb3RvdHlwZS5kb1RpY2sgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB0aGlzLmN1cnJlbnRUaWNrICs9IDE7XG4gICAgaWYgKHRoaXMuY3VycmVudFRpY2sgPj0gdGhpcy5wZXJpb2QpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50VGljayA9IDA7XG4gICAgICAgIHRoaXMuYmxpbmtTdGF0ZSA9ICF0aGlzLmJsaW5rU3RhdGU7XG4gICAgICAgIHRoaXMuYmxpbmsoKTtcbiAgICB9XG5cbn07XG5cbkJsaW5rZXIucHJvdG90eXBlLmJsaW5rID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHBvaW50ID0gdGhpcy5wb2ludCxcbiAgICAgICAgdGlsZSxcbiAgICAgICAgbW92ZWQ7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuXG4gICAgICAgIC8vIEluY3JlbWVudCBvdXIgcG9pbnQgb2YgaW50ZXJlc3RcbiAgICAgICAgcG9pbnQgPSBwb2ludC5hZGQodGhpcy5kaXJlY3Rpb24pO1xuXG4gICAgICAgIC8vIElmIGl0J3Mgb2ZmIHRoZSBib2FyZCwgc3RvcCBpbW1lZGlhdGVseVxuICAgICAgICBpZiAodGhpcy5ib2FyZC5pc091dHNpZGUocG9pbnQpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdyYWIgb3VyIHRpbGUgb2YgaW50ZXJlc3RcbiAgICAgICAgdGlsZSA9IHRoaXMuYm9hcmQuZ2V0VGlsZShwb2ludCk7XG5cblxuICAgICAgICAvLyBJZiB3ZSBhY3R1YWxseSBmb3VuZCBhIHRpbGUuLi5cbiAgICAgICAgaWYgKHRpbGUpIHtcblxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuYmxpbmtTdGF0ZSAmJiB0aWxlLnR5cGUgPT09ICdCbGlua1dhbGwnKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSdyZSBub3QgYmxpbmtpbmcsIHNvIHJlbW92ZSB0aGUgQmxpbmtXYWxsIHRpbGVcbiAgICAgICAgICAgICAgICB0aWxlLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRpbGUudHlwZSA9PT0gJ1BsYXllcicpIHtcblxuICAgICAgICAgICAgICAgIC8vIEhhcm0gdGhlIHBsYXllclxuICAgICAgICAgICAgICAgIHRpbGUuc2VuZE1lc3NhZ2UoJ1NIT1QnKTtcblxuICAgICAgICAgICAgICAgIC8vIFNob3ZlIHRoZSBwbGF5ZXIgb3V0IG9mIHRoZSB3YXkgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICBpZiAoIXRpbGUuaXNCbG9ja2VkKERpcmVjdGlvbi5jbG9ja3dpc2UodGhpcy5kaXJlY3Rpb24pKSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRpbGUubW92ZShEaXJlY3Rpb24uY2xvY2t3aXNlKHRoaXMuZGlyZWN0aW9uKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGlsZS5pc0Jsb2NrZWQoRGlyZWN0aW9uLmNvdW50ZXJDbG9ja3dpc2UodGhpcy5kaXJlY3Rpb24pKSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlZCA9IHRpbGUubW92ZShEaXJlY3Rpb24uY291bnRlckNsb2Nrd2lzZSh0aGlzLmRpcmVjdGlvbikpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHdlcmVuJ3QgYWJsZSB0byBtb3ZlIG91ciBwbGF5ZXJcbiAgICAgICAgICAgICAgICBpZiAoIW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIEFsbCBvdGhlciB0aWxlcyBhcmVuJ3QgYWZmZWN0ZWRcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBhcmUgYmxpbmtpbmcuLi5cbiAgICAgICAgaWYgKHRoaXMuYmxpbmtTdGF0ZSkge1xuXG4gICAgICAgICAgICAvLyBBZGQgYSBibGlua3dhbGxcbiAgICAgICAgICAgIHRoaXMuYm9hcmQuYWRkVGhpbmcocG9pbnQsIHRoaXMuY3JlYXRlQmxpbmtXYWxsKCkpO1xuXG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuQmxpbmtlci5wcm90b3R5cGUuY3JlYXRlQmxpbmtXYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBibGlua1dhbGwgPSBuZXcgZXhwb3J0cy50aGluZ3MuQmxpbmtXYWxsKHRoaXMuYm9hcmQpO1xuICAgIGJsaW5rV2FsbC5ob3Jpem9udGFsID0gKHRoaXMuZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uTm9ydGggfHwgdGhpcy5kaXJlY3Rpb24gPT09IERpcmVjdGlvbi5Tb3V0aCkgPyBmYWxzZSA6IHRydWU7XG4gICAgYmxpbmtXYWxsLmZvcmVncm91bmQgPSB0aGlzLmZvcmVncm91bmQ7XG4gICAgcmV0dXJuIGJsaW5rV2FsbDtcbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBCbGlua1dhbGwgaXMgYSBzcGVjaWFsIHR5cGUgb2Ygd2FsbCBnZW5lcmF0ZWQgYnkgQmxpbmtlcnMuXG4gKi9cbmZ1bmN0aW9uIEJsaW5rV2FsbChib2FyZCkge1xuICAgIFRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMuaG9yaXpvbnRhbCA9IGZhbHNlO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuWWVsbG93O1xufVxuQmxpbmtXYWxsLnByb3RvdHlwZSA9IG5ldyBUaGluZygpO1xuQmxpbmtXYWxsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJsaW5rV2FsbDtcblxuQmxpbmtXYWxsLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFRoaW5nLnByb3RvdHlwZS5zZXJpYWxpemUuY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIHJlc3VsdC5ob3Jpem9udGFsID0gdGhpcy5ob3Jpem9udGFsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuQmxpbmtXYWxsLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgVGhpbmcucHJvdG90eXBlLmRlc2VyaWFsaXplLmNhbGwodGhpcywgZGF0YSk7XG4gICAgdGhpcy5ob3Jpem9udGFsID0gZGF0YS5ob3Jpem9udGFsICE9PSB1bmRlZmluZWQgPyBkYXRhLmhvcml6b250YWwgOiBmYWxzZTtcbn07XG5cbkJsaW5rV2FsbC5wcm90b3R5cGUuZ2V0U3ByaXRlSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaG9yaXpvbnRhbCA/IDIwNSA6IDE4Njtcbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBIEJvbWIgaXMgYSBUaGluZyB0aGF0IGJlY29tZXMgYW4gQWN0aXZlQm9tYiB3aGVuIHRvdWNoZWQuXG4gKlxuICogQHBhcmFtIGJvYXJkIEFuIG93bmVyIGJvYXJkIGZvciB0aGlzIEJvbWJcbiAqL1xuZnVuY3Rpb24gQm9tYihib2FyZCkge1xuICAgIFRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMucmFkaXVzID0gNDtcbiAgICB0aGlzLnNwcml0ZUluZGV4ID0gMTE7XG4gICAgdGhpcy5jb252ZXlhYmxlID0gdHJ1ZTtcbn1cbkJvbWIucHJvdG90eXBlID0gbmV3IFRoaW5nKCk7XG5Cb21iLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJvbWI7XG5cbkJvbWIucHJvdG90eXBlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBUaGluZy5wcm90b3R5cGUuZGVzZXJpYWxpemUuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICB0aGlzLnJhZGl1cyA9IGRhdGEucmFkaXVzIHx8IDQ7XG59O1xuXG5Cb21iLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFRoaW5nLnByb3RvdHlwZS5zZXJpYWxpemUuY2FsbCh0aGlzKTtcbiAgICByZXN1bHQucmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkJvbWIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgdGhpcy5tb3ZlKGRpcmVjdGlvbik7XG59O1xuXG5Cb21iLnByb3RvdHlwZS5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgdmFyIGJvbWI7XG4gICAgaWYgKG1lc3NhZ2UgPT09ICdUT1VDSCcpIHtcbiAgICAgICAgdGhpcy5wbGF5KCd0Y2YrY2YrYycpO1xuICAgICAgICBib21iID0gbmV3IEFjdGl2ZUJvbWIodGhpcy5ib2FyZCk7XG4gICAgICAgIGJvbWIucmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gICAgICAgIGJvbWIuZm9yZWdyb3VuZCA9IHRoaXMuZm9yZWdyb3VuZDtcbiAgICAgICAgYm9tYi5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kO1xuICAgICAgICB0aGlzLmJvYXJkLnJlcGxhY2VUaWxlKHRoaXMucG9pbnQsIGJvbWIpO1xuICAgIH1cbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAqIEEgQm91bGRlciBpcyBhIFRoaW5nIHRoYXQgaXMgcHVzaGFibGUgaW4gYWxsIGRpcmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIGJvYXJkIEFuIG93bmVyIGJvYXJkIGZvciB0aGlzIEJvdWxkZXIuXG4gKi9cbmZ1bmN0aW9uIEJvdWxkZXIoYm9hcmQpIHtcbiAgICBUaGluZy5jYWxsKHRoaXMsIGJvYXJkKTtcbiAgICB0aGlzLmNvbnZleWFibGUgPSB0cnVlO1xuICAgIHRoaXMuc3ByaXRlSW5kZXggPSAyNTQ7XG59XG5Cb3VsZGVyLnByb3RvdHlwZSA9IG5ldyBUaGluZygpO1xuQm91bGRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3VsZGVyO1xuXG4vKipcbiAqIFJlY2VpdmVzIGEgcmVxdWVzdCB0byBiZSBwdXNoZWQgaW4gYSBnaXZlbiBkaXJlY3Rpb24uXG4gKlxuICogQHBhcmFtIGRpcmVjdGlvbiBBIGRpcmVjdGlvbiBpbiB3aGljaCB0aGlzIFRoaW5nIGlzIHJlcXVlc3RlZCB0byBtb3ZlLlxuICovXG5Cb3VsZGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgcHVzaGVyKSB7XG5cbiAgICBpZiAocHVzaGVyLnR5cGUgPT09ICdSaXZlcicpIHtcbiAgICAgICAgdGhpcy5tb3ZlKGRpcmVjdGlvbiwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1vdmUoZGlyZWN0aW9uKSkge1xuICAgICAgICB0aGlzLnBsYXkoJ3QtLWYnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxufTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEJyZWFrYWJsZVdhbGwgcmVwcmVzZW50cyBhbiBvYnN0YWNsZSBmb3IgYSBwbGF5ZXIgdW50aWwgaXQgaXMgc2hvdCwgYXQgd2hpY2hcbiAqIHBvaW50IHRoZSB3YWxsIGlzIHJlbW92ZWQgZnJvbSBpdHMgb3duZXIgQm9hcmQuXG4gKlxuICogQHBhcmFtIGJvYXJkIEFuIG93bmVyIGJvYXJkIGZvciB0aGlzIEJyZWFrYWJsZVdhbGwuXG4gKi9cbmZ1bmN0aW9uIEJyZWFrYWJsZVdhbGwoYm9hcmQpIHtcbiAgICBUaGluZy5jYWxsKHRoaXMsIGJvYXJkKTtcbiAgICB0aGlzLnNwcml0ZUluZGV4ID0gMTc3O1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IENvbG9ycy5CbGFjaztcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQnJpZ2h0Q3lhbjtcbn1cbkJyZWFrYWJsZVdhbGwucHJvdG90eXBlID0gbmV3IFRoaW5nKCk7XG5CcmVha2FibGVXYWxsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJyZWFrYWJsZVdhbGw7XG5cbi8qKlxuICogU2VuZHMgYSBwcm92aWRlZCBtZXNzYWdlIHRvIHRoaXMgQnJlYWthYmxlV2FsbC4gSWYgYSBTSE9UIG1lc3NhZ2VcbiAqIGlzIHJlY2VpdmVkLCB0aGVuIHRoaXMgQnJlYWthYmxlV2FsbCB3aWxsIHZhbmlzaC5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBBIG1lc3NhZ2UgdG8gcmVjZWl2ZS5cbiAqL1xuQnJlYWthYmxlV2FsbC5wcm90b3R5cGUuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlID09PSAnU0hPVCcgfHwgbWVzc2FnZSA9PT0gJ0JPTUJFRCcpIHtcbiAgICAgICAgdGhpcy5wbGF5KCd0LWMnKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgPT09ICdUT1VDSCcpIHtcbiAgICAgICAgdGhpcy5vbmVUaW1lTWVzc2FnZSgnc3RhdHVzLmJyZWFrYWJsZScpO1xuICAgIH1cbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBIEJ1bGxldCBpcyBhbiBVcGRhdGVhYmxlVGhpbmcgdGhhdCByZXByZXNlbnRzIGEgcHJvamVjdGlsZS5cbiAqXG4gKiBAcGFyYW0gYm9hcmQgQW4gb3duZXIgYm9hcmQgZm9yIHRoaXMgQnVsbGV0XG4gKi9cbmZ1bmN0aW9uIEJ1bGxldChib2FyZCkge1xuICAgIFVwZGF0ZWFibGVUaGluZy5jYWxsKHRoaXMsIGJvYXJkKTtcbiAgICB0aGlzLnNwcml0ZUluZGV4ID0gMjQ4O1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IENvbG9ycy5CcmlnaHRXaGl0ZTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBEaXJlY3Rpb24uTm9ydGg7XG4gICAgdGhpcy5zcGVlZCA9IDE7XG59XG5CdWxsZXQucHJvdG90eXBlID0gbmV3IFVwZGF0ZWFibGVUaGluZygpO1xuQnVsbGV0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJ1bGxldDtcblxuLyoqXG4gKiBTZXJpYWxpemVzIHRoaXMgVGhpbmcgdG8gYW4gb2JqZWN0IGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEByZXR1cm4gQSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhpcyBUaGluZy5cbiAqL1xuQnVsbGV0LnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuc2VyaWFsaXplLmNhbGwodGhpcykgfHwge307XG4gICAgZGVsZXRlIHJlc3VsdC5jb2xvcjtcbiAgICByZXN1bHQuZGlyZWN0aW9uID0gRGlyZWN0aW9uLmdldFNob3J0TmFtZSh0aGlzLmRpcmVjdGlvbik7XG4gICAgaWYgKHRoaXMuZnJvbVBsYXllcikge1xuICAgICAgICByZXN1bHQuZnJvbVBsYXllciA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERlc2VyaWFsaXplcyBhIGdpdmVuIGRhdGEgb2JqZWN0IGFuZCB1cGRhdGUncyB0aGlzIFRoaW5nJ3Mgc3RhdGUgdG9cbiAqIHRoYXQgZGF0YS5cbiAqXG4gKiBAcGFyYW0gZGF0YSBBbiBvYmplY3QgdG8gYmUgZGVzZXJpYWxpemVkIGludG8gdGhpcyBUaGluZy5cbiAqL1xuQnVsbGV0LnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQnJpZ2h0V2hpdGU7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBEaXJlY3Rpb24uZnJvbU5hbWUoZGF0YS5kaXJlY3Rpb24pO1xuICAgIGlmIChkYXRhLmZyb21QbGF5ZXIpIHtcbiAgICAgICAgdGhpcy5mcm9tUGxheWVyID0gZGF0YS5mcm9tUGxheWVyO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2VuZHMgYSBwcm92aWRlZCBtZXNzYWdlIHRvIHRoaXMgQnVsbGV0IGluc3RhbmNlLiBJZiBhIFRvdWNoIG1lc3NhZ2UgaXNcbiAqIHJlY2VpdmVkIHRoZW4gdGhlIHBsYXllciB3aWxsIGJlIHNlbnQgYSBzaG90IG1lc3NhZ2UgYW5kIHRoaXMgQnVsbGV0IHdpbGxcbiAqIGJlIHJlbW92ZWQgZnJvbSBpdHMgb3duZXIgQm9hcmQuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgQSBtZXNzYWdlIHRvIGJlIGRlbGl2ZXJlZCB0byB0aGlzIEJ1bGxldC5cbiAqL1xuQnVsbGV0LnByb3RvdHlwZS5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UgPT09ICdUT1VDSCcpIHtcbiAgICAgICAgdGhpcy5ib2FyZC5wbGF5ZXIuc2VuZE1lc3NhZ2UoJ1NIT1QnKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyB3aGV0aGVyIG9yIG5vdCB0aGlzIEJ1bGxldCBpbnN0YW5jZSB3aXNoZXMgdG8gYmUgdXBkYXRlZCBvbiBpdHMgb3duZXIgQm9hcmQnc1xuICogcmV2ZXJzZSB1cGRhdGUgY3ljbGUuXG4gKi9cbkJ1bGxldC5wcm90b3R5cGUudXBkYXRlT25SZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbiA9PT0gRGlyZWN0aW9uLlNvdXRoIHx8IHRoaXMuZGlyZWN0aW9uID09PSBEaXJlY3Rpb24uRWFzdDtcbn07XG5cbkJ1bGxldC5wcm90b3R5cGUuaW5mbHVlbmNlU21hcnRQYXRoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHBvaW50LFxuICAgICAgICBpbmRleDtcblxuICAgIC8vIElmIHdlIGFyZSBhIHBsYXllciBidWxsZXQuLi5cbiAgICBpZiAodGhpcy5mcm9tUGxheWVyKSB7XG5cbiAgICAgICAgcG9pbnQgPSB0aGlzLnBvaW50O1xuXG4gICAgICAgIC8vIFdlaWdodCB0aGUgdGVuIHNwYWNlcyBpbiBmcm9udCBvZiBvdXIgYnVsbGV0IGFzIGF2ZXJzaW9uIHBvaW50c1xuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCAxMDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgcG9pbnQgPSBwb2ludC5hZGQodGhpcy5kaXJlY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5ib2FyZC5hZGp1c3RTbWFydFBhdGhXZWlnaHQocG9pbnQsIDEwMCAtIChpbmRleCAqIDEwKSk7XG4gICAgICAgIH1cblxuICAgIH1cblxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoaXMgYnVsbGV0LCBtb3ZpbmcgaXQgb25lIHRpbGUgaW4gaXRzIGFzc29jaWF0ZWRcbiAqIGRpcmVjdGlvbi5cbiAqL1xuQnVsbGV0LnByb3RvdHlwZS5kb1RpY2sgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBJZiB3ZSBhcmUgdW5hYmxlIHRvIG1vdmUsIGF0dGFjayBvdXIgb2JzdGFjbGVcbiAgICBpZiAoIXRoaXMubW92ZSh0aGlzLmRpcmVjdGlvbiwgdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy5hdHRhY2soKTtcbiAgICAgICAgdGhpcy5yZWFjdCgpO1xuICAgIH1cblxufTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBBdHRhY2sgYSBUaGluZyBpbiB0aGlzIEJ1bGxldCdzIHBhdGguIElmIGEgcGxheWVyLCBTY3JpcHRhYmxlLCBvciBCcmVha2FibGVXYWxsIGlzIGluXG4gKiBpdHMgcGF0aCwgdGhhdCBUaGluZyB3aWxsIGJlIHNlbnQgYSBTSE9UIG1lc3NhZ2UuXG4gKi9cbkJ1bGxldC5wcm90b3R5cGUuYXR0YWNrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gU2VlIHdoYXQgd2FzIGluIG91ciB3YXkuXG4gICAgdmFyIHRoaW5nID0gdGhpcy5ib2FyZC5nZXRUaWxlKHRoaXMucG9pbnQuYWRkKHRoaXMuZGlyZWN0aW9uKSk7XG5cbiAgICAvKlxuICAgICAqIFNlbmQgYSBTSE9UIG1lc3NhZ2UgaWYgdGhlIGJ1bGxldCB3YXMgZnJvbSB0aGUgcGxheWVyXG4gICAgICogb3RoZXJ3aXNlIHdlIG9ubHkgc2VuZCB0aGUgU0hPVCBtZXNzYWdlIHRvIHRoZSBwbGF5ZXIsIFNjcmlwdGFibGVzLCBhbmQgQnJlYWthYmxlV2FsbHMuXG4gICAgICovXG4gICAgaWYgKHRoaW5nICYmICh0aGlzLmZyb21QbGF5ZXIgfHxcbiAgICAgICAgICAgIHRoaW5nLnR5cGUgPT09ICdQbGF5ZXInIHx8IHRoaW5nLnR5cGUgPT09ICdTY3JpcHRhYmxlJyB8fCB0aGluZy50eXBlID09PSAnQnJlYWthYmxlV2FsbCcpKSB7XG4gICAgICAgIHRoaW5nLnNlbmRNZXNzYWdlKCdTSE9UJyk7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIE1ha2UgdGhpcyBCdWxsZXQgcmVhY3QgdG8gaXRzIGVudmlyb25tZW50IGJ5IGxvb2tpbmcgZm9yIHJpY29jaGV0IHBvaW50cyBvciByZW1vdmluZyBpdHNlbGZcbiAqIGZyb20gdGhlIGJvYXJkLlxuICovXG5CdWxsZXQucHJvdG90eXBlLnJlYWN0ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gSWYgd2UgYXJlIHN0aWxsIGJsb2NrZWQgKGJ5IGEgbm9uLXBsYXllciksIGNoZWNrIGlmIHdlIHNob3VsZCByaWNvY2hldFxuICAgIHZhciB0aGluZyA9IHRoaXMuZ2V0QWRqYWNlbnRUaGluZyh0aGlzLmRpcmVjdGlvbik7XG4gICAgaWYgKHRoaW5nICYmIHRoaW5nLnR5cGUgIT09ICdQbGF5ZXInKSB7XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSByaWNvY2hldCBpbiBvdXIgZGlyZWN0aW9uLCByZWZsZWN0IGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gaWYgd2UncmUgbm90IGJsb2NrZWQgdGhhdCB3YXlcbiAgICAgICAgaWYgKHRoaW5nLnR5cGUgPT09ICdSaWNvY2hldCcpIHtcbiAgICAgICAgICAgIHRoaXMucmljb2NoZXQoRGlyZWN0aW9uLm9wcG9zaXRlKHRoaXMuZGlyZWN0aW9uKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJpY29jaGV0IHRvIG91ciByaWdodCwgcmVmbGVjdCB0byB0aGUgbGVmdCBpZiB3ZSdyZSBub3QgYmxvY2tlZCB0aGF0IHdheVxuICAgICAgICB0aGluZyA9IHRoaXMuZ2V0QWRqYWNlbnRUaGluZyhEaXJlY3Rpb24uY2xvY2t3aXNlKHRoaXMuZGlyZWN0aW9uKSk7XG4gICAgICAgIGlmICh0aGluZyAmJiB0aGluZy50eXBlID09PSAnUmljb2NoZXQnKSB7XG4gICAgICAgICAgICB0aGlzLnJpY29jaGV0KERpcmVjdGlvbi5jb3VudGVyQ2xvY2t3aXNlKHRoaXMuZGlyZWN0aW9uKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJpY29jaGV0IHRvIG91ciBsZWZ0LCByZWZsZWN0IHRvIG91ciByaWdodCBpZiB3ZSdyZSBub3QgYmxvY2tlZCB0aGF0IHdheVxuICAgICAgICB0aGluZyA9IHRoaXMuZ2V0QWRqYWNlbnRUaGluZyhEaXJlY3Rpb24uY291bnRlckNsb2Nrd2lzZSh0aGlzLmRpcmVjdGlvbikpO1xuICAgICAgICBpZiAodGhpbmcgJiYgdGhpbmcudHlwZSA9PT0gJ1JpY29jaGV0Jykge1xuICAgICAgICAgICAgdGhpcy5yaWNvY2hldChEaXJlY3Rpb24uY2xvY2t3aXNlKHRoaXMuZGlyZWN0aW9uKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSByZW1vdmUgdGhpcyBidWxsZXQuLi5cbiAgICB0aGlzLnJlbW92ZSgpO1xuXG59O1xuXG4vKipcbiAqIENoYW5nZSB0aGUgZGlyZWN0aW9uIG9mIHRoaXMgYnVsbGV0ICh3aXRoIGEgcmljb2NoZXQgc291bmQpIGlmIHdlJ3JlIGNhcGFibGUgb2YgbW92aW5nIHRoYXQgd2F5LlxuICpcbiAqIEBwYXJhbSBBIGRpcmVjdGlvbiBpbiB3aGljaCB0byByaWNvY2hldFxuICovXG5CdWxsZXQucHJvdG90eXBlLnJpY29jaGV0ID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuXG4gICAgLy8gQ2hhbmdlIGRpcmVjdGlvbnNcbiAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcblxuICAgIC8vIElmIHdlJ3JlIGZyZWUgdG8gcmljb2NoZXQgaW4gdGhlIHByb3ZpZGVkIGRpcmVjdGlvbi4uLlxuICAgIGlmICh0aGlzLm1vdmUoZGlyZWN0aW9uLCB0cnVlKSkge1xuXG4gICAgICAgIC8vIFBsYXkgb3VyIHJpY29jaGV0IHNvdW5kXG4gICAgICAgIHRoaXMucGxheSgnOScsIGZhbHNlLCB0cnVlKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gV2UncmUgbm90IGZyZWUgdG8gUmljb2NoZXQsIHNvIGF0dGFjayBhbmQgcmVtb3ZlIG91cnNlbHZlc1xuICAgICAgICB0aGlzLmF0dGFjaygpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuXG4gICAgfVxufTtcblxuLyoqXG4gKiBBdHRlbXB0cyB0byBwdXNoIHRoaXMgQnVsbGV0LlxuICovXG5CdWxsZXQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZW1vdmUoKTtcbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBDZW50aXBlZGUgaXMgYW4gVXBkYXRlYWJsZVRoaW5nIGNhcGFibGUgb2YgY2hhaW5pbmcgaXRzZWxmIHRvIG90aGVyXG4gKiBDZW50aXBlZGVzIGFuZCBtb3ZpbmcgYXJvdW5kIHRoZSBib2FyZCBhcyBhIHVuaXQuXG4gKlxuICogQHBhcmFtIGJvYXJkIEFuIG93bmVyIGJvYXJkIGZvciB0aGlzIENlbnRpcGVkZVxuICovXG5mdW5jdGlvbiBDZW50aXBlZGUoYm9hcmQpIHtcbiAgICBVcGRhdGVhYmxlVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IDc5O1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IENvbG9ycy5CcmlnaHRCbHVlO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNwZWVkID0gMztcbiAgICB0aGlzLmZvbGxvd2VyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuaGVhZCA9IGZhbHNlO1xuICAgIHRoaXMubGVhZGVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubGlua2VkID0gZmFsc2U7XG4gICAgdGhpcy5maXJzdFRpY2sgPSB0cnVlO1xuICAgIHRoaXMub3JpZW50YXRpb24gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kZXZpYW5jZSA9IDA7XG4gICAgdGhpcy5pbnRlbGxpZ2VuY2UgPSAwO1xufVxuQ2VudGlwZWRlLnByb3RvdHlwZSA9IG5ldyBVcGRhdGVhYmxlVGhpbmcoKTtcbkNlbnRpcGVkZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDZW50aXBlZGU7XG5cbi8qKlxuICogU2VyaWFsaXplcyB0aGlzIFRoaW5nIHRvIGFuIG9iamVjdCBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKiBAcmV0dXJuIEEgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIHRoaXMgVGhpbmcuXG4gKi9cbkNlbnRpcGVkZS5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBVcGRhdGVhYmxlVGhpbmcucHJvdG90eXBlLnNlcmlhbGl6ZS5jYWxsKHRoaXMpO1xuICAgIHJlc3VsdC5oZWFkID0gdGhpcy5oZWFkO1xuICAgIHJlc3VsdC5kZXZpYW5jZSA9IHRoaXMuZGV2aWFuY2U7XG4gICAgcmVzdWx0LmludGVsbGlnZW5jZSA9IHRoaXMuaW50ZWxsaWdlbmNlO1xuICAgIGlmICh0aGlzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgIHJlc3VsdC5vcmllbnRhdGlvbiA9IERpcmVjdGlvbi5nZXRTaG9ydE5hbWUodGhpcy5vcmllbnRhdGlvbik7XG4gICAgfVxuICAgIGlmICh0aGlzLmZvbGxvd2VyKSB7XG4gICAgICAgIHJlc3VsdC5uZXh0U2VnbWVudCA9IERpcmVjdGlvbi5nZXRTaG9ydE5hbWUodGhpcy5wb2ludC5kaXJlY3Rpb25Ubyh0aGlzLmZvbGxvd2VyLnBvaW50KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERlc2VyaWFsaXplcyBhIGdpdmVuIGRhdGEgb2JqZWN0IGFuZCB1cGRhdGUncyB0aGlzIFRoaW5nJ3Mgc3RhdGUgdG9cbiAqIHRoYXQgZGF0YS5cbiAqXG4gKiBAcGFyYW0gZGF0YSBBbiBvYmplY3QgdG8gYmUgZGVzZXJpYWxpemVkIGludG8gdGhpcyBUaGluZy5cbiAqL1xuQ2VudGlwZWRlLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHRoaXMuaGVhZCA9IGRhdGEuaGVhZDtcbiAgICB0aGlzLmludGVsbGlnZW5jZSA9IGRhdGEuaW50ZWxsaWdlbmNlO1xuICAgIHRoaXMuZGV2aWFuY2UgPSBkYXRhLmRldmlhbmNlO1xuICAgIGlmIChkYXRhLm9yaWVudGF0aW9uKSB7XG4gICAgICAgIHRoaXMub3JpZW50YXRpb24gPSBEaXJlY3Rpb24uZnJvbU5hbWUoZGF0YS5vcmllbnRhdGlvbik7XG4gICAgfVxuICAgIGlmIChkYXRhLm5leHRTZWdtZW50KSB7XG4gICAgICAgIHRoaXMubmV4dFNlZ21lbnQgPSBEaXJlY3Rpb24uZnJvbU5hbWUoZGF0YS5uZXh0U2VnbWVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRldmlhbmNlID4gMTApIHtcbiAgICAgICAgdGhpcy5kZXZpYW5jZSA9IDEwO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnRlbGxpZ2VuY2UgPiAxMCkge1xuICAgICAgICB0aGlzLmludGVsbGlnZW5jZSA9IDEwO1xuICAgIH1cbiAgICBpZiAodGhpcy5oZWFkKSB7XG4gICAgICAgIHRoaXMuc3ByaXRlSW5kZXggPSAyMzM7XG4gICAgfVxuICAgIHRoaXMuY3ljbGVDb3VudCA9IDA7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhbiB1bmxpbmtlZCwgbm9uLWhlYWQsIGFkamFjZW50IENlbnRpcGVkZSBzZWdtZW50LlxuICpcbiAqIEByZXR1cm4gQW4gdW5saW5la2VkLCBub24taGVhZCwgYWRqYWNlbnQgQ2VudGlwZWRlIHNlZ21lbnQuXG4gKi9cbkNlbnRpcGVkZS5wcm90b3R5cGUuZ2V0QWRqYWNlbnRTZWdtZW50ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGEgcHJvdmlkZWQgY2FuZGlkYXRlIFRoaW5nIGlzIGEgQ2VudGlwZWRlLCBpc1xuICAgICAqIHVubGlua2VkLCBhbmQgaXMgbm90IGEgaGVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYW5kaWRhdGUgYSBUaGluZ1xuICAgICAqIEByZXR1cm4gdHJ1ZSBpZiBhIGNhbmRpZGF0ZSBpcyBhbiB1bmxpbmtlZCwgbm9uLWhlYWQgQ2VudGlwZWRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmxpbmtlZFNlZ21lbnQoY2FuZGlkYXRlKSB7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLnR5cGUgPT09ICdDZW50aXBlZGUnICYmICFjYW5kaWRhdGUubGlua2VkICYmICFjYW5kaWRhdGUubmV4dFNlZ21lbnQgJiYgIWNhbmRpZGF0ZS5oZWFkO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQ7XG5cbiAgICAvLyBJZiBhIG5leHQgc2VnbWVudCBkaXJlY3Rpb24gd2FzIGV4cGxpY2l0bHkgZGVmaW5lZC4uLlxuICAgIGlmICh0aGlzLm5leHRTZWdtZW50KSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuYm9hcmQuZ2V0VGlsZSh0aGlzLnBvaW50LmFkZCh0aGlzLm5leHRTZWdtZW50KSk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLm5leHRTZWdtZW50O1xuXG4gICAgICAgIC8vIFNhbml0eSBjaGVjayBiZWZvcmUgcmV0dXJuaW5nIG91ciByZXN1bHRcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQudHlwZSA9PT0gJ0NlbnRpcGVkZScgJiYgIXJlc3VsdC5oZWFkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBUcnkgTm9ydGhcbiAgICByZXN1bHQgPSB0aGlzLmJvYXJkLmdldFRpbGUodGhpcy5wb2ludC5hZGQoRGlyZWN0aW9uLk5vcnRoKSk7XG4gICAgaWYgKGlzVW5saW5rZWRTZWdtZW50KHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBFYXN0XG4gICAgcmVzdWx0ID0gdGhpcy5ib2FyZC5nZXRUaWxlKHRoaXMucG9pbnQuYWRkKERpcmVjdGlvbi5FYXN0KSk7XG4gICAgaWYgKGlzVW5saW5rZWRTZWdtZW50KHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBTb3V0aFxuICAgIHJlc3VsdCA9IHRoaXMuYm9hcmQuZ2V0VGlsZSh0aGlzLnBvaW50LmFkZChEaXJlY3Rpb24uU291dGgpKTtcbiAgICBpZiAoaXNVbmxpbmtlZFNlZ21lbnQocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8vIFdlc3RcbiAgICByZXN1bHQgPSB0aGlzLmJvYXJkLmdldFRpbGUodGhpcy5wb2ludC5hZGQoRGlyZWN0aW9uLldlc3QpKTtcbiAgICBpZiAoaXNVbmxpbmtlZFNlZ21lbnQocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG5cbn07XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgbGlua3MgYWRqYWNlbnQgc2VnbWVudHMgdG8gYSBwcm92aWRlZCBDZW50aXBlZGUuXG4gKlxuICogQHBhcmFtIGxlYWRlciBhIENlbnRpcGVkZVxuICovXG5DZW50aXBlZGUucHJvdG90eXBlLmxpbmtTZWdtZW50cyA9IGZ1bmN0aW9uIChsZWFkZXIpIHtcblxuICAgIHRoaXMubGlua2VkID0gdHJ1ZTtcbiAgICB0aGlzLmxlYWRlciA9IGxlYWRlcjtcblxuICAgIGlmICh0aGlzLmxlYWRlcikge1xuICAgICAgICB0aGlzLmRldmlhbmNlID0gbGVhZGVyLmRldmlhbmNlO1xuICAgICAgICB0aGlzLmludGVsbGlnZW5jZSA9IGxlYWRlci5pbnRlbGxpZ2VuY2U7XG4gICAgICAgIHRoaXMuY3ljbGVDb3VudCA9IGxlYWRlci5jeWNsZUNvdW50O1xuICAgICAgICB0aGlzLnNwZWVkID0gbGVhZGVyLnNwZWVkO1xuICAgIH1cblxuICAgIHRoaXMuZm9sbG93ZXIgPSB0aGlzLmdldEFkamFjZW50U2VnbWVudCgpO1xuXG4gICAgaWYgKHRoaXMuZm9sbG93ZXIpIHtcblxuICAgICAgICBpZiAodGhpcy5oZWFkKSB7XG4gICAgICAgICAgICAvLyBDaG9vc2UgYSBuYXR1cmFsIGluaXRpYWwgb3JpZW50YXRpb25cbiAgICAgICAgICAgIHRoaXMub3JpZW50YXRpb24gPSB0aGlzLmZvbGxvd2VyLnBvaW50LmRpcmVjdGlvblRvKHRoaXMucG9pbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mb2xsb3dlci5saW5rU2VnbWVudHModGhpcyk7XG5cbiAgICB9XG5cbn07XG5cbi8qKlxuICogUmV2ZXJzZXMgdGhlIGZvbGxvd2VyL2xlYWRlciByZWxhdGlvbnNoaXAgb2YgdGhpcyBDZW50aXBlZGVcbiAqIGFuZCBpdHMgZm9sbG93ZXJzLlxuICovXG5DZW50aXBlZGUucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG5cblxuICAgIHZhciBuZXh0U2VnbWVudCA9IHRoaXMuZm9sbG93ZXIsXG4gICAgICAgIG9sZExlYWRlciA9IHRoaXMubGVhZGVyO1xuXG4gICAgaWYgKHRoaXMuaGVhZCkge1xuICAgICAgICB0aGlzLmhlYWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zcHJpdGVJbmRleCA9IDc5O1xuICAgIH1cblxuICAgIHRoaXMubGVhZGVyID0gdGhpcy5mb2xsb3dlcjtcbiAgICB0aGlzLmZvbGxvd2VyID0gb2xkTGVhZGVyO1xuXG4gICAgaWYgKG5leHRTZWdtZW50KSB7XG4gICAgICAgIG5leHRTZWdtZW50LnJldmVyc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJlY29tZUhlYWQoKTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogVHVybnMgdGhpcyBDZW50aXBlZGUgaW50byBhIGhlYWQgc2VnbWVudC5cbiAqL1xuQ2VudGlwZWRlLnByb3RvdHlwZS5iZWNvbWVIZWFkID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdGhpcy5oZWFkID0gdHJ1ZTtcbiAgICB0aGlzLnNwcml0ZUluZGV4ID0gMjMzO1xuXG4gICAgdGhpcy5jeWNsZUNvdW50ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5zcGVlZCk7XG5cbn07XG5cbi8qKlxuICogTW92ZXMgdGhpcyBDZW50aXBlZGUgaW4gYSBnaXZlbiBkaXJlY3Rpb24uIElmIGEgUGxheWVyIGlzXG4gKiBsb2NhdGVkIGluIHRoYXQgZGlyZWN0aW9uLCB0aGlzIENlbnRpcGVkZSB3aWxsIGJlIGRlbGV0ZWRcbiAqIGFuZCB0aGUgcGxheWVyIHdpbGwgYmUgc2VudCBhIFNIT1QgbWVzc2FnZSwgb3RoZXJ3aXNlIHRoaXNcbiAqIENlbnRpcGVkZSBhbmQgaXRzIGZvbGxvd2VycyB3aWxsIG1vdmUgb25lIHN0ZXAuXG4gKlxuICogQHBhcmFtIGRpcmVjdGlvbiBBIGRpcmVjdGlvbiBpbiB3aGljaCB0byBtb3ZlLiBUaGlzIGRpcmVjdGlvblxuICogaXMgZXhwZWN0ZWQgdG8gYmUgZnJlZSBmb3IgbW92ZW1lbnQsIGJ1dCBtYXkgY29udGFpbiBhIFBsYXllci5cbiAqL1xuQ2VudGlwZWRlLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuXG4gICAgdmFyIG15UGxhY2UgPSB0aGlzLnBvaW50LmNsb25lKCk7XG5cbiAgICAvLyBJZiB3ZSdyZSBhIGhlYWQsIGNoZWNrIHRvIHNlZSBpZiB3ZSdyZSBhdHRhY2tpbmcgdGhlIHBsYXllclxuICAgIGlmICh0aGlzLmhlYWQgJiYgdGhpcy5pc1BsYXllckFkamFjZW50KGRpcmVjdGlvbikpIHtcbiAgICAgICAgdGhpcy5ib2FyZC5wbGF5ZXIuc2VuZE1lc3NhZ2UoJ1NIT1QnKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYm9hcmQubW92ZVRpbGUodGhpcy5wb2ludCwgdGhpcy5wb2ludC5hZGQoZGlyZWN0aW9uKSwgdHJ1ZSk7XG5cbiAgICBpZiAodGhpcy5mb2xsb3dlcikge1xuICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLmZvbGxvd2VyLnBvaW50LmRpcmVjdGlvblRvKG15UGxhY2UpO1xuICAgICAgICB0aGlzLmZvbGxvd2VyLm1vdmUoZGlyZWN0aW9uKTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogUmVxdWVzdHMgdGhhdCB0aGlzIENlbnRpcGVkZSBiZSBwdXNoZWQgaW4gYSBnaXZlbiBkaXJlY3Rpb24uIFNpbmNlXG4gKiBDZW50aXBlZGVzIGNhbid0IGJlIHB1c2hlZCwgdGhlIENlbnRpcGVkZSB3aWxsIGJlIGRlbGV0ZWQgaW5zdGVhZC5cbiAqXG4gKiBAcGFyYW0gZGlyZWN0aW9uIEEgZ2l2ZW4gZGlyZWN0aW9uIHRvIHB1c2ggdGhpcyBDZW50aXBlZGUuXG4gKi9cbkNlbnRpcGVkZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBsYXkoJ3QrYy0tLWMrKysrYy0tYycpO1xuICAgIHRoaXMucmVtb3ZlKCk7XG59O1xuXG4vKipcbiAqIERlbGV0ZXMgdGhpcyBDZW50aXBlZGUgZnJvbSBpdHMgQm9hcmQuIEFueSBsZWFkZXIgYW5kIGZvbGxvd2VyXG4gKiBDZW50aXBlZGVzIHdpbGwgYmUgdXBkYXRlcyB0byBubyBsb25nZXIgY29udGFpbiB0aGlzIENlbnRpcGVkZVxuICogYXMgd2VsbC5cbiAqL1xuQ2VudGlwZWRlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICBpZiAodGhpcy5sZWFkZXIpIHtcbiAgICAgICAgdGhpcy5sZWFkZXIuZm9sbG93ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0aGlzLmZvbGxvd2VyKSB7XG4gICAgICAgIHRoaXMuZm9sbG93ZXIubGVhZGVyID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcyk7XG5cbn07XG5cbi8qKlxuICogU2VuZHMgYSBwcm92aWRlZCBtZXNzYWdlIHRvIHRoaXMgQ2VudGlwZWRlLiBJZiBhIFNIT1QgbWVzc2FnZVxuICogaXMgcmVjZWl2ZWQsIHRoZW4gdGhpcyBDZW50aXBlZGUgd2lsbCBiZSBkZWxldGVkIGZyb20gaXRzIGJvYXJkLlxuICogSWYgYSBUT1VDSCBtZXNzYWdlIGlzIHJlY2VpdmVkLCB0aGVuIHRoZSBib2FyZCdzIHBsYXllciB3aWxsIGJlXG4gKiBzZW50IGEgU0hPVCBtZXNzYWdlIGFuZCB0aGlzIENlbnRpcGVkZSB3aWxsIGJlIGRlbGV0ZWQuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgQSBtZXNzYWdlIHRvIGJlIHNlbnQgdG8gdGhpcyBDZW50aXBlZGUuXG4gKi9cbkNlbnRpcGVkZS5wcm90b3R5cGUuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlID09PSAnU0hPVCcgfHwgbWVzc2FnZSA9PT0gJ0JPTUJFRCcpIHtcbiAgICAgICAgdGhpcy5wbGF5KCd0K2MtLS1jKysrK2MtLWMnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5hZGp1c3RDb3VudGVyKCdTQ09SRScsIDEwKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UgPT09ICdUT1VDSCcpIHtcbiAgICAgICAgdGhpcy5ib2FyZC5wbGF5ZXIuc2VuZE1lc3NhZ2UoJ1NIT1QnKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhpcyBDZW50aXBlZGUgc2hvdWxkIGRldmlhdGUgZnJvbVxuICogaXRzIG9yaWVudGF0aW9uLiBUaGlzIGlzIGEgcHJvYmFiaWxpdHkgYmFzZWQgb24gdGhpc1xuICogQ2VudGlwZWRlcyBkZXZpYW5jZSBwcm9wZXJ0eS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhpcyBDZW50aXBlZGUgc2hvdWxkIGRldmlhdGUgbm93LCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkNlbnRpcGVkZS5wcm90b3R5cGUuZGV2aWF0ZSA9IGZ1bmN0aW9uICgpIHtcblxuICAgIGlmICh0aGlzLmRldmlhbmNlIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciByYW5kb21WYWx1ZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIwKTtcbiAgICByZXR1cm4gcmFuZG9tVmFsdWUgPD0gdGhpcy5kZXZpYW5jZTtcblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoaXMgQ2VudGlwZWRlIHNob3VsZCBzZWVrIHRoZSBwbGF5ZXJcbiAqIGF0IHRoaXMgbW9tZW50LCBvciBpZiBpdCBzaG91bGQgbW92ZSByYW5kb21seS4gVGhpcyBpcyBhXG4gKiBwcm9iYWJpbGl0eSBiYXNlZCBvbiB0aGlzIENlbnRpcGVkZSdzIGludGVsbGlnZW5jZSBwcm9wZXJ0eS5cbiAqL1xuQ2VudGlwZWRlLnByb3RvdHlwZS5zZWVrUGxheWVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKHRoaXMuaW50ZWxsaWdlbmNlIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzUGxheWVyQWxpZ25lZCgpKSB7XG5cbiAgICAgICAgdmFyIHJhbmRvbVZhbHVlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApO1xuICAgICAgICByZXR1cm4gcmFuZG9tVmFsdWUgPD0gdGhpcy5pbnRlbGxpZ2VuY2U7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG5cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSB0aWNrLlxuICovXG5DZW50aXBlZGUucHJvdG90eXBlLmRvVGljayA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBkaXJlY3Rpb24sXG4gICAgICAgIGF2YWlsYWJsZURpcmVjdGlvbnM7XG5cbiAgICBpZiAodGhpcy5maXJzdFRpY2spIHtcbiAgICAgICAgdGhpcy5maXJzdFRpY2sgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIElmIHdlIGFyZW4ndCBhIGhlYWQgYW5kIGRvbid0IGhhdmUgYSBsZWFkZXIsIGJlY29tZSBvbmVcbiAgICAgICAgaWYgKCF0aGlzLmhlYWQgJiYgdGhpcy5sZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5iZWNvbWVIZWFkKCk7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIENlbnRpcGVkZXMgb25seSB1cGRhdGUgaWYgdGhleSBhcmUgYSBoZWFkXG4gICAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGhhdmVuJ3QgaW5pdGlhbGl6ZWQgb3VyIHNlZ21lbnRzLCBkbyBpdCBub3dcbiAgICBpZiAoIXRoaXMubGlua2VkKSB7XG4gICAgICAgIHRoaXMubGlua1NlZ21lbnRzKCk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgdG8gc2VlIHRoZSBwbGF5ZXIgbm93Li4uXG4gICAgaWYgKHRoaXMuc2Vla1BsYXllcigpKSB7XG5cbiAgICAgICAgLy8gU2V0IG91ciBvcmllbnRhdGlvbiB0b3dhcmQgdGhlIHBsYXllclxuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gdGhpcy5nZXRQbGF5ZXJEaXJlY3Rpb24oKTtcblxuICAgIH1cblxuICAgIC8vIElmIHdlJ3ZlIGdvdCBhbiBvcmllbnRhdGlvbiBhbmQgaXQncyBhdHRhY2thYmxlLCBtb3ZlIHRoZXJlXG4gICAgaWYgKHRoaXMub3JpZW50YXRpb24gJiYgdGhpcy5pc0F0dGFja2FibGUodGhpcy5vcmllbnRhdGlvbikgJiYgIXRoaXMuZGV2aWF0ZSgpKSB7XG4gICAgICAgIHRoaXMubW92ZSh0aGlzLm9yaWVudGF0aW9uKTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIEZpbmQgYWxsIGF0dGFja2FibGUgZGlyZWN0aW9uc1xuICAgICAgICBhdmFpbGFibGVEaXJlY3Rpb25zID0gdGhpcy5nZXRBdHRhY2thYmxlRGlyZWN0aW9ucygpO1xuXG4gICAgICAgIC8vIElmIGRpcmVjdGlvbnMgYXJlIGF2YWlsYWJsZS4uLlxuICAgICAgICBpZiAoYXZhaWxhYmxlRGlyZWN0aW9ucy5sZW5ndGggPiAwKSB7XG5cbiAgICAgICAgICAgIC8vIFBpY2sgb25lIGFuZCByZW1lbWJlciBpdCBhcyBvdXIgb3JpZW50YXRpb25cbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IERpcmVjdGlvbi5yYW5kb20oYXZhaWxhYmxlRGlyZWN0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICAgICAgdGhpcy5tb3ZlKGRpcmVjdGlvbik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmV2ZXJzZSgpO1xuICAgICAgICB9XG5cbiAgICB9XG5cblxufTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBDb252ZXlvcihib2FyZCkge1xuICAgIFVwZGF0ZWFibGVUaGluZy5jYWxsKHRoaXMsIGJvYXJkKTtcbiAgICB0aGlzLmNsb2Nrd2lzZSA9IHRydWU7XG4gICAgdGhpcy5hbmltYXRpb25JbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIENvbnZleW9yLmFuaW1hdGlvbkZyYW1lcy5sZW5ndGggLSAxKTtcbiAgICB0aGlzLnNwcml0ZUluZGV4ID0gMTc5O1xufVxuQ29udmV5b3IucHJvdG90eXBlID0gbmV3IFVwZGF0ZWFibGVUaGluZygpO1xuQ29udmV5b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udmV5b3I7XG5Db252ZXlvci5hbmltYXRpb25GcmFtZXMgPSBbMTc5LCA0NywgNDUsIDkyXTtcbkNvbnZleW9yLk1vdmVBY3Rpb24gPSB7TU9WRTogMSwgVEVOVEFUSVZFOiAyfTtcblxuQ29udmV5b3IucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5zZXJpYWxpemUuY2FsbCh0aGlzKTtcbiAgICByZXN1bHQuY2xvY2t3aXNlID0gdGhpcy5jbG9ja3dpc2U7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkNvbnZleW9yLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHRoaXMuY2xvY2t3aXNlID0gZGF0YS5jbG9ja3dpc2U7XG59O1xuXG5Db252ZXlvci5wcm90b3R5cGUubWFya1BhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuXG4gICAgdmFyIGluZGV4LFxuICAgICAgICB0aWxlLFxuICAgICAgICBvYnN0YWNsZSxcbiAgICAgICAgTW92ZUFjdGlvbiA9IENvbnZleW9yLk1vdmVBY3Rpb247XG5cbiAgICBmb3IgKGluZGV4ID0gcGF0aC5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleCAtPSAxKSB7XG5cbiAgICAgICAgLy8gR3JhYiBvdXIgdGlsZSBvZiBpbnRlcmVzdFxuICAgICAgICB0aWxlID0gdGhpcy5ib2FyZC5nZXRUaWxlKHBhdGhbaW5kZXhdKTtcblxuICAgICAgICAvLyBJZiBpdCBleGlzdHMgYW5kIGlzIGNvbnZleWFibGUuLi5cbiAgICAgICAgaWYgKHRpbGUgJiYgdGlsZS5jb252ZXlhYmxlKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIHN0YXJ0aW5nLCBvdXIgbW92ZSBpcyB0ZW50YXRpdmUgb24gdGhlIGZpbmFsIG1vdmVcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gcGF0aC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgcGF0aFtpbmRleF0uYWN0aW9uID0gTW92ZUFjdGlvbi5URU5UQVRJVkU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBhdGggaXNuJ3Qgb2ZmIHRoZSBib2FyZC4uLlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5ib2FyZC5pc091dHNpZGUocGF0aFtpbmRleCArIDFdKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdyYWIgb3VyIG9ic3RhY2xlXG4gICAgICAgICAgICAgICAgICAgIG9ic3RhY2xlID0gdGhpcy5ib2FyZC5nZXRUaWxlKHBhdGhbaW5kZXggKyAxXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gb2JzdGFjbGUsIG9yIGl0J3Mgc3VycmVuZGVyYWJsZSwgdGhlbiBzZXQgb3VyIGFjdGlvbiB0byBNT1ZFXG4gICAgICAgICAgICAgICAgICAgIGlmICghb2JzdGFjbGUgfHwgKCFvYnN0YWNsZS5jb252ZXlhYmxlICYmIG9ic3RhY2xlLnN1cnJlbmRlcmFibGUpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhbaW5kZXhdLmFjdGlvbiA9IE1vdmVBY3Rpb24uTU9WRTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUYWtlIHRoZSBzYW1lIGFjdGlvbiBhcyBvdXIgcHJldmlvdXMgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aFtpbmRleF0uYWN0aW9uID0gcGF0aFtpbmRleCArIDFdLmFjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGxhc3QgcG9zaXRpb24gaXMgZnJlZSwgb3IgaWYgdGhlIGxhc3QgcGF0aCBhY3Rpb24gaXMgTU9WRSBvciBURU5UQVRJVkUuLi5cbiAgICBpZiAodGhpcy5ib2FyZC5pc0ZyZWVPclN1cnJlbmRlcmFibGUocGF0aFswXSkgfHwgcGF0aFswXS5hY3Rpb24gPT09IE1vdmVBY3Rpb24uTU9WRSB8fCBwYXRoWzBdLmFjdGlvbiA9PT0gTW92ZUFjdGlvbi5URU5UQVRJVkUpIHtcblxuICAgICAgICAvLyBDb252ZXJ0IGFsbCBURU5UQVRJVkUgYWN0aW9ucyB0byBNT1ZFIGFjdGlvbnNcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcGF0aC5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2luZGV4XS5hY3Rpb24gPT09IE1vdmVBY3Rpb24uVEVOVEFUSVZFKSB7XG4gICAgICAgICAgICAgICAgcGF0aFtpbmRleF0uYWN0aW9uID0gTW92ZUFjdGlvbi5NT1ZFO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG5cbn07XG5cbkNvbnZleW9yLnByb3RvdHlwZS5leGVjdXRlUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG5cbiAgICB2YXIgaW5kZXgsXG4gICAgICAgIGhlbGRUaGluZyxcbiAgICAgICAgdGhpbmc7XG5cbiAgICBmb3IgKGluZGV4ID0gcGF0aC5sZW5ndGggLSAxOyBpbmRleCA+PSAwOyBpbmRleCAtPSAxKSB7XG5cbiAgICAgICAgaWYgKHBhdGhbaW5kZXhdLmFjdGlvbiA9PT0gQ29udmV5b3IuTW92ZUFjdGlvbi5NT1ZFKSB7XG5cbiAgICAgICAgICAgIHRoaW5nID0gdGhpcy5ib2FyZC5nZXRUaWxlKHBhdGhbaW5kZXhdKTtcbiAgICAgICAgICAgIHRoaXMuYm9hcmQuZGVsZXRlVGlsZShwYXRoW2luZGV4XSk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gcGF0aC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgaGVsZFRoaW5nID0gdGhpbmc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9hcmQuYWRkVGhpbmcocGF0aFtpbmRleCArIDFdLCB0aGluZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKGhlbGRUaGluZykge1xuICAgICAgICB0aGlzLmJvYXJkLmFkZFRoaW5nKHBhdGhbMF0sIGhlbGRUaGluZyk7XG4gICAgfVxuXG59O1xuXG5Db252ZXlvci5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHBhdGg7XG5cbiAgICBpZiAodGhpcy5jbG9ja3dpc2UpIHtcblxuICAgICAgICB0aGlzLmFuaW1hdGlvbkluZGV4ICs9IDE7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkluZGV4ID49IENvbnZleW9yLmFuaW1hdGlvbkZyYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uSW5kZXggPSAwO1xuICAgICAgICB9XG5cblxuICAgICAgICBwYXRoID0gW1xuICAgICAgICAgICAgbmV3IFBvaW50KHRoaXMucG9pbnQueCAtIDEsIHRoaXMucG9pbnQueSAtIDEpLFxuICAgICAgICAgICAgbmV3IFBvaW50KHRoaXMucG9pbnQueCwgdGhpcy5wb2ludC55IC0gMSksXG4gICAgICAgICAgICBuZXcgUG9pbnQodGhpcy5wb2ludC54ICsgMSwgdGhpcy5wb2ludC55IC0gMSksXG4gICAgICAgICAgICBuZXcgUG9pbnQodGhpcy5wb2ludC54ICsgMSwgdGhpcy5wb2ludC55KSxcbiAgICAgICAgICAgIG5ldyBQb2ludCh0aGlzLnBvaW50LnggKyAxLCB0aGlzLnBvaW50LnkgKyAxKSxcbiAgICAgICAgICAgIG5ldyBQb2ludCh0aGlzLnBvaW50LngsIHRoaXMucG9pbnQueSArIDEpLFxuICAgICAgICAgICAgbmV3IFBvaW50KHRoaXMucG9pbnQueCAtIDEsIHRoaXMucG9pbnQueSArIDEpLFxuICAgICAgICAgICAgbmV3IFBvaW50KHRoaXMucG9pbnQueCAtIDEsIHRoaXMucG9pbnQueSlcbiAgICAgICAgXTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgdGhpcy5hbmltYXRpb25JbmRleCAtPSAxO1xuICAgICAgICBpZiAodGhpcy5hbmltYXRpb25JbmRleCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uSW5kZXggPSBDb252ZXlvci5hbmltYXRpb25GcmFtZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhdGggPSBbXG4gICAgICAgICAgICBuZXcgUG9pbnQodGhpcy5wb2ludC54IC0gMSwgdGhpcy5wb2ludC55IC0gMSksXG4gICAgICAgICAgICBuZXcgUG9pbnQodGhpcy5wb2ludC54IC0gMSwgdGhpcy5wb2ludC55KSxcbiAgICAgICAgICAgIG5ldyBQb2ludCh0aGlzLnBvaW50LnggLSAxLCB0aGlzLnBvaW50LnkgKyAxKSxcbiAgICAgICAgICAgIG5ldyBQb2ludCh0aGlzLnBvaW50LngsIHRoaXMucG9pbnQueSArIDEpLFxuICAgICAgICAgICAgbmV3IFBvaW50KHRoaXMucG9pbnQueCArIDEsIHRoaXMucG9pbnQueSArIDEpLFxuICAgICAgICAgICAgbmV3IFBvaW50KHRoaXMucG9pbnQueCArIDEsIHRoaXMucG9pbnQueSksXG4gICAgICAgICAgICBuZXcgUG9pbnQodGhpcy5wb2ludC54ICsgMSwgdGhpcy5wb2ludC55IC0gMSksXG4gICAgICAgICAgICBuZXcgUG9pbnQodGhpcy5wb2ludC54LCB0aGlzLnBvaW50LnkgLSAxKVxuICAgICAgICBdO1xuXG4gICAgfVxuXG4gICAgdGhpcy5tYXJrUGF0aChwYXRoKTtcbiAgICB0aGlzLmV4ZWN1dGVQYXRoKHBhdGgpO1xuXG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IENvbnZleW9yLmFuaW1hdGlvbkZyYW1lc1t0aGlzLmFuaW1hdGlvbkluZGV4XTtcblxufTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIERvb3IgaXMgYSBUaGluZyB0aGF0IGFjdHMgYXMgYW4gb2JzdGFjbGUgdW5sZXNzIGFuIGFzc29jaWF0ZWQgS2V5IGhhcyBiZWVuXG4gKiBjb2xsZWN0ZWQgZmlyc3QuXG4gKi9cbmZ1bmN0aW9uIERvb3IoYm9hcmQpIHtcbiAgICBUaGluZy5jYWxsKHRoaXMsIGJvYXJkKTtcbiAgICB0aGlzLnNwcml0ZUluZGV4ID0gMTA7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyaWdodFdoaXRlO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IENvbG9ycy5CbHVlO1xufVxuRG9vci5wcm90b3R5cGUgPSBuZXcgVGhpbmcoKTtcbkRvb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRG9vcjtcblxuRG9vci5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuXG4gICAgVGhpbmcucHJvdG90eXBlLmRlc2VyaWFsaXplLmNhbGwodGhpcywgZGF0YSk7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyaWdodFdoaXRlO1xuXG4gICAgLy8gU2FuaXRpemUgdGhlIGNvbG9yIGlmIG5lY2Vzc2FyeVxuICAgIGlmICh0aGlzLmJhY2tncm91bmQpIHtcblxuICAgICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kLmlzTGlnaHQoKSkge1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kLmRhcmtlbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZCA9PT0gQ29sb3JzLkJsYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBDb2xvcnMuV2hpdGU7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IENvbG9ycy5CbHVlO1xuICAgIH1cblxufTtcblxuLyoqXG4gKiBEZWxpdmVycyBhIHByb3ZpZGVkIG1lc3NhZ2UgdG8gdGhpcyBUaGluZy4gSWYgYSBUT1VDSCBtZXNzYWdlIGlzIHJlY2VpdmVkLCB0aGVuXG4gKiB0aGlzIERvb3Igd2lsbCB2YW5pc2ggaWYgYW4gYXNzb2NpYXRlZCBLZXkgaGFzIGJlZW4gcHJldmlvdXNseSBjb2xsZWN0ZWQuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VOYW1lIGEgbmFtZSBvZiBhIG1lc3NhZ2UgdG8gZGVsaXZlci5cbiAqL1xuRG9vci5wcm90b3R5cGUuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXG4gICAgdmFyIGRvb3JUeXBlLFxuICAgICAgICBtYXRjaGluZ0tleUNvZGU7XG5cbiAgICBpZiAobWVzc2FnZSA9PT0gJ1RPVUNIJykge1xuXG4gICAgICAgIC8vIEdldCBhIHJlYWRhYmxlIGRvb3IgZGVzY3JpcHRpb25cbiAgICAgICAgZG9vclR5cGUgPSBpMThuLmdldE1lc3NhZ2UoJ2Rvb3JzLicgKyB0aGlzLmJhY2tncm91bmQuY29kZSk7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGEgbWF0Y2hpbmcga2V5IGNvZGVcbiAgICAgICAgbWF0Y2hpbmdLZXlDb2RlID0gJ0tFWScgKyB0aGlzLmJhY2tncm91bmQubGlnaHRlbigpLmNvZGU7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0Q291bnRlclZhbHVlKG1hdGNoaW5nS2V5Q29kZSkgPiAwKSB7XG5cbiAgICAgICAgICAgIC8vIFRoZSBwbGF5ZXIgaGFzIHRoZSByaWdodCBrZXkgdHlwZVxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0Q291bnRlcihtYXRjaGluZ0tleUNvZGUsIC0xKTtcbiAgICAgICAgICAgIHRoaXMuYm9hcmQuc2V0RGlzcGxheU1lc3NhZ2UoaTE4bi5nZXRNZXNzYWdlKCdkb29ycy5vcGVuJywgZG9vclR5cGUpKTtcbiAgICAgICAgICAgIHRoaXMucGxheSgndGNnYmNnYitpYycpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIFRoZSBQbGF5ZXIgZG9lcyBub3QgaGF2ZSB0aGUgY29ycmVjdCBrZXkgdHlwZVxuICAgICAgICAgICAgdGhpcy5ib2FyZC5zZXREaXNwbGF5TWVzc2FnZShpMThuLmdldE1lc3NhZ2UoJ2Rvb3JzLmxvY2tlZCcsIGRvb3JUeXBlKSk7XG4gICAgICAgICAgICB0aGlzLnBsYXkoJ3QtLWdjJyk7XG5cbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIER1cGxpY2F0b3IoYm9hcmQpIHtcbiAgICBVcGRhdGVhYmxlVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5NQVhfU1RFUFMgPSAyMDtcbiAgICB0aGlzLmNvcHlEaXJlY3Rpb24gPSBEaXJlY3Rpb24uRWFzdDtcbiAgICB0aGlzLnNwZWVkID0gMTA7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IDI1MDtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jdXJyZW50U3RlcCA9IDA7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyaWdodFdoaXRlO1xufVxuRHVwbGljYXRvci5wcm90b3R5cGUgPSBuZXcgVXBkYXRlYWJsZVRoaW5nKCk7XG5EdXBsaWNhdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IER1cGxpY2F0b3I7XG5EdXBsaWNhdG9yLmFuaW1hdGlvbkZyYW1lcyA9IFsyNTAsIDI0OSwgNywgOSwgMTExLCA3OV07XG5cbkR1cGxpY2F0b3IucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5zZXJpYWxpemUuY2FsbCh0aGlzKTtcbiAgICBkZWxldGUgcmVzdWx0LmNvbG9yO1xuICAgIHJlc3VsdC5jb3B5RGlyZWN0aW9uID0gRGlyZWN0aW9uLmdldFNob3J0TmFtZSh0aGlzLmNvcHlEaXJlY3Rpb24pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5EdXBsaWNhdG9yLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQnJpZ2h0V2hpdGU7XG4gICAgdGhpcy5jb3B5RGlyZWN0aW9uID0gRGlyZWN0aW9uLmZyb21OYW1lKGRhdGEuY29weURpcmVjdGlvbik7XG59O1xuXG5EdXBsaWNhdG9yLnByb3RvdHlwZS5kb1RpY2sgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgY2xvbmVUaGluZyxcbiAgICAgICAgdGFyZ2V0VGhpbmcsXG4gICAgICAgIGlzRnJlZVNwYWNlLFxuICAgICAgICBjbG9uZVBvaW50LFxuICAgICAgICB0YXJnZXRQb2ludCxcbiAgICAgICAgY2xvbmVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmN1cnJlbnRTdGVwICs9IDE7XG4gICAgaWYgKHRoaXMuY3VycmVudFN0ZXAgPj0gdGhpcy5NQVhfU1RFUFMpIHtcblxuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gMDtcblxuICAgICAgICAvLyBHcmFiIG91ciBjbG9uZSBwb2ludCBhbmQgdGhpbmdcbiAgICAgICAgY2xvbmVQb2ludCA9IHRoaXMucG9pbnQuYWRkKHRoaXMuY29weURpcmVjdGlvbik7XG4gICAgICAgIGNsb25lVGhpbmcgPSB0aGlzLmJvYXJkLmdldFRpbGUoY2xvbmVQb2ludCk7XG5cbiAgICAgICAgLy8gR3JhYiBvdXIgdGFyZ2V0IHBvaW50XG4gICAgICAgIHRhcmdldFBvaW50ID0gdGhpcy5wb2ludC5hZGQoRGlyZWN0aW9uLm9wcG9zaXRlKHRoaXMuY29weURpcmVjdGlvbikpO1xuXG4gICAgICAgIC8vIElmIG91ciB0YXJnZXQgcG9pbnQgaXMgb24gdGhlIGJvYXJkLCBzZWUgd2hhdCdzIGFscmVhZHkgdGhlcmVcbiAgICAgICAgaWYgKCF0aGlzLmJvYXJkLmlzT3V0c2lkZSh0YXJnZXRQb2ludCkpIHtcbiAgICAgICAgICAgIHRhcmdldFRoaW5nID0gdGhpcy5ib2FyZC5nZXRUaWxlKHRhcmdldFBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsb25lVGhpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSBnb3QgYSB0aGluZyB0byBjbG9uZS4uLlxuICAgICAgICBpZiAoY2xvbmVUaGluZykge1xuXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlcmUgaXMgZnJlZSBzcGFjZSwgb3IgaWYgd2UgY2FuIG1ha2Ugc29tZSBieSBwdXNoaW5nIGFuIG9ic3RhY2xlXG4gICAgICAgICAgICBpc0ZyZWVTcGFjZSA9IHRhcmdldFRoaW5nID8gdGhpcy5ib2FyZC5tb3ZlVGlsZSh0aGlzLnBvaW50LCB0YXJnZXRQb2ludCwgZmFsc2UsIHRydWUpIDogdHJ1ZTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgZnJlZSBzcGFjZVxuICAgICAgICAgICAgaWYgKGlzRnJlZVNwYWNlKSB7XG5cbiAgICAgICAgICAgICAgICBjbG9uZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG91ciBuZXcgdGhpbmdcbiAgICAgICAgICAgICAgICB0aGlzLmJvYXJkLmFkZFRoaW5nKHRhcmdldFBvaW50LCBjbG9uZVRoaW5nLmNsb25lKCkpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgdGhpcy5wbGF5KGNsb25lZCA/ICdzY2RlZmcnIDogJy0tZyNmIycpO1xuXG5cblxuICAgIH1cblxuICAgIHRoaXMuc3ByaXRlSW5kZXggPSBEdXBsaWNhdG9yLmFuaW1hdGlvbkZyYW1lc1tNYXRoLnJvdW5kKCh0aGlzLmN1cnJlbnRTdGVwIC8gdGhpcy5NQVhfU1RFUFMpICogKER1cGxpY2F0b3IuYW5pbWF0aW9uRnJhbWVzLmxlbmd0aCAtIDEpKV07XG5cbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gRXhwbG9zaW9uKGJvYXJkKSB7XG4gICAgVXBkYXRlYWJsZVRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMucmFkaXVzID0gNDtcbiAgICB0aGlzLnRpbWVUb0xpdmUgPSBFeHBsb3Npb24uTUFYX1RUTDtcbiAgICB0aGlzLnNwZWVkID0gMTtcbiAgICB0aGlzLnNwcml0ZUluZGV4ID0gMDtcbn1cbkV4cGxvc2lvbi5wcm90b3R5cGUgPSBuZXcgVXBkYXRlYWJsZVRoaW5nKCk7XG5FeHBsb3Npb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXhwbG9zaW9uO1xuRXhwbG9zaW9uLk1BWF9UVEwgPSA1O1xuXG5FeHBsb3Npb24ucHJvdG90eXBlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBVcGRhdGVhYmxlVGhpbmcucHJvdG90eXBlLmRlc2VyaWFsaXplLmNhbGwodGhpcywgZGF0YSk7XG4gICAgdGhpcy5yYWRpdXMgPSBkYXRhLnJhZGl1cyB8fCA0O1xuICAgIHRoaXMudGltZVRvTGl2ZSA9IGRhdGEudGltZVRvTGl2ZSB8fCBFeHBsb3Npb24uTUFYX1RUTDtcbn07XG5cbkV4cGxvc2lvbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBVcGRhdGVhYmxlVGhpbmcucHJvdG90eXBlLnNlcmlhbGl6ZSh0aGlzKTtcbiAgICByZXN1bHQucmFkaXVzID0gdGhpcy5yYWRpdXM7XG4gICAgcmVzdWx0LnRpbWVUb0xpdmUgPSB0aGlzLnRpbWVUb0xpdmU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkV4cGxvc2lvbi5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHBvaW50cyxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHRpbGU7XG5cbiAgICAvLyBJZiB3ZSdyZSBhdCB0aGUgc3RhcnQgb2Ygb3VyIGV4cGxvc2lvbiwgc2VuZCBhIEJPTUJFRCBtZXNzYWdlIHRvIGFsbCBhZmZlY3RlZCBUaGluZ3NcbiAgICBpZiAodGhpcy50aW1lVG9MaXZlID09PSBFeHBsb3Npb24uTUFYX1RUTCkge1xuXG4gICAgICAgIHRoaXMucGxheSgndCsrK2MtYy1jLWMtYy1jJywgdHJ1ZSk7XG5cbiAgICAgICAgcG9pbnRzID0gdXRpbGl0aWVzLnBvaW50c0luQ2lyY2xlKHRoaXMucG9pbnQsIHRoaXMucmFkaXVzKTtcblxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwb2ludHMubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgICB0aWxlID0gdGhpcy5ib2FyZC5nZXRUaWxlKHBvaW50c1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKHRpbGUpIHtcbiAgICAgICAgICAgICAgICB0aWxlLnNlbmRNZXNzYWdlKCdCT01CRUQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFmdGVyIG91ciB0aW1lIHRvIGxpdmUsIHJlbW92ZSBvdXJzZWx2ZXNcbiAgICB0aGlzLnRpbWVUb0xpdmUgLT0gMTtcbiAgICBpZiAodGhpcy50aW1lVG9MaXZlIDw9IDApIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG5cbn07XG5cbkV4cGxvc2lvbi5wcm90b3R5cGUuZ2V0VG9yY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHV0aWxpdGllcy5nZW5lcmF0ZUNpcmNsZURhdGEodGhpcy5wb2ludCwgTWF0aC5yb3VuZCgodGhpcy5yYWRpdXMgKiB0aGlzLnRpbWVUb0xpdmUpIC8gKEV4cGxvc2lvbi5NQVhfVFRMIC0gMSkpICsgMik7XG59O1xuXG5FeHBsb3Npb24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cbiAgICB2YXIgcG9pbnRzLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgc3ByaXRlID0gdGhpcy5ib2FyZC5nYW1lLnJlc291cmNlcy5ncmFwaGljcy5nZXRTcHJpdGUoMTc2ICsgTWF0aC5yb3VuZCgoMiAqIHRoaXMudGltZVRvTGl2ZSkgLyBFeHBsb3Npb24uTUFYX1RUTCkpLFxuICAgICAgICByYWRpdXM7XG5cbiAgICBpZiAodGhpcy50aW1lVG9MaXZlID09PSBFeHBsb3Npb24uTUFYX1RUTCkge1xuICAgICAgICByYWRpdXMgPSBNYXRoLnJvdW5kKHRoaXMucmFkaXVzIC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmFkaXVzID0gTWF0aC5yb3VuZCgodGhpcy5yYWRpdXMgKiB0aGlzLnRpbWVUb0xpdmUpIC8gKEV4cGxvc2lvbi5NQVhfVFRMIC0gMSkpO1xuICAgIH1cblxuICAgIHBvaW50cyA9IHV0aWxpdGllcy5wb2ludHNJbkNpcmNsZSh0aGlzLnBvaW50LCByYWRpdXMpO1xuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcG9pbnRzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICBzcHJpdGUuZHJhdyhjb250ZXh0LCBwb2ludHNbaW5kZXhdLnN1YnRyYWN0KHRoaXMuYm9hcmQud2luZG93T3JpZ2luKSwgQ29sb3JzLlllbGxvdywgQ29sb3JzLlJlZCk7XG4gICAgfVxuXG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogRmFrZVdhbGwgbG9va3MgbGlrZSBhIG5vcm1hbCBXYWxsLCBidXQgaXMgc3VycmVuZGVyYWJsZSB0byB3aGF0ZXZlciBUaGluZyB3aXNoZXNcbiAqIHRvIG1vdmUgdGhlcmUuXG4gKlxuICogQHBhcmFtIGJvYXJkIEFuIG93bmVyIGJvYXJkIGZvciB0aGlzIEZha2VXYWxsXG4gKi9cbmZ1bmN0aW9uIEZha2VXYWxsKGJvYXJkKSB7XG4gICAgVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IDE3ODtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuWWVsbG93O1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IENvbG9ycy5CbGFjaztcbn1cbkZha2VXYWxsLnByb3RvdHlwZSA9IG5ldyBUaGluZygpO1xuRmFrZVdhbGwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRmFrZVdhbGw7XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGlzIEZha2VXYWxsIGlzIHN1cnJlbmRlcmFibGUgdG8gYW5vdGhlciB0aGluZy5cbiAqXG4gKiBAcGFyYW0gc2VuZGVyIEFub3RoZXIgVGhpbmcgdGhhdCBpcyByZXF1ZXN0aW5nIHRoaXMgVGhpbmcgdG8gc3VycmVuZGVyXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhpcyBUaGluZyBpcyB3aWxsaW5nIHRvIHN1cnJlbmRlciBpdHMgcG9zaXRpb24uXG4gKi9cbkZha2VXYWxsLnByb3RvdHlwZS5pc1N1cnJlbmRlcmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhIHNwcml0ZSBpbmRleCB1c2VkIHRvIHJlcHJlc2VudCB0aGlzIEZha2VXYWxsIG9uIGEgcmVuZGVyZWRcbiAqIEJvYXJkLiBJZiB0aGlzIEZha2VXYWxsJ3Mgb3duZXIgYm9hcmQncyBnYW1lIGlzIGluIGRlYnVnIG1vZGUsIHRoZW4gYSB2aXNpYmxlXG4gKiByZXByZXNlbnRhdGlvbiB3aWxsIGJlIHVzZWQuXG4gKi9cbkZha2VXYWxsLnByb3RvdHlwZS5nZXRTcHJpdGVJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5ib2FyZC5nYW1lLmlzRWRpdG9yID8gMTc2IDogMTc4O1xufTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKlxuICogRm9yZXN0IGFjdHMgYXMgYSBub24tcHVzaGFibGUgb2JzdGFjbGUsIGxpa2UgYSB3YWxsLCBidXQgaXQgdmFuaXNoZXMgd2hlbiB0aGVcbiAqIHBsYXllciBhdHRlbXB0cyB0byBtb3ZlIHRvIGl0cyBsb2NhdGlvbiwgY2xlYXJpbmcgdGhpcyBUaGluZyBmcm9tIHRoZSBib2FyZC5cbiAqXG4gKiBAcGFyYW0gYm9hcmQgQW4gb3duZXIgYm9hcmQgZm9yIHRoaXMgRm9yZXN0XG4gKi9cbmZ1bmN0aW9uIEZvcmVzdChib2FyZCkge1xuICAgIFRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMuc3ByaXRlSW5kZXggPSAxNzY7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJsYWNrO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IENvbG9ycy5HcmVlbjtcbn1cbkZvcmVzdC5wcm90b3R5cGUgPSBuZXcgVGhpbmcoKTtcbkZvcmVzdC5ub3RlQ3ljbGUgPSBbJ2UnLCAnLWInLCAnZiMnLCAnYicsICdmJywgJ2MnLCAnZycsICcrYyddO1xuRm9yZXN0Lm5vdGVJbmRleCA9IDA7XG5Gb3Jlc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRm9yZXN0O1xuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhpcyBGb3Jlc3QgaW50byBhIGRhdGEgb2JqZWN0LlxuICovXG5Gb3Jlc3QucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gVGhpbmcucHJvdG90eXBlLnNlcmlhbGl6ZS5jYWxsKHRoaXMpO1xuICAgIGRlbGV0ZSByZXN1bHQuY29sb3I7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRGVzZXJpYWxpemVzIGEgcHJvdmlkZWQgZGF0YSBPYmplY3QgaW50byBGb3Jlc3QuXG4gKlxuICogQHBhcmFtIGRhdGEgQSBkYXRhIG9iamVjdCB0byBiZSBkZXNlcmlhbGl6ZWQgaW50byBGb3Jlc3QuXG4gKi9cbkZvcmVzdC5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIFRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IENvbG9ycy5HcmVlbjtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQmxhY2s7XG59O1xuXG4vKipcbiAqIERlbGl2ZXJzIGEgcHJvdmlkZWQgbWVzc2FnZSB0byB0aGlzIFRoaW5nLiBJZiBhIFRPVUNIIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsXG4gKiB0aGVuIHRoaXMgRm9yZXN0IHdpbGwgYmUgZGVsZXRlZCBmcm9tIHRoZSBib2FyZCwgYWxsb3dpbmcgbW92ZW1lbnQgb250byBpdHNcbiAqIHNwYWNlLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlTmFtZSBhIG5hbWUgb2YgYSBtZXNzYWdlIHRvIGRlbGl2ZXIuXG4gKi9cbkZvcmVzdC5wcm90b3R5cGUuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlID09PSAnVE9VQ0gnKSB7XG5cbiAgICAgICAgdGhpcy5vbmVUaW1lTWVzc2FnZSgnc3RhdHVzLmZvcmVzdCcpO1xuXG4gICAgICAgIHRoaXMucGxheShGb3Jlc3Qubm90ZUN5Y2xlW0ZvcmVzdC5ub3RlSW5kZXhdKTtcblxuICAgICAgICBGb3Jlc3Qubm90ZUluZGV4ICs9IDE7XG5cbiAgICAgICAgaWYgKEZvcmVzdC5ub3RlSW5kZXggPj0gRm9yZXN0Lm5vdGVDeWNsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIEZvcmVzdC5ub3RlSW5kZXggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5ib2FyZC5kZWxldGVUaWxlKHRoaXMucG9pbnQpO1xuICAgIH1cbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZnVuY3Rpb24gR2VtKGJvYXJkKSB7XG4gICAgVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IDQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IENvbG9ycy5CcmlnaHRNYWdlbnRhO1xuICAgIHRoaXMuY29udmV5YWJsZSA9IHRydWU7XG59XG5HZW0ucHJvdG90eXBlID0gbmV3IFRoaW5nKCk7XG5HZW0ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VtO1xuXG4vKipcbiAqIERlbGl2ZXJzIGEgcHJvdmlkZWQgbWVzc2FnZSB0byB0aGlzIFRoaW5nLiBJZiBhIFRPVUNIIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsXG4gKiB0aGVuIHRoZSBnYW1lJ3MgR2VtcyBjb3VudGVyIHdpbGwgaW5jcmVhc2UgYnkgMSwgdGhlIGhlYWx0aCBjb3VudGVyIHdpbGwgaW5jcmVhc2VcbiAqIGJ5IDEsIGFuZCB0aGUgc2NvcmUgY291bnRlciB3aWxsIGlucmVhc2UgYnkgMTAuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VOYW1lIGEgbmFtZSBvZiBhIG1lc3NhZ2UgdG8gZGVsaXZlci5cbiAqL1xuR2VtLnByb3RvdHlwZS5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UgPT09ICdUT1VDSCcpIHtcbiAgICAgICAgdGhpcy5vbmVUaW1lTWVzc2FnZSgnc3RhdHVzLmdlbScpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmFkanVzdENvdW50ZXIoJ0hFQUxUSCcsIDEpO1xuICAgICAgICB0aGlzLmFkanVzdENvdW50ZXIoJ0dFTVMnLCAxKTtcbiAgICAgICAgdGhpcy5hZGp1c3RDb3VudGVyKCdTQ09SRScsIDEwKTtcbiAgICAgICAgdGhpcy5wbGF5KCd0K2MtZ2VjJyk7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlID09PSAnU0hPVCcgfHwgbWVzc2FnZSA9PT0gJ0JPTUJFRCcpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5wbGF5KCd0LWMnKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFB1c2hlcyB0aGlzIEdlbSBpbiBhIHByb3ZpZGVkIGRpcmVjdGlvbi4gSWYgdGhpcyBHZW0gY2Fubm90IGJlIHB1c2hlZCxcbiAqIHRoZW4gaXQgd2lsbCBiZSBzcXVpc2hlZCBhbmQgcmVtb3ZlZCBmcm9tIGl0cyBvd25lciBCb2FyZC5cbiAqXG4gKiBAcGFyYW0gZGlyZWN0aW9uIEEgZGlyZWN0aW9uIGluIHdoaWNoIHRvIHB1c2ggdGhpcyBHZW0uXG4gKi9cbkdlbS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIHB1c2hlcikge1xuXG4gICAgaWYgKHB1c2hlci50eXBlID09PSAnUml2ZXInKSB7XG4gICAgICAgIHRoaXMubW92ZShkaXJlY3Rpb24sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMubW92ZShkaXJlY3Rpb24pKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuXG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIEhlYXJ0KGJvYXJkKSB7XG4gICAgVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IDM7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyaWdodFJlZDtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5jb252ZXlhYmxlID0gdHJ1ZTtcbn1cbkhlYXJ0LnByb3RvdHlwZSA9IG5ldyBUaGluZygpO1xuSGVhcnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGVhcnQ7XG5cbkhlYXJ0LnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFRoaW5nLnByb3RvdHlwZS5zZXJpYWxpemUuY2FsbCh0aGlzKTtcbiAgICBkZWxldGUgcmVzdWx0LmNvbG9yO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5IZWFydC5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIFRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IENvbG9ycy5CcmlnaHRSZWQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gdW5kZWZpbmVkO1xufTtcblxuSGVhcnQucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZSA9PT0gJ1RPVUNIJykge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnBsYXkoJ3RjZWZnK2NlZycpO1xuICAgICAgICB0aGlzLmFkanVzdENvdW50ZXIoJ0hFQUxUSF9NQVgnLCAxMCk7XG4gICAgICAgIHRoaXMuYWRqdXN0Q291bnRlcignSEVBTFRIJywgMTApO1xuICAgICAgICB0aGlzLmFkanVzdENvdW50ZXIoJ1NDT1JFJywgNTAwKTtcbiAgICAgICAgdGhpcy5ib2FyZC5zZXREaXNwbGF5TWVzc2FnZShpMThuLmdldE1lc3NhZ2UoJ3N0YXR1cy5oZWFydCcpKTtcbiAgICB9XG59O1xuXG5IZWFydC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIHB1c2hlcikge1xuXG4gICAgaWYgKHB1c2hlci50eXBlID09PSAnUml2ZXInKSB7XG4gICAgICAgIHRoaXMubW92ZShkaXJlY3Rpb24sIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubW92ZShkaXJlY3Rpb24pO1xuICAgIH1cblxufTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKlxuICogSW52aXNpYmxlV2FsbCB3aWxsIGFwcGVhciBpbnZpc2libGUgdW50aWwgaXQgaXMgdG91Y2hlZCwgYXQgd2hpY2ggcG9pbnQgaXRcbiAqIGJlY29tZXMgYSByZWd1bGFyIFdhbGwuXG4gKlxuICogQHBhcmFtIGJvYXJkIEFuIG93bmVyIEJvYXJkLlxuICovXG5mdW5jdGlvbiBJbnZpc2libGVXYWxsKGJvYXJkKSB7XG4gICAgVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IDA7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyaWdodEdyZWVuO1xufVxuSW52aXNpYmxlV2FsbC5wcm90b3R5cGUgPSBuZXcgVGhpbmcoKTtcbkludmlzaWJsZVdhbGwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW52aXNpYmxlV2FsbDtcblxuLyoqXG4gKiBEZWxpdmVycyBhIHByb3ZpZGVkIG1lc3NhZ2UgdG8gdGhpcyBUaGluZy4gSWYgYSBUT1VDSCBtZXNzYWdlIGlzIHJlY2VpdmVkLFxuICogdGhlbiB0aGlzIFRoaW5nIHdpbGwgdHVybiBpbnRvIGEgV2FsbCBUaGluZy5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZU5hbWUgYSBuYW1lIG9mIGEgbWVzc2FnZSB0byBkZWxpdmVyLlxuICovXG5JbnZpc2libGVXYWxsLnByb3RvdHlwZS5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cbiAgICB2YXIgV2FsbCA9IGV4cG9ydHMudGhpbmdzLldhbGwsXG4gICAgICAgIHJlcGxhY2VtZW50O1xuXG4gICAgaWYgKG1lc3NhZ2UgPT09ICdUT1VDSCcpIHtcbiAgICAgICAgcmVwbGFjZW1lbnQgPSBuZXcgV2FsbCgpO1xuICAgICAgICByZXBsYWNlbWVudC5mb3JlZ3JvdW5kID0gdGhpcy5mb3JlZ3JvdW5kO1xuICAgICAgICByZXBsYWNlbWVudC5iYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kO1xuICAgICAgICB0aGlzLm9uZVRpbWVNZXNzYWdlKCdzdGF0dXMuaW52aXNpYmxlJyk7XG4gICAgICAgIHRoaXMuYm9hcmQucmVwbGFjZVRpbGUodGhpcy5wb2ludCwgcmVwbGFjZW1lbnQpO1xuICAgICAgICB0aGlzLnBsYXkoJ3QtLWRjJyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3ByaXRlIGluZGV4IHRvIGJlIHVzZWQgdG8gcmVwcmVzZW50IHRoaXMgSW52aXNpYmxlV2FsbC5cbiAqIElmIHdlIGRldGVjdCB0aGF0IHdlIGFyZSBpbiBhIGdhbWUgZWRpdG9yLCAxNzYgd2lsbCBiZSB1c2VkLiBPdGhlcndpc2UsIDAuXG4gKlxuICogQHJldHVybiBBIHNwcml0ZSBpbmRleC5cbiAqL1xuSW52aXNpYmxlV2FsbC5wcm90b3R5cGUuZ2V0U3ByaXRlSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm9hcmQuZ2FtZS5pc0VkaXRvciA/IDE3NiA6IDA7XG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogS2V5IGlzIGEgVGhpbmcgcmVwcmVzZW50aW5nIGEgY29sbGVjdGFibGUga2V5IGl0ZW0uIE9uZSBrZXkgb2YgYSBnaXZlbiBjb2xvclxuICogbWF5IGJlIGNvbGxlY3RlZCBhdCBhIHRpbWUuIEtleXMgYXJlIHVzZWQgdG8gdW5sb2NrIERvb3IgVGhpbmdzLlxuICpcbiAqIEBwYXJhbSBib2FyZCBBbiBvd25lciBCb2FyZCBmb3IgdGhpcyBLZXkuXG4gKi9cbmZ1bmN0aW9uIEtleShib2FyZCkge1xuICAgIFRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMuc3ByaXRlSW5kZXggPSAxMjtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyaWdodEJsdWU7XG4gICAgdGhpcy5jb252ZXlhYmxlID0gdHJ1ZTtcbn1cbktleS5wcm90b3R5cGUgPSBuZXcgVGhpbmcoKTtcbktleS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXk7XG5cbktleS5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIFRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuXG4gICAgLy8gS2V5cyBjYW4gb25seSBiZSBicmlnaHQgY29sb3JzXG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gdGhpcy5mb3JlZ3JvdW5kLmxpZ2h0ZW4oKTtcblxuICAgIC8vIEdyZXkgYW5kIGZsYXNoaW5nIGtleXMgZG9uJ3QgZXhpc3QgZWl0aGVyLCBzbyBhc3N1bWUgd2hpdGVcbiAgICBpZiAodGhpcy5mb3JlZ3JvdW5kIGluc3RhbmNlb2YgQ3ljbGluZ0NvbG9yIHx8IHRoaXMuZm9yZWdyb3VuZCA9PT0gQ29sb3JzLkdyZXkpIHtcbiAgICAgICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyaWdodFdoaXRlO1xuICAgIH1cblxuICAgIHRoaXMuYmFja2dyb3VuZCA9IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogRGVsaXZlcnMgYSBwcm92aWRlZCBtZXNzYWdlIHRvIHRoaXMgVGhpbmcuIElmIGEgVE9VQ0ggbWVzc2FnZSBpc1xuICogcmVjZWl2ZWQsIHRoZW4gdGhpcyBLZXkgd2lsbCBiZSBjb2xsZWN0ZWQsIGlmIGFuIGV4aXN0aW5nIEtleSBvZiB0aGlzXG4gKiB0eXBlIGhhcyBub3QgYWxyZWFkeSBiZWVuIGNvbGxlY3RlZC5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZU5hbWUgYSBuYW1lIG9mIGEgbWVzc2FnZSB0byBkZWxpdmVyLlxuICovXG5LZXkucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblxuICAgIHZhciBrZXlUeXBlO1xuXG4gICAgaWYgKG1lc3NhZ2UgPT09ICdUT1VDSCcpIHtcblxuICAgICAgICAvLyBHZXQgYSByZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGlzIGtleSB0eXBlXG4gICAgICAgIGtleVR5cGUgPSBpMThuLmdldE1lc3NhZ2UoJ2tleXMuJyArIHRoaXMuZm9yZWdyb3VuZC5jb2RlKTtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIHBsYXllciBoYXMgdGhlIGtleSBhbHJlYWR5XG4gICAgICAgIGlmICh0aGlzLmdldENvdW50ZXJWYWx1ZSgnS0VZJyArIHRoaXMuZm9yZWdyb3VuZC5jb2RlKSA+IDApIHtcblxuICAgICAgICAgICAgLy8gVGhlIHBsYXllciBhbHJlYWR5IGhhcyB0aGlzIGtleSB0eXBlXG4gICAgICAgICAgICB0aGlzLmJvYXJkLnNldERpc3BsYXlNZXNzYWdlKGkxOG4uZ2V0TWVzc2FnZSgna2V5cy50b29tYW55Jywga2V5VHlwZSkpO1xuICAgICAgICAgICAgdGhpcy5wbGF5KCdzYy1jJyk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gVGhlIHBsYXllciBkb2Vzbid0IHlldCBoYXZlIHRoZSByaWdodCBrZXkgdHlwZVxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0Q291bnRlcignS0VZJyArIHRoaXMuZm9yZWdyb3VuZC5jb2RlLCAxKTtcbiAgICAgICAgICAgIHRoaXMuYm9hcmQuc2V0RGlzcGxheU1lc3NhZ2UoaTE4bi5nZXRNZXNzYWdlKCdrZXlzLmNvbGxlY3QnLCBrZXlUeXBlKSk7XG4gICAgICAgICAgICB0aGlzLnBsYXkoJ3QrY2VnY2VnY2VnK3NjJyk7XG4gICAgICAgIH1cblxuICAgIH1cbn07XG5cbi8qKlxuICogUmVjZWl2ZXMgYSByZXF1ZXN0IHRvIGJlIHB1c2hlZCBpbiBhIGdpdmVuIGRpcmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gZGlyZWN0aW9uIEEgZGlyZWN0aW9uIGluIHdoaWNoIHRoaXMgVGhpbmcgaXMgcmVxdWVzdGVkIHRvIG1vdmUuXG4gKi9cbktleS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24sIHB1c2hlcikge1xuXG4gICAgaWYgKHB1c2hlci50eXBlID09PSAnUml2ZXInKSB7XG4gICAgICAgIHRoaXMubW92ZShkaXJlY3Rpb24sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAocHVzaGVyLnR5cGUgIT09ICdQbGF5ZXInICYmIHRoaXMubW92ZShkaXJlY3Rpb24pKSB7XG4gICAgICAgIHRoaXMucGxheSgndC0tZicsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBMYXZhKGJvYXJkKSB7XG4gICAgVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gQ29sb3JzLkJyaWdodFJlZDtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQnJpZ2h0UmVkO1xuICAgIHRoaXMuY3ljbGVDb3VudCA9IDA7XG4gICAgdGhpcy5jeWNsZVJhdGUgPSBib2FyZC5nYW1lLkNZQ0xFX1JBVEUgKiA1O1xuICAgIHRoaXMuc3ByaXRlSW5kZXggPSAxNzY7XG59XG5MYXZhLnByb3RvdHlwZSA9IG5ldyBUaGluZygpO1xuTGF2YS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXZhO1xuXG5MYXZhLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFRoaW5nLnByb3RvdHlwZS5zZXJpYWxpemUuY2FsbCh0aGlzKTtcbiAgICBkZWxldGUgcmVzdWx0LmNvbG9yO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5MYXZhLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgVGhpbmcucHJvdG90eXBlLmRlc2VyaWFsaXplLmNhbGwodGhpcywgZGF0YSk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gQ29sb3JzLkJyaWdodFJlZDtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQnJpZ2h0UmVkO1xufTtcblxuTGF2YS5wcm90b3R5cGUudXBkYXRlV2hpbGVVbmRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0aGluZyA9IHRoaXMuYm9hcmQuZ2V0VGlsZSh0aGlzLnBvaW50KTtcblxuICAgIC8vIElmIGEgcGxheWVyIHN0ZXBwZWQgb24gdGhlIGxhdmEuLi5cbiAgICBpZiAodGhpbmcudHlwZSA9PT0gJ1BsYXllcicpIHtcblxuICAgICAgICAvLyBEYW1hZ2UgdGhlIHBsYXllciBldmVyeSBmaXZlIGN5Y2xlc1xuICAgICAgICB0aGlzLmN5Y2xlQ291bnQgKz0gMTtcbiAgICAgICAgaWYgKHRoaXMuY3ljbGVDb3VudCA+IHRoaXMuY3ljbGVSYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmN5Y2xlQ291bnQgPSAwO1xuICAgICAgICAgICAgdGhpbmcuc2VuZE1lc3NhZ2UoJ1NIT1QnKTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmICh0aGluZy50eXBlID09PSAnU2NyaXB0YWJsZScpIHtcblxuICAgICAgICAvLyBTY3JpcHRhYmxlcyBnZXQgc2VudCBhIExBVkEgbWVzc2FnZVxuICAgICAgICB0aGluZy5zZW5kTWVzc2FnZSgnTEFWQScpO1xuXG4gICAgfSBlbHNlIGlmICghdGhpbmcubGF2YVdhbGtlcikge1xuXG4gICAgICAgIC8vIEFueXRoaW5nIGVsc2UgdGhhdCdzIG5vdCBhIGxhdmEgd2Fsa2VyLCBnZXRzXG4gICAgICAgIC8vIHNlbnQgYSBTSE9UIG1lc3NhZ2UgaW1tZWRpYXRlbHkuXG4gICAgICAgIHRoaW5nLnNlbmRNZXNzYWdlKCdTSE9UJyk7XG5cbiAgICB9XG5cbn07XG5cbkxhdmEucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZSA9PT0gJ1RPVUNIJykge1xuICAgICAgICB0aGlzLmN5Y2xlQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmJvYXJkLnBsYXllci5zZW5kTWVzc2FnZSgnU0hPVCcpO1xuICAgIH1cbn07XG5cbkxhdmEucHJvdG90eXBlLmlzU3VycmVuZGVyYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAqIExpbmVXYWxsIGlzIGEgVGhpbmcgcmVwcmVzZW50aW5nIGFuIGltbW92ZWFibGUgb2JzdGFjbGUgd2l0aCBsaW5lIGRlY29yYXRpb24uXG4gKlxuICogQHBhcmFtIGJvYXJkIEFuIG93bmVyIGJvYXJkIGZvciB0aGlzIExpbmVXYWxsLlxuICovXG5mdW5jdGlvbiBMaW5lV2FsbChib2FyZCkge1xuICAgIFRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMuc3ByaXRlSW5kZXggPSB1bmRlZmluZWQ7XG59XG5MaW5lV2FsbC5wcm90b3R5cGUgPSBuZXcgVGhpbmcoKTtcbkxpbmVXYWxsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVXYWxsO1xuTGluZVdhbGwubGluZU1hcCA9IHtcbiAgICAnJzogMjQ5LFxuICAgICdOJzogMjA4LFxuICAgICdFJzogMTk4LFxuICAgICdTJzogMjEwLFxuICAgICdXJzogMTgxLFxuICAgICdORSc6IDIwMCxcbiAgICAnTlMnOiAxODYsXG4gICAgJ05XJzogMTg4LFxuICAgICdFUyc6IDIwMSxcbiAgICAnRVcnOiAyMDUsXG4gICAgJ1NXJzogMTg3LFxuICAgICdORVMnOiAyMDQsXG4gICAgJ05FVyc6IDIwMixcbiAgICAnTlNXJzogMTg1LFxuICAgICdFU1cnOiAyMDMsXG4gICAgJ05FU1cnOiAyMDZcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgc3ByaXRlIGluZGV4IHRvIGJlIHVzZWQgd2hlbiB2aXN1YWxseSByZXByZXNlbnRpbmcgdGhpcyBMaW5lV2FsbCBvbiBhIHJlbmRlcmVkXG4gKiBnYW1lIEJvYXJkLiBUaGUgc3ByaXRlIGluZGV4IG9mIHRoaXMgTGluZVdhbGwgd2lsbCBkZXBlbmQgb24gaXRzIHN1cnJvdW5kaW5ncywgYWx0ZXJpbmdcbiAqIGl0cyBpbWFnZSB3aGVuIGNvbm5lY3RpbmcgTGluZVdhbGxzIGFyZSBmb3VuZC5cbiAqL1xuTGluZVdhbGwucHJvdG90eXBlLmdldFNwcml0ZUluZGV4ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKHRoaXMuc3ByaXRlSW5kZXggIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5ib2FyZC5nYW1lLmlzRWRpdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwcml0ZUluZGV4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGluZUFkamFjZW50KHNvdXJjZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciB0aWxlID0gc291cmNlLmJvYXJkLmdldFRpbGUoc291cmNlLnBvaW50LmFkZChkaXJlY3Rpb24pKTtcbiAgICAgICAgcmV0dXJuIHRpbGUgJiYgdGlsZS50eXBlID09PSAnTGluZVdhbGwnO1xuICAgIH1cblxuICAgIHZhciBzdXJyb3VuZGluZ1BhdHRlcm4gPSAnJztcbiAgICBzdXJyb3VuZGluZ1BhdHRlcm4gKz0gaXNMaW5lQWRqYWNlbnQodGhpcywgRGlyZWN0aW9uLk5vcnRoKSA/ICdOJyA6ICcnO1xuICAgIHN1cnJvdW5kaW5nUGF0dGVybiArPSBpc0xpbmVBZGphY2VudCh0aGlzLCBEaXJlY3Rpb24uRWFzdCkgPyAnRScgOiAnJztcbiAgICBzdXJyb3VuZGluZ1BhdHRlcm4gKz0gaXNMaW5lQWRqYWNlbnQodGhpcywgRGlyZWN0aW9uLlNvdXRoKSA/ICdTJyA6ICcnO1xuICAgIHN1cnJvdW5kaW5nUGF0dGVybiArPSBpc0xpbmVBZGphY2VudCh0aGlzLCBEaXJlY3Rpb24uV2VzdCkgPyAnVycgOiAnJztcblxuICAgIHRoaXMuc3ByaXRlSW5kZXggPSBMaW5lV2FsbC5saW5lTWFwW3N1cnJvdW5kaW5nUGF0dGVybl07XG4gICAgcmV0dXJuIHRoaXMuc3ByaXRlSW5kZXg7XG5cbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBMaW9uIGlzIGFuIFVwZGF0ZWFibGVUaGluZyByZXByZXNlbnRpbmcgYSBsaW9uIGVuZW15LCB3aGljaCBtb3ZlcyBhcm91bmRcbiAqIHdpdGggYSBzcGVjaWZpZWQgcmFuZG9tbmVzcyBhbmQgYXR0YWNrcyB0aGUgcGxheWVyLlxuICovXG5mdW5jdGlvbiBMaW9uKGJvYXJkKSB7XG4gICAgVXBkYXRlYWJsZVRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMuaW50ZWxsaWdlbmNlID0gMztcbiAgICB0aGlzLnNwcml0ZUluZGV4ID0gMjM0O1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IENvbG9ycy5CcmlnaHRSZWQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3BlZWQgPSAyO1xuICAgIHRoaXMuY29udmV5YWJsZSA9IHRydWU7XG59XG5MaW9uLnByb3RvdHlwZSA9IG5ldyBVcGRhdGVhYmxlVGhpbmcoKTtcbkxpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGlvbjtcblxuLyoqXG4gKiBTZXJpYWxpemVzIHRoaXMgTGlvbiB0byBhbiBPYmplY3QuXG4gKlxuICogQHJldHVybiBBIHNlcmlhbGl6ZWQgTGlvblxuICovXG5MaW9uLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuc2VyaWFsaXplLmNhbGwodGhpcyk7XG4gICAgZGVsZXRlIHJlc3VsdC5jb2xvcjtcbiAgICByZXN1bHQuaW50ZWxsaWdlbmNlID0gdGhpcy5pbnRlbGxpZ2VuY2U7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRGVzZXJpYWxpemVzIHRoaXMgTGlvbiBmcm9tIGEgcHJvdmlkZWQgZGF0YSBPYmplY3RcbiAqXG4gKiBAcGFyYW0gZGF0YSBBIGRhdGEgTGlvbiBvYmplY3QgdG8gYmUgZGVzZXJpYWxpemVkLlxuICovXG5MaW9uLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQnJpZ2h0UmVkO1xuICAgIHRoaXMuaW50ZWxsaWdlbmNlID0gZGF0YS5pbnRlbGxpZ2VuY2U7XG59O1xuXG4vKipcbiAqIERlbGl2ZXJzIGEgcHJvdmlkZWQgbWVzc2FnZSB0byB0aGlzIFRoaW5nLiBJZiBhIFNIT1QgbWVzc2FnZSBpcyByZWNlaXZlZCxcbiAqIHRoZW4gdGhpcyBMaW9uIHdpbGwgYmUgZGVsZXRlZCBmcm9tIHRoZSBib2FyZC4gSWYgYSBUT1VDSCBtZXNzYWdlIGlzXG4gKiByZWNlaXZlZCwgdGhlbiB0aGUgcGxheWVyIHdpbGwgYmUgc2VudCBhIFNIT1QgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZU5hbWUgYSBuYW1lIG9mIGEgbWVzc2FnZSB0byBkZWxpdmVyLlxuICovXG5MaW9uLnByb3RvdHlwZS5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cbiAgICBpZiAobWVzc2FnZSA9PT0gJ1NIT1QnIHx8IG1lc3NhZ2UgPT09ICdCT01CRUQnKSB7XG4gICAgICAgIHRoaXMucGxheSgndCtjLS0tYysrKytjLS1jJywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRqdXN0Q291bnRlcignU0NPUkUnLCAxMCk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlID09PSAnVE9VQ0gnKSB7XG4gICAgICAgIHRoaXMuYm9hcmQucGxheWVyLnNlbmRNZXNzYWdlKCdTSE9UJyk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIFJlY2VpdmVzIGEgcmVxdWVzdCB0byBiZSBwdXNoZWQgaW4gYSBnaXZlbiBkaXJlY3Rpb24uXG4gKlxuICogQHBhcmFtIGRpcmVjdGlvbiBBIGRpcmVjdGlvbiBpbiB3aGljaCB0aGlzIFRoaW5nIGlzIHJlcXVlc3RlZCB0byBtb3ZlLlxuICovXG5MaW9uLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgcHVzaGVyKSB7XG5cbiAgICBpZiAocHVzaGVyLnR5cGUgPT09ICdSaXZlcicpIHtcbiAgICAgICAgdGhpcy5tb3ZlKGRpcmVjdGlvbiwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5tb3ZlKGRpcmVjdGlvbikpIHtcbiAgICAgICAgdGhpcy5wbGF5KCd0K2MtLS1jKysrK2MtLWMnKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGlzIExpb24gc2hvdWxkIHNlZWsgdGhlIHBsYXllciBkdXJpbmcgaXRzIG5leHQgbW92ZS5cbiAqIFRoZSBwcm9iYWJpbGl0eSBvZiBhIHRydWUgcmVzdWx0IGRlcGVuZHMgb24gdGhpcyBMaW9uJ3MgaW50ZWxsaWdlbmNlXG4gKiBwcm9wZXJ0eS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhpcyBMaW9uIHNob3VsZCBzZWVrIHRoZSBwbGF5ZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuTGlvbi5wcm90b3R5cGUuc2Vla1BsYXllciA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciByYW5kb21WYWx1ZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKTtcbiAgICByZXR1cm4gcmFuZG9tVmFsdWUgPD0gdGhpcy5pbnRlbGxpZ2VuY2U7XG5cbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGlzIExpb24gZm9yIGEgcHJvdmlkZWQgdGltZXN0YW1wLiBUaGlzIExpb24gd2lsbCBtb3ZlIGl0c2VsZiByYW5kb21seVxuICogZHVyaW5nIHVwZGF0ZXMuIElmIGEgUGxheWVyIGJsb2NrcyBpdHMgbW92ZW1lbnQsIHRoZW4gdGhlIHBsYXllciB3aWxsIGJlIHNlbnRcbiAqIGEgU0hPVCBtZXNzYWdlIGFuZCB0aGlzIExpb24gd2lsbCBiZSByZW1vdmVkIGZyb20gaXRzIHBhcmVudCBib2FyZC5cbiAqL1xuTGlvbi5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuc2Vla1BsYXllcigpID8gdGhpcy5nZXRQbGF5ZXJEaXJlY3Rpb24oKSA6IERpcmVjdGlvbi5yYW5kb20oKSxcbiAgICAgICAgdGhpbmcgPSB0aGlzLmJvYXJkLmdldFRpbGUodGhpcy5wb2ludC5hZGQoZGlyZWN0aW9uKSk7XG5cbiAgICBpZiAodGhpbmcgJiYgdGhpbmcudHlwZSA9PT0gJ1BsYXllcicpIHtcbiAgICAgICAgdGhpbmcuc2VuZE1lc3NhZ2UoJ1NIT1QnKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIERvbid0IG1vdmUgaW4gdGhlIGRpcmVjdGlvbiBvZiBhIFJpdmVyXG4gICAgaWYgKHRoaW5nICYmIHRoaW5nLnR5cGUgPT09ICdSaXZlcicgJiYgdGhpbmcuZGlyZWN0aW9uID09PSBEaXJlY3Rpb24ub3Bwb3NpdGUoZGlyZWN0aW9uKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5tb3ZlKGRpcmVjdGlvbiwgdHJ1ZSk7XG5cbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBQYXNzYWdlIGlzIGEgVGhpbmcgY2FwYWJsZSBvZiBtb3ZpbmcgYSBwbGF5ZXIgdG8gaXRzIG1hdGNoaW5nIHBhc3NhZ2Ugb24gYSB0YXJnZXQgYm9hcmQuXG4gKlxuICogQHBhcmFtIGJvYXJkIEFuIG93bmVyIGJvYXJkIGZvciB0aGlzIFBhc3NhZ2VcbiAqL1xuZnVuY3Rpb24gUGFzc2FnZShib2FyZCkge1xuICAgIFRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMuc3ByaXRlSW5kZXggPSAyNDA7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyaWdodFdoaXRlO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IENvbG9ycy5CbHVlO1xuICAgIHRoaXMudGFyZ2V0Qm9hcmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5wYXNzYWdlSWQgPSAwO1xuICAgIHRoaXMuZ2xvdyA9IHRydWU7XG59XG5QYXNzYWdlLnByb3RvdHlwZSA9IG5ldyBUaGluZygpO1xuUGFzc2FnZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXNzYWdlO1xuXG4vKipcbiAqIERlbGl2ZXJzIGEgcHJvdmlkZWQgbWVzc2FnZSB0byB0aGlzIFRoaW5nLiBJZiBhIFRPVUNIIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsXG4gKiB0aGVuIHRoaXMgUGFzc2FnZSB3aWxsIG1vdmUgdGhlIHBsYXllciB0byBhIG1hdGNoaW5nIFBhc3NhZ2Ugb24gaXRzIHRhcmdldCBib2FyZC5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZU5hbWUgYSBuYW1lIG9mIGEgbWVzc2FnZSB0byBkZWxpdmVyLlxuICovXG5QYXNzYWdlLnByb3RvdHlwZS5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgaWYgKG1lc3NhZ2UgPT09ICdUT1VDSCcpIHtcbiAgICAgICAgdGhpcy5wbGF5KCd0Y2VnIHRjI2ZnIyB0ZGYjYSB0ZCNnYSMgdGVnIytjJyk7XG4gICAgICAgIHRoaXMuYm9hcmQuZ2FtZS5tb3ZlUGxheWVyVG9QYXNzYWdlKHRoaXMucGFzc2FnZUlkLCB0aGlzLnRhcmdldEJvYXJkKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhpcyBQYXNzYWdlIHRvIGFuIE9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIEEgc2VyaWFsaXplZCBQYXNzYWdlXG4gKi9cblBhc3NhZ2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gVGhpbmcucHJvdG90eXBlLnNlcmlhbGl6ZS5jYWxsKHRoaXMpO1xuICAgIHJlc3VsdC5wYXNzYWdlSWQgPSB0aGlzLnBhc3NhZ2VJZDtcbiAgICByZXN1bHQudGFyZ2V0Qm9hcmQgPSB0aGlzLnRhcmdldEJvYXJkO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHByb3ZpZGVkIGRhdGEgT2JqZWN0IGludG8gYSBQYXNzYWdlLlxuICpcbiAqIEBwYXJhbSBkYXRhIEEgZGF0YSBvYmplY3QgdG8gYmUgZGVzZXJpYWxpemVkIGludG8gYSBQYXNzYWdlLlxuICovXG5QYXNzYWdlLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgVGhpbmcucHJvdG90eXBlLmRlc2VyaWFsaXplLmNhbGwodGhpcywgZGF0YSk7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyaWdodFdoaXRlO1xuICAgIGlmICghdGhpcy5iYWNrZ3JvdW5kKSB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IENvbG9ycy5CbHVlO1xuICAgIH1cbiAgICB0aGlzLnRhcmdldEJvYXJkID0gZGF0YS50YXJnZXRCb2FyZDtcbiAgICB0aGlzLnBhc3NhZ2VJZCA9IGRhdGEucGFzc2FnZUlkO1xufTtcblxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qXG4gKiBQbGF5ZXIgaXMgYW4gVXBkYXRlYWJsZVRoaW5nIHRoYXQgaXMgY29udHJvbGxhYmxlIGJ5IHRoZSB1c2VyIGFuZCByZXByZXNlbnRzXG4gKiB0aGUgcHJpbWFyeSBhY3Rpb24gcG9pbnQgZm9yIGdhbWVwbGF5LlxuICpcbiAqIEBwYXJhbSBib2FyZCBBbiBvd25lciBib2FyZCBmb3IgdGhpcyBQbGF5ZXIuXG4gKi9cbmZ1bmN0aW9uIFBsYXllcihib2FyZCkge1xuICAgIFVwZGF0ZWFibGVUaGluZy5jYWxsKHRoaXMsIGJvYXJkKTtcblxuICAgIHRoaXMubmFtZSA9ICdQbGF5ZXInO1xuICAgIHRoaXMuc3ByaXRlSW5kZXggPSAyO1xuICAgIHRoaXMucG9pbnQgPSBuZXcgUG9pbnQoLTEsIC0xKTtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQnJpZ2h0V2hpdGU7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gQ29sb3JzLkJsdWU7XG4gICAgdGhpcy5jb252ZXlhYmxlID0gdHJ1ZTtcblxuICAgIGlmIChib2FyZCkge1xuICAgICAgICB0aGlzLmV2ZW50U2NoZWR1bGVyID0gbmV3IERlbGF5ZWRFdmVudFNjaGVkdWxlcihib2FyZC5nYW1lLkNZQ0xFX1RJQ0tTICogMiwgMCk7XG4gICAgfVxuXG4gICAgdGhpcy5nYW1lID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc3BlZWQgPSAxO1xuICAgIHRoaXMuZ2xvdyA9IHRydWU7XG5cblxuXG59XG5QbGF5ZXIucHJvdG90eXBlID0gbmV3IFVwZGF0ZWFibGVUaGluZygpO1xuUGxheWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYXllcjtcblxuLyoqXG4gKiBTZXJpYWxpemVzIHRoaXMgUGxheWVyIGluc3RhbmNlLiBOb3RlIHRoYXQgcGxheWVycyBkb24ndCBhY3R1YWxseVxuICogZ2V0IHNlcmlhbGl6ZWQuIEluc3RlYWQsIGFueSB0aWxlIHVuZGVyIHRoZSBwbGF5ZXIgaXMgcmV0dXJuZWQuXG4gKi9cblBsYXllci5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIHRoaXMudW5kZXIgPyB0aGlzLnVuZGVyLnNlcmlhbGl6ZSgpIDogMDtcblxufTtcblxuLyoqXG4gKiBSZWNlaXZlcyBhIHJlcXVlc3QgdG8gYmUgcHVzaGVkIGluIGEgZ2l2ZW4gZGlyZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBkaXJlY3Rpb24gQSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhpcyBUaGluZyBpcyByZXF1ZXN0ZWQgdG8gbW92ZS5cbiAqL1xuUGxheWVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgIHRoaXMubW92ZShkaXJlY3Rpb24pO1xufTtcblxuLyoqXG4gKiBNb3ZlcyB0aGlzIFRoaW5nIGluIGEgcHJvdmlkZWQgRGlyZWN0aW9uIGFuZCByZXR1cm5zIGl0cyBzdWNjZXNzLlxuICpcbiAqIEBwYXJhbSBkaXJlY3Rpb24gQSBEaXJlY3Rpb24gaW4gd2hpY2ggdG8gbW92ZSB0aGlzIFRoaW5nLlxuICogQHJldHVybiB0cnVlIGlmIHRoZSBtb3ZlIHdhcyBzdWNjZXNzZnVsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblBsYXllci5wcm90b3R5cGUubW92ZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcblxuICAgIC8vIFJlbWVtYmVyIG91ciBjdXJyZW50IGxvY2F0aW9uXG4gICAgdmFyIHN0YXJ0aW5nUG9pbnQgPSB0aGlzLnBvaW50LmNsb25lKCksXG4gICAgICAgIG5ld0xvY2F0aW9uID0gdGhpcy5wb2ludC5hZGQoZGlyZWN0aW9uKSxcbiAgICAgICAgdGhpbmc7XG5cbiAgICAvLyBGaXJzdCwgY2hlY2sgaWYgdGhlIGRpcmVjdGlvbiBpcyBvdXRzaWRlIHRoZSBib2FyZFxuICAgIGlmICh0aGlzLmJvYXJkLmlzT3V0c2lkZShuZXdMb2NhdGlvbikpIHtcblxuICAgICAgICAvLyBGaW5kIG91dCB3aGljaCBkaXJlY3Rpb24gd2UncmUgbW92aW5nIHRvXG4gICAgICAgIGRpcmVjdGlvbiA9IHRoaXMucG9pbnQuZGlyZWN0aW9uVG8obmV3TG9jYXRpb24pO1xuICAgICAgICB0aGlzLmJvYXJkLm1vdmVQbGF5ZXJPZmZCb2FyZChkaXJlY3Rpb24pO1xuXG4gICAgICAgIC8vIFRoaXMgaXNuJ3QgYSB0eXBpY2FsIGJvYXJkIG1vdmVcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgfVxuXG4gICAgLy8gSWYgd2UncmUgbm90IG1vdmluZyBvZmYgYm9hcmQsIGluc3BlY3QgdGhlIHRoaW5nIHdlJ3JlIG1vdmluZyB0b1xuICAgIHRoaW5nID0gdGhpcy5ib2FyZC5nZXRUaWxlKG5ld0xvY2F0aW9uKTtcblxuICAgIC8vIElmIHRoZXJlJ3MgYSB0aWxlIHRoZXJlLCBzZW5kIGl0IGEgdG91Y2ggbWVzc2FnZVxuICAgIGlmICh0aGluZykge1xuICAgICAgICB0aGluZy5zZW5kTWVzc2FnZSgnVE9VQ0gnKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgcGxheWVyIHdhc24ndCBhbHJlYWR5IG1vdmVkIGFzIGEgcmVzdWx0IG9mIGFib3ZlIGFjdGlvbnMsIGRvIG91ciBtb3ZlXG4gICAgaWYgKHRoaXMucG9pbnQuZXF1YWxzKHN0YXJ0aW5nUG9pbnQpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvYXJkLm1vdmVUaWxlKHRoaXMucG9pbnQsIG5ld0xvY2F0aW9uKTtcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UgdGhpcyB3YXNuJ3QgYSB0eXBpY2FsIG1vdmUgYW55bW9yZVxuICAgIHJldHVybiBmYWxzZTtcblxufTtcblxuLyoqXG4gKiBTaG9vdHMgYSBwbGF5ZXIgYnVsbGV0IGluIGEgcHJvdmlkZWQgRGlyZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBBIERpcmVjdGlvbiBpbiB3aGljaCB0byBzaG9vdCBhIHBsYXllciBidWxsZXQuXG4gKi9cblBsYXllci5wcm90b3R5cGUuc2hvb3QgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG5cbiAgICAvLyBJZiB3ZSBjYW4ndCBzaG9vdCBvbiB0aGlzIGJvYXJkLCByZXR1cm5cbiAgICBpZiAodGhpcy5ib2FyZC5jYW5QbGF5ZXJTaG9vdCh0cnVlKSA8PSAwKSB7XG4gICAgICAgIHRoaXMucGxheSgnMDInKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmdldENvdW50ZXJWYWx1ZSgnQU1NTycpID4gMCkge1xuICAgICAgICB0aGlzLmFkanVzdENvdW50ZXIoJ0FNTU8nLCAtMSk7XG4gICAgICAgIFRoaW5nRmFjdG9yeS5zaG9vdCh0aGlzLmJvYXJkLCB0aGlzLnBvaW50LmFkZChkaXJlY3Rpb24pLCBkaXJlY3Rpb24sIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYm9hcmQuc2V0RGlzcGxheU1lc3NhZ2UoaTE4bi5nZXRNZXNzYWdlKCdzdGF0dXMubm9hbW1vJykpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYW4gdXBkYXRlIHRpY2sgb2YgdGhpcyBQbGF5ZXIgaW5zdGFuY2UsIG1vdmluZyBvciBzaG9vdGluZ1xuICogaW4gaXRzIGRpcmVjdGlvbiwgYXMgbmVjZXNzYXJ5LlxuICovXG5QbGF5ZXIucHJvdG90eXBlLmRvVGljayA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBldmVudCA9IHRoaXMuZXZlbnRTY2hlZHVsZXIudGFrZUV2ZW50KCk7XG5cbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09IE1PVkVfQUNUSU9OKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmUoZXZlbnQuZGlyZWN0aW9uKTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSBTSE9PVF9BQ1RJT04pIHtcbiAgICAgICAgICAgIHRoaXMuc2hvb3QoZXZlbnQuZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cblxufTtcblxuXG4vKipcbiAqIFVwZGF0ZXMgdGhpcyBQbGF5ZXIgZm9yIGEgc2luZ2xlIGV4ZWN1dGlvbiBjeWNsZS4gRHVyaW5nIGl0cyB1cGRhdGUsXG4gKiBQbGF5ZXIgd2lsbCBjaGVjayBmb3Iga2V5cHJlc3NlcyBhbmQgbW92ZSBhY2NvcmRpbmdseS5cbiAqL1xuUGxheWVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgayA9IHRoaXMuZ2FtZS5rZXlib2FyZCxcbiAgICAgICAga2V5ID0gay5nZXRNb3N0UmVjZW50UHJlc3MoW2suVVAsIGsuUklHSFQsIGsuRE9XTiwgay5MRUZUXSk7XG5cbiAgICBpZiAoay5pc1ByZXNzZWQoay5TSElGVCkgfHwgay5pc1ByZXNzZWQoay5TUEFDRSkpIHtcblxuICAgICAgICBpZiAoa2V5ID09PSBrLlVQKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2NoZWR1bGVyLnNjaGVkdWxlRXZlbnQoay5pc1ByZXNzZWQoay5VUCksIHsndHlwZSc6IFNIT09UX0FDVElPTiwgICdkaXJlY3Rpb24nOiBEaXJlY3Rpb24uTm9ydGh9KTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IGsuUklHSFQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTY2hlZHVsZXIuc2NoZWR1bGVFdmVudChrLmlzUHJlc3NlZChrLlJJR0hUKSwgeyd0eXBlJzogU0hPT1RfQUNUSU9OLCAnZGlyZWN0aW9uJzogRGlyZWN0aW9uLkVhc3R9KTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IGsuRE9XTikge1xuICAgICAgICAgICAgdGhpcy5ldmVudFNjaGVkdWxlci5zY2hlZHVsZUV2ZW50KGsuaXNQcmVzc2VkKGsuRE9XTiksIHsndHlwZSc6IFNIT09UX0FDVElPTiwgJ2RpcmVjdGlvbic6IERpcmVjdGlvbi5Tb3V0aH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gay5MRUZUKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2NoZWR1bGVyLnNjaGVkdWxlRXZlbnQoay5pc1ByZXNzZWQoay5MRUZUKSwgeyd0eXBlJzogU0hPT1RfQUNUSU9OLCAnZGlyZWN0aW9uJzogRGlyZWN0aW9uLldlc3R9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTY2hlZHVsZXIuY2FuY2VsRXZlbnQoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChrZXkgPT09IGsuVVApIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTY2hlZHVsZXIuc2NoZWR1bGVFdmVudChrLmlzUHJlc3NlZChrLlVQKSwgeyd0eXBlJzogTU9WRV9BQ1RJT04sICdkaXJlY3Rpb24nOiBEaXJlY3Rpb24uTm9ydGh9KTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IGsuUklHSFQpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTY2hlZHVsZXIuc2NoZWR1bGVFdmVudChrLmlzUHJlc3NlZChrLlJJR0hUKSwgeyd0eXBlJzogTU9WRV9BQ1RJT04sICdkaXJlY3Rpb24nOiBEaXJlY3Rpb24uRWFzdH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gay5ET1dOKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50U2NoZWR1bGVyLnNjaGVkdWxlRXZlbnQoay5pc1ByZXNzZWQoay5ET1dOKSwgeyd0eXBlJzogTU9WRV9BQ1RJT04sICdkaXJlY3Rpb24nOiBEaXJlY3Rpb24uU291dGh9KTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IGsuTEVGVCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudFNjaGVkdWxlci5zY2hlZHVsZUV2ZW50KGsuaXNQcmVzc2VkKGsuTEVGVCksIHsndHlwZSc6IE1PVkVfQUNUSU9OLCAnZGlyZWN0aW9uJzogRGlyZWN0aW9uLldlc3R9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRTY2hlZHVsZXIuY2FuY2VsRXZlbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIFQgaGFzIGJlZW4gcHJlc3NlZCwgYW5kIHdlIGhhdmUgMTAgc2Vjb25kcyBvciBsZXNzIG9uIG91ciBjdXJyZW50IHRvcmNoXG4gICAgICAgIGlmIChrLmlzUHJlc3NlZChbay5UXSkpIHtcbiAgICAgICAgICAgIHRoaXMudXNlVG9yY2goKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgIC8vIFRvIHN0YXkgc3VmZmljaWVudGx5IHJlc3BvbnNpdmUsIHRoZSBwbGF5ZXIgdG9yY2ggaGFzIHRvIGJlIGluaXRpYWxpemVkIGV4cGxpY2l0bHkgaGVyZVxuICAgIHRoaXMuYm9hcmQuaW5pdGlhbGl6ZVRvcmNoKHRoaXMpO1xuXG59O1xuXG4vKipcbiAqIFVzZXMgYSB0b3JjaCwgaWxsdW1pbmF0aW5nIHN1cnJvdW5kaW5nIHRpbGVzIGlmIGEgZ2l2ZW4gYm9hcmQgaXNcbiAqIGRhcmsuXG4gKi9cblBsYXllci5wcm90b3R5cGUudXNlVG9yY2ggPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBJZiB0aGUgcGxheWVyIGhhcyBtb3JlIHRoYW4gMTAgc2Vjb25kcyBsZWZ0IG9uIHRoZSBjdXJyZW50IHRvcmNoLFxuICAgIC8vIHRoZW4gdGhleSBkb24ndCBuZWVkIGFub3RoZXIgeWV0LlxuICAgIGlmICh0aGlzLmdhbWUuZ2V0Q291bnRlclZhbHVlKCdUT1JDSExJRkUnKSA+IDEwMDAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgcGxheWVyIGhhcyB0b3JjaGVzIGF2YWlsYWJsZS4uLlxuICAgIGlmICh0aGlzLmdhbWUuZ2V0Q291bnRlclZhbHVlKCdUT1JDSEVTJykgPiAwKSB7XG5cbiAgICAgICAgLy8gSWYgdGhlIHJvb20gaXNuJ3QgZGFyaywgbGV0IHRoZSBwbGF5ZXIga2VlcCB0aGUgdG9yY2hcbiAgICAgICAgaWYgKCF0aGlzLmJvYXJkLmRhcmspIHtcbiAgICAgICAgICAgIHRoaXMuYm9hcmQuc2V0RGlzcGxheU1lc3NhZ2UoaTE4bi5nZXRNZXNzYWdlKCdzdGF0dXMubm90ZGFyaycpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlY3JlYXNlIG91ciB0b3JjaCBjb3VudFxuICAgICAgICB0aGlzLmdhbWUuYWRqdXN0Q291bnRlcignVE9SQ0hFUycsIC0xKTtcblxuICAgICAgICAvLyBTcGVjaWZ5IHRoYXQgd2UncmUgbm93IHVzaW5nIGEgdG9yY2hcbiAgICAgICAgdGhpcy5nYW1lLnNldENvdW50ZXJWYWx1ZSgnVE9SQ0hMSUZFJywgVE9SQ0hfVFRMKTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gRGlzcGxheSBhIG1lc3NhZ2UgaW5kaWNhdGluZyB3ZSBoYXZlIG5vIHRvcmNoZXNcbiAgICAgICAgdGhpcy5ib2FyZC5zZXREaXNwbGF5TWVzc2FnZShpMThuLmdldE1lc3NhZ2UoJ3N0YXR1cy5ub3RvcmNoZXMnKSk7XG5cbiAgICB9XG5cblxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSB0b3JjaCBhcmVhIGZvciB0aGlzIFBsYXllciwgaWYgdGhlIHBsYXllcidzIHRvcmNoIGlzIGN1cnJlbnRseSBhY3RpdmUuXG4gKi9cblBsYXllci5wcm90b3R5cGUuZ2V0VG9yY2ggPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgdG9yY2hMaWZlID0gdGhpcy5nYW1lLmdldENvdW50ZXJWYWx1ZSgnVE9SQ0hMSUZFJyksXG4gICAgICAgIHRvcmNoU3RyZW5ndGggPSBNQVhfVE9SQ0hfU1RSRU5HVEg7XG5cbiAgICAvLyBJZiB3ZSd2ZSBnb3QgYSB0b3JjaC4uLlxuICAgIGlmICh0b3JjaExpZmUgPiAwKSB7XG5cbiAgICAgICAgLy8gU3RhcnQgc2hyaW5raW5nIHRoZSByYWRpdXMgd2hlbiB0aGVyZSdzIG9ubHkgMjAgc2Vjb25kcyBsZWZ0XG4gICAgICAgIGlmICh0b3JjaExpZmUgPCAyMDAwMCkge1xuICAgICAgICAgICAgdG9yY2hTdHJlbmd0aCA9IE1hdGguY2VpbCgodG9yY2hMaWZlICogTUFYX1RPUkNIX1NUUkVOR1RIKSAvIChUT1JDSF9UVEwgLyAzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXRpbGl0aWVzLmdlbmVyYXRlQ2lyY2xlRGF0YSh0aGlzLnBvaW50LCB0b3JjaFN0cmVuZ3RoKTtcblxuICAgIH1cblxufTtcblxuLyoqXG4gKiBEZWxpdmVycyBhIHByb3ZpZGVkIG1lc3NhZ2UgdG8gdGhpcyBUaGluZy5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZU5hbWUgYSBuYW1lIG9mIGEgbWVzc2FnZSB0byBkZWxpdmVyLlxuICovXG5QbGF5ZXIucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblxuICAgIGlmIChtZXNzYWdlID09PSAnU0hPVCcgfHwgbWVzc2FnZSA9PT0gJ0JPTUJFRCcpIHtcbiAgICAgICAgdGhpcy5wbGF5KCd0LS1jK2MtYytkIycsIHRydWUpO1xuICAgICAgICB0aGlzLmFkanVzdENvdW50ZXIoJ0hFQUxUSCcsIC0xMCk7XG4gICAgICAgIHRoaXMuYm9hcmQucGxheWVySHVydCgpO1xuICAgIH1cblxufTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFB1c2hlciByZXByZXNlbnRzIGFuIFVwZGF0ZWFibGVUaGluZyB0aGF0IGNvbnRpbnVhbGx5IG1vdmVzIGluIGEgZGVmaW5lZCBkaXJlY3Rpb24sXG4gKiBwdXNoaW5nIG9ic3RhY2xlcyBpbiBpdHMgcGF0aC5cbiAqXG4gKiBAcGFyYW0gYm9hcmQgQW4gb3duZXIgYm9hcmQgZm9yIHRoaXMgUHVzaGVyLlxuICovXG5mdW5jdGlvbiBQdXNoZXIoYm9hcmQpIHtcbiAgICBVcGRhdGVhYmxlVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5vcmllbnRhdGlvbiA9IERpcmVjdGlvbi5Tb3V0aDtcbiAgICB0aGlzLnNwZWVkID0gMztcbiAgICB0aGlzLmluaXRpYWxpemVTcHJpdGUoKTtcbn1cblB1c2hlci5wcm90b3R5cGUgPSBuZXcgVXBkYXRlYWJsZVRoaW5nKCk7XG5QdXNoZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVzaGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGEgc3ByaXRlSW5kZXggZm9yIHRoaXMgUHVzaGVyIGJhc2VkIG9uIGl0cyBkZWZpbmVkXG4gKiBkaXJlY3Rpb24uXG4gKi9cblB1c2hlci5wcm90b3R5cGUuaW5pdGlhbGl6ZVNwcml0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5vcmllbnRhdGlvbiA9PT0gRGlyZWN0aW9uLk5vcnRoKSB7XG4gICAgICAgIHRoaXMuc3ByaXRlSW5kZXggPSAzMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3JpZW50YXRpb24gPT09IERpcmVjdGlvbi5FYXN0KSB7XG4gICAgICAgIHRoaXMuc3ByaXRlSW5kZXggPSAxNjtcbiAgICB9IGVsc2UgaWYgKHRoaXMub3JpZW50YXRpb24gPT09IERpcmVjdGlvbi5Tb3V0aCkge1xuICAgICAgICB0aGlzLnNwcml0ZUluZGV4ID0gMzE7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9yaWVudGF0aW9uID09PSBEaXJlY3Rpb24uV2VzdCkge1xuICAgICAgICB0aGlzLnNwcml0ZUluZGV4ID0gMTc7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXJpYWxpemVzIHRoaXMgUHVzaGVyIGluc3RhbmNlIHRvIGFuIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIEEgc2VyaWFsaXplZCBQdXNoZXJcbiAqL1xuUHVzaGVyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuc2VyaWFsaXplLmNhbGwodGhpcyk7XG4gICAgcmVzdWx0Lm9yaWVudGF0aW9uID0gRGlyZWN0aW9uLmdldE5hbWUodGhpcy5vcmllbnRhdGlvbik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRGVzZXJpYWxpemVzIGEgcHJvdmlkZWQgZGF0YSBvYmplY3QgaW50byBhIFB1c2hlciBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gZGF0YSBTZXJpYWxpemVzIFB1c2hlciBkYXRhIHRvIGJlIGRlc2VyaWFsaXplZC5cbiAqL1xuUHVzaGVyLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoZGF0YS5vcmllbnRhdGlvbikge1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gRGlyZWN0aW9uLmZyb21OYW1lKGRhdGEub3JpZW50YXRpb24pO1xuICAgIH1cbiAgICB0aGlzLmluaXRpYWxpemVTcHJpdGUoKTtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSB0aWNrIHVwZGF0ZSBvZiB0aGlzIFB1c2hlci5cbiAqL1xuUHVzaGVyLnByb3RvdHlwZS5kb1RpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMubW92ZSh0aGlzLm9yaWVudGF0aW9uKSkge1xuICAgICAgICB0aGlzLnBsYXkoJ3QtLWYnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxufTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFJpY29jaGV0IGlzIGEgVGhpbmcgdGhhdCByZWZsZWN0cyBidWxsZXRzLlxuICpcbiAqIEBwYXJhbSBib2FyZCBBbiBvd25lciBib2FyZCBmb3IgdGhpcyBSaWNvY2hldC5cbiAqL1xuZnVuY3Rpb24gUmljb2NoZXQoYm9hcmQpIHtcbiAgICBUaGluZy5jYWxsKHRoaXMsIGJvYXJkKTtcbiAgICB0aGlzLnNwcml0ZUluZGV4ID0gNDI7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IENvbG9ycy5CcmlnaHRHcmVlbjtcbn1cblJpY29jaGV0LnByb3RvdHlwZSA9IG5ldyBUaGluZygpO1xuUmljb2NoZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmljb2NoZXQ7XG5cbi8qKlxuICogU2VyaWFsaXplcyB0aGlzIFJpY29jaGV0IHRvIGEgZGF0YSBvYmplY3QuXG4gKi9cblJpY29jaGV0LnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFRoaW5nLnByb3RvdHlwZS5zZXJpYWxpemUuY2FsbCh0aGlzKTtcbiAgICBkZWxldGUgcmVzdWx0LmNvbG9yO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERlc2VyaWFsaXplcyB0aGlzIFJpY29jaGV0IGZyb20gYSBkYXRhIG9iamVjdC5cbiAqL1xuUmljb2NoZXQucHJvdG90eXBlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBUaGluZy5wcm90b3R5cGUuZGVzZXJpYWxpemUuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyaWdodEdyZWVuO1xufTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5mdW5jdGlvbiBSaXZlcihib2FyZCkge1xuICAgIFRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gRGlyZWN0aW9uLk5vcnRoO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IENvbG9ycy5CbHVlO1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IENvbG9ycy5CcmlnaHRCbHVlO1xuICAgIHRoaXMuc3BlZWQgPSAxO1xuICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xufVxuUml2ZXIucHJvdG90eXBlID0gbmV3IFRoaW5nKCk7XG5SaXZlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSaXZlcjtcblxuUml2ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgc3dpdGNoIChEaXJlY3Rpb24uZ2V0U2hvcnROYW1lKHRoaXMuZGlyZWN0aW9uKSkge1xuICAgIGNhc2UgJ04nOlxuICAgICAgICB0aGlzLnNwcml0ZUluZGV4ID0gMzA7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0UnOlxuICAgICAgICB0aGlzLnNwcml0ZUluZGV4ID0gMTY7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1MnOlxuICAgICAgICB0aGlzLnNwcml0ZUluZGV4ID0gMzE7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1cnOlxuICAgICAgICB0aGlzLnNwcml0ZUluZGV4ID0gMTc7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cblJpdmVyLnByb3RvdHlwZS51cGRhdGVXaGlsZVVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG59O1xuXG5SaXZlci5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHRoaW5nID0gdGhpcy5ib2FyZC5nZXRUaWxlKHRoaXMucG9pbnQpO1xuXG4gICAgaWYgKHRoaW5nLmNvbnZleWFibGUpIHtcbiAgICAgICAgdGhpbmcucHVzaCh0aGlzLmRpcmVjdGlvbiwgdGhpcyk7XG4gICAgfVxuXG59O1xuXG5SaXZlci5wcm90b3R5cGUuaXNTdXJyZW5kZXJhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuUml2ZXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5zZXJpYWxpemUuY2FsbCh0aGlzKTtcbiAgICBkZWxldGUgcmVzdWx0LmNvbG9yO1xuICAgIGRlbGV0ZSByZXN1bHQuc3BlZWQ7XG4gICAgcmVzdWx0LmRpcmVjdGlvbiA9IERpcmVjdGlvbi5nZXRTaG9ydE5hbWUodGhpcy5kaXJlY3Rpb24pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5SaXZlci5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuZGVzZXJpYWxpemUuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSBDb2xvcnMuQmx1ZTtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQnJpZ2h0Qmx1ZTtcbiAgICB0aGlzLmRpcmVjdGlvbiA9IERpcmVjdGlvbi5mcm9tTmFtZShkYXRhLmRpcmVjdGlvbik7XG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuLyoqXG4gKiBSdWZmaWFuIGlzIGFuIFVwZGF0ZWFibGVUaGluZyB0aGF0IGF0dGFja3MgaW4gYSBidXJzdCBvZiBtb3ZlbWVudCwgZm9sbG93ZWRcbiAqIGJ5IGEgd2FpdCB0aW1lLCB0aGVuIGFub3RoZXIgYnVyc3Qgb2YgbW92ZW1lbnQuXG4gKlxuICogQHBhcmFtIGJvYXJkIEFuIG93bmVyIGJvYXJkIGZvciB0aGlzIFJ1ZmZpYW4uXG4gKi9cbmZ1bmN0aW9uIFJ1ZmZpYW4oYm9hcmQpIHtcbiAgICBVcGRhdGVhYmxlVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IDU7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IENvbG9ycy5CcmlnaHRNYWdlbnRhO1xuICAgIHRoaXMuaW50ZWxsaWdlbmNlID0gNTtcbiAgICB0aGlzLnJlc3RpbmdUaW1lID0gNTtcbiAgICB0aGlzLm1vdmluZyA9IGZhbHNlO1xuICAgIHRoaXMudGltZUxlZnQgPSAwO1xuICAgIHRoaXMuc3BlZWQgPSAxO1xuICAgIHRoaXMub3JpZW50YXRpb24gPSBEaXJlY3Rpb24uTm9ydGg7XG4gICAgdGhpcy5jb252ZXlhYmxlID0gdHJ1ZTtcbn1cblJ1ZmZpYW4ucHJvdG90eXBlID0gbmV3IFVwZGF0ZWFibGVUaGluZygpO1xuUnVmZmlhbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSdWZmaWFuO1xuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhpcyBSdWZmaWFuIHRvIGEgZGF0YSBvYmplY3QuXG4gKlxuICogQHJldHVybiBBIHNlcmlhbGl6ZWQgUnVmZmlhbi5cbiAqL1xuUnVmZmlhbi5wcm90b3R5cGUuc2VyaWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBVcGRhdGVhYmxlVGhpbmcucHJvdG90eXBlLnNlcmlhbGl6ZS5jYWxsKHRoaXMpO1xuICAgIGRlbGV0ZSByZXN1bHQuY29sb3I7XG4gICAgcmVzdWx0LmludGVsbGlnZW5jZSA9IHRoaXMuaW50ZWxsaWdlbmNlO1xuICAgIHJlc3VsdC5yZXN0aW5nVGltZSA9IHRoaXMucmVzdGluZ1RpbWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRGVzZXJpYWxpemVzIGEgcHJvdmlkZWQgZGF0YSBvYmplY3QsIGNvbmZpZ3VyaW5nIHRoaXMgUnVmZmlhbi5cbiAqXG4gKiBAcGFyYW0gZGF0YSBBIGRhdGEgb2JqZWN0IHRvIGJlIGRlc2VyaWFsaXplZCBpbnRvIGEgUnVmZmlhbi5cbiAqL1xuUnVmZmlhbi5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuZGVzZXJpYWxpemUuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyaWdodE1hZ2VudGE7XG4gICAgdGhpcy5pbnRlbGxpZ2VuY2UgPSBkYXRhLmludGVsbGlnZW5jZSB8fCA1O1xuICAgIHRoaXMucmVzdGluZ1RpbWUgPSBkYXRhLnJlc3RpbmdUaW1lIHx8IDU7XG59O1xuXG4vKipcbiAqIFB1c2hlcyB0aGlzIFJ1ZmZpYW4gaW5zdGFuY2UgaW4gYSBnaXZlbiBkaXJlY3Rpb24uIElmIHRoaXMgUnVmZmlhblxuICogY2Fubm90IGJlIHB1c2hlZCwgaXQgd2lsbCBiZSBzcXVpc2hlZCBhbmQgcmVtb3ZlZCBmcm9tIGl0cyBvd25lciBCb2FyZC5cbiAqXG4gKiBAcGFyYW0gZGlyZWN0aW9uIEEgZGlyZWN0aW9uIGluIHdoaWNoIHRvIHB1c2ggdGhpcyBSdWZmaWFuLlxuICovXG5SdWZmaWFuLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgcHVzaGVyKSB7XG5cbiAgICBpZiAocHVzaGVyICYmIHB1c2hlci50eXBlID09PSAnUml2ZXInKSB7XG4gICAgICAgIHRoaXMubW92ZShkaXJlY3Rpb24sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMubW92ZShkaXJlY3Rpb24pKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMucGxheSgndCtjLS0tYysrKytjLS1jJyk7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcHJvdmlkZWQgbWVzc2FnZSB0byB0aGlzIFJ1ZmZpYW4uXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgQSBtZXNzYWdlIHRvIGJlIGRlbGl2ZXJlZCB0byB0aGlzIFJ1ZmZpYW4uXG4gKi9cblJ1ZmZpYW4ucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZSA9PT0gJ1NIT1QnIHx8IG1lc3NhZ2UgPT09ICdCT01CRUQnKSB7XG4gICAgICAgIHRoaXMucGxheSgndCtjLS0tYysrKytjLS1jJywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRqdXN0Q291bnRlcignU0NPUkUnLCAxMCk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlID09PSAnVE9VQ0gnKSB7XG4gICAgICAgIHRoaXMuYm9hcmQucGxheWVyLnNlbmRNZXNzYWdlKCdTSE9UJyk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoaXMgUnVmZmlhbiBzaG91bGQgc2VlayB0aGUgcGxheWVyIGR1cmluZyBpdHMgbmV4dCBtb3ZlLlxuICogVGhlIHByb2JhYmlsaXR5IG9mIGEgdHJ1ZSByZXN1bHQgZGVwZW5kcyBvbiB0aGlzIFJ1ZmZpYW4ncyBpbnRlbGxpZ2VuY2VcbiAqIHByb3BlcnR5LlxuICpcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGlzIFJ1ZmZpYW4gc2hvdWxkIHNlZWsgdGhlIHBsYXllciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5SdWZmaWFuLnByb3RvdHlwZS5zZWVrUGxheWVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHJhbmRvbVZhbHVlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApO1xuICAgIHJldHVybiByYW5kb21WYWx1ZSA8PSB0aGlzLmludGVsbGlnZW5jZTtcblxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhbiB1cGRhdGUgdGljayBmb3IgdGhpcyBSdWZmaWFuIGluc3RhbmNlLlxuICovXG5SdWZmaWFuLnByb3RvdHlwZS5kb1RpY2sgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAvLyBEZWNyZW1lbnQgb3VyIHJlbWFpbmluZyB0aW1lIGFuZCBjaGVjayBpZiBpdCBoYXMgZWxhcHNlZC4uLlxuICAgIHRoaXMudGltZUxlZnQgLT0gMTtcbiAgICBpZiAodGhpcy50aW1lTGVmdCA8PSAwKSB7XG5cbiAgICAgICAgLy8gVG9nZ2xlIG91ciBtb3ZlbWVudCBzdGF0dXNcbiAgICAgICAgdGhpcy5tb3ZpbmcgPSAhdGhpcy5tb3Zpbmc7XG5cbiAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gbW92ZSwgY2hvb3NlIGEgZGlyZWN0aW9uIGFuZCBkdXJhdGlvblxuICAgICAgICBpZiAodGhpcy5tb3ZpbmcpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZW50YXRpb24gPSB0aGlzLnNlZWtQbGF5ZXIoKSA/IHRoaXMuZ2V0UGxheWVyRGlyZWN0aW9uKCkgOiBEaXJlY3Rpb24ucmFuZG9tKCk7XG4gICAgICAgICAgICB0aGlzLnRpbWVMZWZ0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50aW1lTGVmdCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKSAtICgxMCAtIHRoaXMucmVzdGluZ1RpbWUpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSdyZSBtb3ZpbmcuLi5cbiAgICBpZiAodGhpcy5tb3ZpbmcpIHtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hhdCdzIGluIG91ciB3YXlcbiAgICAgICAgdmFyIHRoaW5nID0gdGhpcy5ib2FyZC5nZXRUaWxlKHRoaXMucG9pbnQuYWRkKHRoaXMub3JpZW50YXRpb24pKTtcblxuICAgICAgICAvLyBJZiBpdCdzIHRoZSBwbGF5ZXIsIGF0dGFjayBpdFxuICAgICAgICBpZiAodGhpbmcgJiYgdGhpbmcudHlwZSA9PT0gJ1BsYXllcicpIHtcbiAgICAgICAgICAgIHRoaW5nLnNlbmRNZXNzYWdlKCdTSE9UJyk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgbW92ZSBpbiB0aGUgZGlyZWN0aW9uIG9mIGEgUml2ZXJcbiAgICAgICAgaWYgKHRoaW5nICYmIHRoaW5nLnR5cGUgPT09ICdSaXZlcicgJiYgdGhpbmcuZGlyZWN0aW9uID09PSBEaXJlY3Rpb24ub3Bwb3NpdGUodGhpcy5vcmllbnRhdGlvbikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSBqdXN0IG1vdmVcbiAgICAgICAgdGhpcy5tb3ZlKHRoaXMub3JpZW50YXRpb24sIHRydWUpO1xuXG4gICAgfVxuXG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogU2lnbnBvc3QgaXMgYSBUaGluZyB0aGF0IGRpc3BsYXlzIGEgbWVzc2FnZSB3aGVuIHRvdWNoZWQuXG4gKlxuICogQHBhcmFtIGJvYXJkIEFuIG93bmVyIGJvYXJkXG4gKi9cbmZ1bmN0aW9uIFNpZ25wb3N0KGJvYXJkKSB7XG4gICAgVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IDIwOTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyb3duO1xuICAgIHRoaXMudGV4dCA9IHVuZGVmaW5lZDtcbn1cblNpZ25wb3N0LnByb3RvdHlwZSA9IG5ldyBUaGluZygpO1xuU2lnbnBvc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2lnbnBvc3Q7XG5cblNpZ25wb3N0LnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFRoaW5nLnByb3RvdHlwZS5zZXJpYWxpemUuY2FsbCh0aGlzKTtcbiAgICBkZWxldGUgcmVzdWx0LmNvbG9yO1xuICAgIHJlc3VsdC50ZXh0ID0gdGhpcy50ZXh0O1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5TaWducG9zdC5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIFRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQnJvd247XG4gICAgdGhpcy50ZXh0ID0gZGF0YS50ZXh0O1xufTtcblxuU2lnbnBvc3QucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblxuICAgIHZhciBsaW5lcyxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIHRleHQ7XG5cbiAgICBpZiAobWVzc2FnZSA9PT0gJ1RPVUNIJykge1xuXG4gICAgICAgIHRoaXMuYm9hcmQuZ2FtZS5zY3JvbGwuc2V0VGl0bGUoaTE4bi5nZXRNZXNzYWdlKCdvYnN0YWNsZXMuc2lnbnBvc3QnKSk7XG4gICAgICAgIHRoaXMuYm9hcmQuZ2FtZS5zY3JvbGwuY2xlYXJMaW5lcygpO1xuXG4gICAgICAgIGlmICghdGhpcy50ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnRleHQgPSBpMThuLmdldE1lc3NhZ2UoJ29ic3RhY2xlcy5zaWducG9zdG1lc3NhZ2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxpbmVzID0gdGhpcy50ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgbGluZXMubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgICB0ZXh0ID0gaTE4bi5nZXRCb2FyZE1lc3NhZ2UodGhpcy5ib2FyZCwgbGluZXNbaW5kZXhdKTtcbiAgICAgICAgICAgIHRoaXMuYm9hcmQuZ2FtZS5zY3JvbGwuYWRkTGluZSh0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGxheSgndGMtYytkLWQrZS1lK2YtZitnLWcnKTtcbiAgICAgICAgdGhpcy5ib2FyZC5nYW1lLnNldFN0YXRlKEdhbWVTdGF0ZS5SZWFkaW5nKTtcblxuICAgIH1cblxufTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFNsaWRlckV3IGlzIGEgVGhpbmcgdGhhdCBpcyBwdXNoYWJsZSBvbmx5IGluIHRoZSBFYXN0IGFuZCBXZXN0IGRpcmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gYm9hcmQgQW4gb3duZXIgYm9hcmQuXG4gKi9cbmZ1bmN0aW9uIFNsaWRlckV3KGJvYXJkKSB7XG4gICAgVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IDI5O1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQnJpZ2h0V2hpdGU7XG59XG5TbGlkZXJFdy5wcm90b3R5cGUgPSBuZXcgVGhpbmcoKTtcblNsaWRlckV3LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNsaWRlckV3O1xuXG4vKipcbiAqIFJlY2VpdmVzIGEgcmVxdWVzdCB0byBiZSBwdXNoZWQgaW4gYSBnaXZlbiBkaXJlY3Rpb24uXG4gKlxuICogQHBhcmFtIGRpcmVjdGlvbiBBIGRpcmVjdGlvbiBpbiB3aGljaCB0aGlzIFRoaW5nIGlzIHJlcXVlc3RlZCB0byBtb3ZlLlxuICovXG5TbGlkZXJFdy5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICBpZiAoZGlyZWN0aW9uLmVxdWFscyhEaXJlY3Rpb24uRWFzdCkgfHwgZGlyZWN0aW9uLmVxdWFscyhEaXJlY3Rpb24uV2VzdCkpIHtcbiAgICAgICAgaWYgKHRoaXMubW92ZShkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXkoJ3QtLWYnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogU2xpZGVyTnMgaXMgYSBUaGluZyB0aGF0IGlzIHB1c2hhYmxlIG9ubHkgaW4gdGhlIE5vcnRoIGFuZCBTb3V0aCBkaXJlY3Rpb24uXG4gKlxuICogQHBhcmFtIGJvYXJkIEFuIG93bmVyIGJvYXJkLlxuICovXG5mdW5jdGlvbiBTbGlkZXJOcyhib2FyZCkge1xuICAgIFRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMuc3ByaXRlSW5kZXggPSAxODtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyaWdodFdoaXRlO1xufVxuU2xpZGVyTnMucHJvdG90eXBlID0gbmV3IFRoaW5nKCk7XG5TbGlkZXJOcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTbGlkZXJOcztcblxuLyoqXG4gKiBSZWNlaXZlcyBhIHJlcXVlc3QgdG8gYmUgcHVzaGVkIGluIGEgZ2l2ZW4gZGlyZWN0aW9uLlxuICpcbiAqIEBwYXJhbSBkaXJlY3Rpb24gQSBkaXJlY3Rpb24gaW4gd2hpY2ggdGhpcyBUaGluZyBpcyByZXF1ZXN0ZWQgdG8gbW92ZS5cbiAqL1xuU2xpZGVyTnMucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbi5lcXVhbHMoRGlyZWN0aW9uLk5vcnRoKSB8fCBkaXJlY3Rpb24uZXF1YWxzKERpcmVjdGlvbi5Tb3V0aCkpIHtcbiAgICAgICAgaWYgKHRoaXMubW92ZShkaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXkoJ3QtLWYnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogU25ha2UgaXMgYSB0b3VjaCBiYWRkaWUgdGhhdCBpbnRlbGxpZ2VudGx5IGZpbmRzIHRoZSBwbGF5ZXIgYWxvbmcgYSBwcmVjb21wdXRlZFxuICogc21hcnQgcGF0aC5cbiAqL1xuZnVuY3Rpb24gU25ha2UoYm9hcmQpIHtcbiAgICBVcGRhdGVhYmxlVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IDIzNTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkdyZWVuO1xuICAgIHRoaXMuY29udmV5YWJsZSA9IHRydWU7XG4gICAgdGhpcy5zcGVlZCA9IDM7XG59XG5TbmFrZS5wcm90b3R5cGUgPSBuZXcgVXBkYXRlYWJsZVRoaW5nKCk7XG5TbmFrZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTbmFrZTtcblxuU25ha2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5zZXJpYWxpemUuY2FsbCh0aGlzKTtcbiAgICBkZWxldGUgcmVzdWx0LmNvbG9yO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHB1c2ggdGhpcyBTbmFrZSBpbiBhIHByb3ZpZGVkIGRpcmVjdGlvbi5cbiAqL1xuU25ha2UucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLm1vdmUoZGlyZWN0aW9uKSkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnBsYXkoJ3QrYy0tLWMrKysrYy0tYycpO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2VuZHMgYSBwcm92aWRlZCBtZXNzYWdlIHRvIHRoaXMgUnVmZmlhbi5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBBIG1lc3NhZ2UgdG8gYmUgZGVsaXZlcmVkIHRvIHRoaXMgUnVmZmlhbi5cbiAqL1xuU25ha2UucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZSA9PT0gJ1NIT1QnIHx8IG1lc3NhZ2UgPT09ICdCT01CRUQnKSB7XG4gICAgICAgIHRoaXMucGxheSgndCtjLS0tYysrKytjLS1jJywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRqdXN0Q291bnRlcignU0NPUkUnLCAxMCk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlID09PSAnVE9VQ0gnKSB7XG4gICAgICAgIHRoaXMuYm9hcmQucGxheWVyLnNlbmRNZXNzYWdlKCdTSE9UJyk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoaXMgU25ha2UuIFRoaXMgU25ha2Ugd2lsbCBtb3ZlIGl0c2VsZiBhbG9uZyB0aGUgYm9hcmQncyBjdXJyZW50XG4gKiBzbWFydCBwYXRoIGRpcmVjdGx5IHRvd2FyZCB0aGUgcGxheWVyLCBnb2luZyBhcm91bmQgd2FsbHMgYW5kIG9ic3RhY2xlcy5cbiAqIElmIHRoZXJlIGlzIG5vIGRpcmVjdCBwYXRoIHRvIHRoZSBwbGF5ZXIgKGluY2x1ZGluZyB0aHJvdWdoIGJ1bGxldHMgYW5kXG4gKiBvdGhlciBiYWRkaWVzKSwgdGhlbiBpdCB3aWxsIHJlc3QgaW4gcGxhY2UuXG4gKi9cblNuYWtlLnByb3RvdHlwZS5kb1RpY2sgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5nZXRTbWFydERpcmVjdGlvbigpLFxuICAgICAgICB0aGluZztcblxuICAgIGlmIChkaXJlY3Rpb24pIHtcblxuICAgICAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQnJpZ2h0R3JlZW47XG5cbiAgICAgICAgdGhpbmcgPSB0aGlzLmJvYXJkLmdldFRpbGUodGhpcy5wb2ludC5hZGQoZGlyZWN0aW9uKSk7XG4gICAgICAgIGlmICh0aGluZyAmJiB0aGluZy50eXBlID09PSAnUGxheWVyJykge1xuICAgICAgICAgICAgdGhpbmcuc2VuZE1lc3NhZ2UoJ1NIT1QnKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlKGRpcmVjdGlvbiwgdHJ1ZSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuR3JlZW47XG4gICAgfVxuXG5cbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAqIFNvbGlkV2FsbCBpcyBhIFRoaW5nIHJlcHJlc2VudGluZyBhbiBpbW1vdmVhYmxlIG9ic3RhY2xlLlxuICpcbiAqIEBwYXJhbSBib2FyZCBBbiBvd25lciBib2FyZCBmb3IgdGhpcyBTb2xpZFdhbGwuXG4gKi9cbmZ1bmN0aW9uIFNvbGlkV2FsbChib2FyZCkge1xuICAgIFRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMuc3ByaXRlSW5kZXggPSAyMTk7XG59XG5Tb2xpZFdhbGwucHJvdG90eXBlID0gbmV3IFRoaW5nKCk7XG5Tb2xpZFdhbGwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29saWRXYWxsO1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogU3BpZGVyIGlzIGFuIFVwZGF0ZWFibGVUaGluZyB0aGF0IG9ubHkgbW92ZXMgYWxvbmcgU3BpZGVXZWJzLlxuICpcbiAqIEBwYXJhbSBib2FyZCBBbiBvd25lciBCb2FyZCBmb3IgdGhpcyBTcGlkZXJcbiAqL1xuZnVuY3Rpb24gU3BpZGVyKGJvYXJkKSB7XG4gICAgVXBkYXRlYWJsZVRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMuc3ByaXRlSW5kZXggPSAxNTtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQnJpZ2h0UmVkO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmludGVsbGlnZW5jZSA9IDU7XG4gICAgdGhpcy5zcGVlZCA9IDE7XG59XG5TcGlkZXIucHJvdG90eXBlID0gbmV3IFVwZGF0ZWFibGVUaGluZygpO1xuU3BpZGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwaWRlcjtcblxuLyoqXG4gKiBTZXJpYWxpemVzIHRoaXMgU3BpZGVyIGluc3RhbmNlIGludG8gYSBkYXRhIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIEEgc2VyaWFsaXplZCBTcGlkZXJcbiAqL1xuU3BpZGVyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuc2VyaWFsaXplLmNhbGwodGhpcyk7XG4gICAgcmVzdWx0LmludGVsbGlnZW5jZSA9IHRoaXMuaW50ZWxsaWdlbmNlO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERlc2VyaWFsaXplcyBhIGRhdGEgb2JqZWN0IGFuZCBjb25maWd1cmUgdGhpcyBTcGlkZXIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIGRhdGEgQSBkYXRhIG9iamVjdCB0byBiZSBkZXNlcmlhbGl6ZWQgaW50byBhIFNwaWRlci5cbiAqL1xuU3BpZGVyLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHRoaXMuaW50ZWxsaWdlbmNlID0gZGF0YS5pbnRlbGxpZ2VuY2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhpcyBTcGlkZXIgaW5zdGFuY2Ugc2hvdWxkIHNlZWsgdGhlIHBsYXllclxuICogZm9yIGFuIGF0dGFjaywgb3IgY2hvb3NlIGEgcmFuZG9tIGRpcmVjdGlvbi4gVGhpcyBkZWNpc2lvbiBpcyB3ZWlnaHRlZFxuICogYmFzZWQgb24gdGhpcyBTcGlkZXIncyBpbnRlbGxpZ2VuY2UgcHJvcGVydHkuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoaXMgU3BpZGVyIHNob3VsZCBzZWVrIHRoZSBwbGF5ZXIsIGZhbHNlIG90aGVyd2lzZVxuICovXG5TcGlkZXIucHJvdG90eXBlLnNlZWtQbGF5ZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgcmFuZG9tVmFsdWUgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMCk7XG4gICAgcmV0dXJuIHJhbmRvbVZhbHVlIDw9IHRoaXMuaW50ZWxsaWdlbmNlO1xuXG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgYSBwb3NpdGlvbiBpbiBhIHByb3ZpZGVkIGRpcmVjdGlvbiBpcyBhdHRhY2thYmxlXG4gKiBieSB0aGlzIFNwaWRlci4gQXR0YWNrYWJsZSBwb3NpdGlvbnMgYXJlIGRlZmluZWQgYXMgc3BpZGVyIHdlYnNcbiAqIG9yIHNwb3RzIG9jY3VwaWVkIGJ5IGEgcGxheWVyLlxuICpcbiAqIHJldHVybiB0cnVlIGlmIGEgcHJvdmlkZWQgZGlyZWN0aW9uIGlzIGF0dGFja2FibGUsIGZhbHNlIG90aGVyd2lzZVxuICovXG5TcGlkZXIucHJvdG90eXBlLmlzQXR0YWNrYWJsZSA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICB2YXIgdGhpbmcgPSB0aGlzLmJvYXJkLmdldFRpbGUodGhpcy5wb2ludC5hZGQoZGlyZWN0aW9uKSk7XG4gICAgcmV0dXJuIHRoaW5nICYmICh0aGluZy50eXBlID09PSAnU3BpZGVyV2ViJyB8fCB0aGluZy50eXBlID09PSAnUGxheWVyJyk7XG59O1xuXG4vKipcbiAqIERlbGl2ZXJzIGEgcHJvdmlkZWQgbWVzc2FnZSB0byB0aGlzIFRoaW5nLiBJZiBhIFNIT1QgbWVzc2FnZSBpcyByZWNlaXZlZCxcbiAqIHRoZW4gdGhpcyBMaW9uIHdpbGwgYmUgZGVsZXRlZCBmcm9tIHRoZSBib2FyZC4gSWYgYSBUT1VDSCBtZXNzYWdlIGlzXG4gKiByZWNlaXZlZCwgdGhlbiB0aGUgcGxheWVyIHdpbGwgYmUgc2VudCBhIFNIT1QgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZU5hbWUgYSBuYW1lIG9mIGEgbWVzc2FnZSB0byBkZWxpdmVyLlxuICovXG5TcGlkZXIucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblxuICAgIGlmIChtZXNzYWdlID09PSAnU0hPVCcgfHwgbWVzc2FnZSA9PT0gJ0JPTUJFRCcpIHtcbiAgICAgICAgdGhpcy5wbGF5KCd0K2MtLS1jKysrK2MtLWMnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5hZGp1c3RDb3VudGVyKCdTQ09SRScsIDEwKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgPT09ICdUT1VDSCcpIHtcbiAgICAgICAgdGhpcy5ib2FyZC5wbGF5ZXIuc2VuZE1lc3NhZ2UoJ1NIT1QnKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogUmVjZWl2ZXMgYSByZXF1ZXN0IHRvIGJlIHB1c2hlZCBpbiBhIGdpdmVuIGRpcmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gZGlyZWN0aW9uIEEgZGlyZWN0aW9uIGluIHdoaWNoIHRoaXMgVGhpbmcgaXMgcmVxdWVzdGVkIHRvIG1vdmUuXG4gKi9cblNwaWRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMubW92ZShkaXJlY3Rpb24pKSB7XG4gICAgICAgIHRoaXMucGxheSgndCtjLS0tYysrKytjLS1jJyk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhbiB1cGRhdGUgdGljayBmb3IgdGhpcyBTcGlkZXIgaW5zdGFuY2UuXG4gKi9cblNwaWRlci5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgLy8gR2V0IGEgZGlyZWN0aW9uIGJhc2VkIG9uIG91ciBpbnRlbGxpZ2VuY2VcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5zZWVrUGxheWVyKCkgPyB0aGlzLmdldFBsYXllckRpcmVjdGlvbigpIDogRGlyZWN0aW9uLnJhbmRvbSh0aGlzLmdldEF0dGFja2FibGVEaXJlY3Rpb25zKCkpLFxuICAgICAgICB0aGluZztcblxuICAgIC8vIElmIGEgZGlyZWN0aW9uIHdhcyBkZWNpZGVkIHVwb24uLi5cbiAgICBpZiAoZGlyZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAvLyBEZXRlcm1pbmUgYW55IG9ic3RhY2xlIGluIG91ciB3YXlcbiAgICAgICAgdGhpbmcgPSB0aGlzLmJvYXJkLmdldFRpbGUodGhpcy5wb2ludC5hZGQoZGlyZWN0aW9uKSk7XG5cbiAgICAgICAgLy8gSWYgaXQncyBhIHBsYXllciwgYXR0YWNrIGl0XG4gICAgICAgIGlmICh0aGluZyAmJiB0aGluZy50eXBlID09PSAnUGxheWVyJykge1xuICAgICAgICAgICAgdGhpbmcuc2VuZE1lc3NhZ2UoJ1NIT1QnKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb3ZlIGFsb25nIHNwaWRlciB3ZWJzXG4gICAgICAgIGlmICh0aGluZyAmJiB0aGluZy50eXBlID09PSAnU3BpZGVyV2ViJykge1xuICAgICAgICAgICAgdGhpcy5tb3ZlKGRpcmVjdGlvbiwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgIH1cbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBTcGlkZXJXZWIgaXMgYSBUaGluZyB0aGF0IHJlcHJlc2VudHMgYSBwYXRoIGFsb25nIHdoaWNoIFNwaWRlcnMgd2lsbCB0cmF2ZWwuXG4gKlxuICogQHBhcmFtIGJvYXJkIEFuIG93bmVyIEJvYXJkIGZvciB0aGlzIFNwaWRlcldlYi5cbiAqL1xuZnVuY3Rpb24gU3BpZGVyV2ViKGJvYXJkKSB7XG4gICAgVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuR3JleTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG59XG5TcGlkZXJXZWIucHJvdG90eXBlID0gbmV3IFRoaW5nKCk7XG5TcGlkZXJXZWIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BpZGVyV2ViO1xuU3BpZGVyV2ViLmxpbmVNYXAgPSB7XG4gICAgJyc6IDI0OSxcbiAgICAnTic6IDE3OSxcbiAgICAnRSc6IDE5NixcbiAgICAnUyc6IDE3OSxcbiAgICAnVyc6IDE5NixcbiAgICAnTkUnOiAxOTIsXG4gICAgJ05TJzogMTc5LFxuICAgICdOVyc6IDIxNyxcbiAgICAnRVMnOiAyMTgsXG4gICAgJ0VXJzogMTk2LFxuICAgICdTVyc6IDE5MSxcbiAgICAnTkVTJzogMTk1LFxuICAgICdORVcnOiAxOTMsXG4gICAgJ05TVyc6IDE4MCxcbiAgICAnRVNXJzogMTk0LFxuICAgICdORVNXJzogMTk3XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhIHNwcml0ZSBpbmRleCB0byBiZSB1c2VkIGFzIGEgdmlzdWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgU3BpZGVyV2ViLlxuICogVGhlIGluZGV4IHJldHVybmVkIGRlcGVuZHMgb24gdGhlIHN1cnJvdW5pbmdzIG9mIHRoaXMgU3BpZGVyV2ViLCB3aGljaCB3aWxsIGFwcGVhclxuICogdG8gY29ubmVjdCB3aXRoIGFkamFjZW50IHNwaWRlciB3ZWJzLlxuICovXG5TcGlkZXJXZWIucHJvdG90eXBlLmdldFNwcml0ZUluZGV4ID0gZnVuY3Rpb24gKCkge1xuXG4gICAgaWYgKHRoaXMuc3ByaXRlSW5kZXggIT09IHVuZGVmaW5lZCAmJiAhdGhpcy5ib2FyZC5nYW1lLmlzRWRpdG9yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwcml0ZUluZGV4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTGluZUFkamFjZW50KHNvdXJjZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciB0aWxlID0gc291cmNlLmJvYXJkLmdldFRpbGUoc291cmNlLnBvaW50LmFkZChkaXJlY3Rpb24pKTtcbiAgICAgICAgcmV0dXJuICh0aWxlICYmICh0aWxlLnR5cGUgPT09ICdTcGlkZXJXZWInIHx8ICh0aWxlLnVuZGVyICYmIHRpbGUudW5kZXIudHlwZSA9PT0gJ1NwaWRlcldlYicpKSk7XG4gICAgfVxuXG4gICAgdmFyIHN1cnJvdW5kaW5nUGF0dGVybiA9ICcnO1xuICAgIHN1cnJvdW5kaW5nUGF0dGVybiArPSBpc0xpbmVBZGphY2VudCh0aGlzLCBEaXJlY3Rpb24uTm9ydGgpID8gJ04nIDogJyc7XG4gICAgc3Vycm91bmRpbmdQYXR0ZXJuICs9IGlzTGluZUFkamFjZW50KHRoaXMsIERpcmVjdGlvbi5FYXN0KSA/ICdFJyA6ICcnO1xuICAgIHN1cnJvdW5kaW5nUGF0dGVybiArPSBpc0xpbmVBZGphY2VudCh0aGlzLCBEaXJlY3Rpb24uU291dGgpID8gJ1MnIDogJyc7XG4gICAgc3Vycm91bmRpbmdQYXR0ZXJuICs9IGlzTGluZUFkamFjZW50KHRoaXMsIERpcmVjdGlvbi5XZXN0KSA/ICdXJyA6ICcnO1xuXG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IFNwaWRlcldlYi5saW5lTWFwW3N1cnJvdW5kaW5nUGF0dGVybl07XG4gICAgcmV0dXJuIHRoaXMuc3ByaXRlSW5kZXg7XG5cbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGlzIFNwaWRlcldlYiBpcyBzdXJyZW5kZXJhYmxlIHRvIGFub3RoZXIgdGhpbmcuXG4gKlxuICogQHBhcmFtIHNlbmRlciBBbm90aGVyIFRoaW5nIHRoYXQgaXMgcmVxdWVzdGluZyB0aGlzIFRoaW5nIHRvIHN1cnJlbmRlclxuICogQHJldHVybiB0cnVlIGlmIHRoaXMgVGhpbmcgaXMgd2lsbGluZyB0byBzdXJyZW5kZXIgaXRzIHBvc2l0aW9uLlxuICovXG5TcGlkZXJXZWIucHJvdG90eXBlLmlzU3VycmVuZGVyYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBTcGlubmluZ0d1biBpcyBhbiBVcGRhdGVhYmxlVGhpbmcgdGhhdCBzcGlucyBpbiBwbGFjZSBhbmQgc2hvb3RzLiBJdHMgc2hvb3RpbmdcbiAqIGJlaGF2aW91ciB3aWxsIGRlcGVuZCBvbiBpdHMgaW50ZWxsaWdlbmNlICh3aGljaCBhZmZlY3RzIHdoZW4gaXQgc2hvb3RzKSBhbmQgaXRzXG4gKiBmaXJpbmcgcmF0ZSAod2hpY2ggYWZmZWN0cyBob3cgb2Z0ZW4gaXQgc2hvb3RzKS5cbiAqXG4gKiBAcGFyYW0gYm9hcmQgQW4gb3duZXIgQm9hcmQgZm9yIHRoaXMgU3Bpbm5pbmdHdW4uXG4gKi9cbmZ1bmN0aW9uIFNwaW5uaW5nR3VuKGJvYXJkKSB7XG4gICAgVXBkYXRlYWJsZVRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMuaW50ZWxsaWdlbmNlID0gNTtcbiAgICB0aGlzLmZpcmluZ1JhdGUgPSA1O1xuICAgIHRoaXMuc3ByaXRlSW5kZXggPSAyNDtcbiAgICB0aGlzLmFuaW1hdGlvbkluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogU3Bpbm5pbmdHdW4uYW5pbWF0aW9uRnJhbWVzLmxlbmd0aCAtIDEpO1xuICAgIHRoaXMuc3BlZWQgPSAyO1xufVxuU3Bpbm5pbmdHdW4ucHJvdG90eXBlID0gbmV3IFVwZGF0ZWFibGVUaGluZygpO1xuU3Bpbm5pbmdHdW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3Bpbm5pbmdHdW47XG5TcGlubmluZ0d1bi5hbmltYXRpb25GcmFtZXMgPSBbMjQsIDI2LCAyNSwgMjddO1xuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhpcyBTcGlubmluZ0d1biBpbnN0YW5jZSBpbnRvIGEgZGF0YSBvYmplY3QuXG4gKlxuICogQHJldHVybiBBIHNlcmlhbGl6ZWQgU3Bpbm5pbmdHdW4uXG4gKi9cblNwaW5uaW5nR3VuLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuc2VyaWFsaXplLmNhbGwodGhpcyk7XG4gICAgcmVzdWx0LmludGVsbGlnZW5jZSA9IHRoaXMuaW50ZWxsaWdlbmNlO1xuICAgIHJlc3VsdC5maXJpbmdSYXRlID0gdGhpcy5maXJpbmdSYXRlO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHByb3ZpZGVkIGRhdGEgb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGlzIFNwaW5uaW5nR3VuIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBkYXRhIEEgc2VyaWFsaXplZCBTcGlubmluZ0d1biBkYXRhIG9iamVjdC5cbiAqL1xuU3Bpbm5pbmdHdW4ucHJvdG90eXBlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBVcGRhdGVhYmxlVGhpbmcucHJvdG90eXBlLmRlc2VyaWFsaXplLmNhbGwodGhpcywgZGF0YSk7XG4gICAgdGhpcy5pbnRlbGxpZ2VuY2UgPSBkYXRhLmludGVsbGlnZW5jZSB8fCA1O1xuICAgIHRoaXMuZmlyaW5nUmF0ZSA9IGRhdGEuZmlyaW5nUmF0ZSB8fCA1O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNpbmdsZSB1cGRhdGUgdGljayBvZiB0aGlzIFNwaW5uaW5nR3VuIGluc3RhbmNlLlxuICovXG5TcGlubmluZ0d1bi5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIG1lID0gdGhpcztcbiAgICBmdW5jdGlvbiBzaG9vdChyYW5kb20pIHtcbiAgICAgICAgaWYgKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKSA8PSBtZS5maXJpbmdSYXRlKSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gcmFuZG9tID8gRGlyZWN0aW9uLnJhbmRvbSgpIDogbWUuZ2V0UGxheWVyRGlyZWN0aW9uKCk7XG4gICAgICAgICAgICBUaGluZ0ZhY3Rvcnkuc2hvb3QobWUuYm9hcmQsIG1lLnBvaW50LmFkZChkaXJlY3Rpb24pLCBkaXJlY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRpb25JbmRleCArPSAxO1xuICAgIGlmICh0aGlzLmFuaW1hdGlvbkluZGV4ID49IFNwaW5uaW5nR3VuLmFuaW1hdGlvbkZyYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25JbmRleCA9IDA7XG4gICAgfVxuICAgIHRoaXMuc3ByaXRlSW5kZXggPSBTcGlubmluZ0d1bi5hbmltYXRpb25GcmFtZXNbdGhpcy5hbmltYXRpb25JbmRleF07XG5cbiAgICBpZiAoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOSkgPD0gdGhpcy5pbnRlbGxpZ2VuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNQbGF5ZXJBbGlnbmVkKDIpKSB7XG4gICAgICAgICAgICBzaG9vdCgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2hvb3QodHJ1ZSk7XG4gICAgfVxuXG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogVGVsZXBvcnRlciBpcyBhbiBVcGRhdGVhYmxlVGhpbmcgY2FwYWJsZSBvZiB0ZWxlcG9ydGluZyB0aGUgcGxheWVyXG4gKiB0byBhbiBhc3NvY2lhdGVkIG9wcG9zaXRlIHRlbGVwb3J0ZXIgYWxvbmcgdGhlIHNhbWUgZGlyZWN0aW9uYWwgYXhpcy5cbiAqXG4gKiBAcGFyYW0gYm9hcmQgQW4gb3duZXIgQm9hcmQgZm9yIHRoaXMgVGVsZXBvcnRlci5cbiAqL1xuZnVuY3Rpb24gVGVsZXBvcnRlcihib2FyZCkge1xuICAgIFVwZGF0ZWFibGVUaGluZy5jYWxsKHRoaXMsIGJvYXJkKTtcbiAgICB0aGlzLm9yaWVudGF0aW9uID0gRGlyZWN0aW9uLkVhc3Q7XG4gICAgdGhpcy5hbmltYXRpb25GcmFtZSA9IDI7XG4gICAgdGhpcy5zcGVlZCA9IDM7XG59XG5UZWxlcG9ydGVyLnByb3RvdHlwZSA9IG5ldyBVcGRhdGVhYmxlVGhpbmcoKTtcblRlbGVwb3J0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGVsZXBvcnRlcjtcblRlbGVwb3J0ZXIuYW5pbWF0aW9uRnJhbWVzID0ge1xuICAgICdOb3J0aCc6IFsxOTYsIDEyNiwgOTQsIDEyNl0sXG4gICAgJ0Vhc3QnOiBbMTc5LCA0MSwgNjIsIDQxXSxcbiAgICAnU291dGgnOiBbMTk2LCAxMjYsIDExOCwgMTI2XSxcbiAgICAnV2VzdCc6IFsxNzksIDQwLCA2MCwgNDBdXG59O1xuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhpcyBUZWxlcG9ydGVyIGluc3RhbmNlIGludG8gYSBkYXRhIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIEEgZGF0YSBvYmplY3QgcmVwcmVzZW50aW5nIGEgc2VyaWFsaXplZCBUZWxlcG9ydGVyLlxuICovXG5UZWxlcG9ydGVyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuc2VyaWFsaXplLmNhbGwodGhpcyk7XG4gICAgcmVzdWx0Lm9yaWVudGF0aW9uID0gRGlyZWN0aW9uLmdldE5hbWUodGhpcy5vcmllbnRhdGlvbik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRGVzZXJpYWxpemVzIGEgcHJvdmlkZWQgZGF0YSBvYmplY3QgdG8gY29uZmlndXJlIHRoaXMgVGVsZXBvcnRlciBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gZGF0YSBBIGRhdGEgb2JqZWN0IHJlcHJlc2VudGluZyBhIHNlcmlhbGl6ZWQgVGVsZXBvcnRlci5cbiAqL1xuVGVsZXBvcnRlci5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuZGVzZXJpYWxpemUuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICBpZiAoZGF0YS5vcmllbnRhdGlvbikge1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gRGlyZWN0aW9uLmZyb21OYW1lKGRhdGEub3JpZW50YXRpb24pO1xuICAgIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzaW5nbGUgdXBkYXRlIHRpY2sgb2YgdGhpcyBUZWxlcG9ydGVyIGluc3RhbmNlLlxuICovXG5UZWxlcG9ydGVyLnByb3RvdHlwZS5kb1RpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hbmltYXRpb25GcmFtZSArPSAxO1xuICAgIGlmICh0aGlzLmFuaW1hdGlvbkZyYW1lID49IFRlbGVwb3J0ZXIuYW5pbWF0aW9uRnJhbWVzW0RpcmVjdGlvbi5nZXROYW1lKHRoaXMub3JpZW50YXRpb24pXS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25GcmFtZSA9IDA7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYSBzcHJpdGUgaW5kZXggdXNlZCB0byB2aXN1YWxseSByZXByZXNlbnQgdGhpcyBUZWxlcG9ydGVyIGluc3RhbmNlIG9uXG4gKiBhIHJlbmRlcmVkIGdhbWUgQm9hcmQuXG4gKlxuICogQHJldHVybiBhIHNwcml0ZSBpbmRleC5cbiAqL1xuVGVsZXBvcnRlci5wcm90b3R5cGUuZ2V0U3ByaXRlSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRlbGVwb3J0ZXIuYW5pbWF0aW9uRnJhbWVzW0RpcmVjdGlvbi5nZXROYW1lKHRoaXMub3JpZW50YXRpb24pXVt0aGlzLmFuaW1hdGlvbkZyYW1lXTtcbn07XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcHVzaCB0aGlzIFRlbGVwb3J0ZXIgaW5zdGFuY2UgaW4gYSBnaXZlbiBkaXJlY3Rpb24uIFRoaXMgdGVsZXBvcnRlciwgcmF0aGVyIHRoYW5cbiAqIGJlIHB1c2hlZCwgbWF5IHRlbGVwb3J0IHRoZSBpdGVtIGJlaW5nIHB1c2hlZCB0byBhbm90aGVyIGxvY2F0aW9uIG9uIGl0cyBvd25lciBCb2FyZCwgYmFzZWRcbiAqIG9uIHRoaXMgVGVsZXBvcnRlcidzIG9yaWVudGF0aW9uLCBhbmQgdGhlIGxvY2F0aW9uIGFuZCBvcmllbnRhdGlvbiBvZiBvdGhlciBUZWxlcG9ydGVycyBvbiB0aGUgYm9hcmQuXG4gKlxuICogQHBhcmFtIGRpcmVjdGlvbiBBIGRpcmVjdGlvbiBpbiB3aGljaCB0byBwdXNoIHRoaXMgVGVsZXBvcnRlci5cbiAqL1xuVGVsZXBvcnRlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcblxuICAgIC8vIFdlIG9ubHkgdGVsZXBvcnQgaW4gb3VyIGN1cnJlbnQgZGlyZWN0aW9uXG4gICAgaWYgKCF0aGlzLm9yaWVudGF0aW9uLmVxdWFscyhkaXJlY3Rpb24pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFBvaW50ID0gdGhpcy5wb2ludC5hZGQoRGlyZWN0aW9uLm9wcG9zaXRlKHRoaXMub3JpZW50YXRpb24pKSxcbiAgICAgICAgZGVzdGluYXRpb25Qb2ludCA9IHRoaXMucG9pbnQuYWRkKHRoaXMub3JpZW50YXRpb24pLFxuICAgICAgICB0aGluZyxcbiAgICAgICAgdGlsZSA9IHRoaXMuYm9hcmQuZ2V0VGlsZShkZXN0aW5hdGlvblBvaW50KSxcbiAgICAgICAgc3VjY2VzcyA9IHRpbGUgJiYgdGlsZS50eXBlID09PSAnVGVsZXBvcnRlcicgPyBmYWxzZSA6IHRoaXMuYm9hcmQubW92ZVRpbGUoY3VycmVudFBvaW50LCBkZXN0aW5hdGlvblBvaW50KTtcblxuICAgIC8vIElmIHdlIGNvdWxkbid0IG1vdmUgdGhlIHRpbGUgdG8gdGhlIG90aGVyIHNpZGUgb2YgdGhpcyB0ZWxlcG9ydGVyLi4uXG4gICAgaWYgKCFzdWNjZXNzKSB7XG5cbiAgICAgICAgLy8gV2hpbGUgd2UgaGF2ZW4ndCByZWFjaGVkIHRoZSBlZGdlIG9mIHRoZSBib2FyZC4uLlxuICAgICAgICB3aGlsZSAoIXRoaXMuYm9hcmQuaXNPdXRzaWRlKGRlc3RpbmF0aW9uUG9pbnQpKSB7XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGZvdW5kIGEgbWF0Y2hpbmcgdGVsZXBvcnRlci4uLlxuICAgICAgICAgICAgdGhpbmcgPSB0aGlzLmJvYXJkLmdldFRpbGUoZGVzdGluYXRpb25Qb2ludCk7XG4gICAgICAgICAgICBpZiAodGhpbmcgJiYgdGhpbmcudHlwZSA9PT0gJ1RlbGVwb3J0ZXInICYmIHRoaW5nLm9yaWVudGF0aW9uID09PSBEaXJlY3Rpb24ub3Bwb3NpdGUodGhpcy5vcmllbnRhdGlvbikpIHtcblxuICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHRpbGUgdG8gdGhlIG1hdGNoaW5nIHRlbGVwb3J0ZXIncyBkZXN0aW5hdGlvblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvYXJkLm1vdmVUaWxlKGN1cnJlbnRQb2ludCwgZGVzdGluYXRpb25Qb2ludC5hZGQodGhpcy5vcmllbnRhdGlvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxheSgndGMrZC1lK2YjLWcjK2EjYytkJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMb29rIGF0IHRoZSBuZXh0IHRpbGUgaW4gdGhlIGRpcmVjdGlvblxuICAgICAgICAgICAgZGVzdGluYXRpb25Qb2ludCA9IGRlc3RpbmF0aW9uUG9pbnQuYWRkKHRoaXMub3JpZW50YXRpb24pO1xuXG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGxheSgndGMrZC1lK2YjLWcjK2EjYytkJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxufTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFRleHQgaXMgYSBUaGluZyB0aGF0IGRpc3BsYXlzIGEgY2hhcmFjdGVyIGRlcGVuZGluZyBvbiB0aGUgbG9jYWxlIG9mIHRoZSBnYW1lLlxuICpcbiAqIEBwYXJhbSBib2FyZCBBbiBvd25lciBib2FyZCBmb3IgdGhpcyBUaGluZy5cbiAqL1xuZnVuY3Rpb24gVGV4dChib2FyZCkge1xuICAgIFRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMuaTE4biA9IHtcbiAgICAgICAgZW46IDBcbiAgICB9O1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IENvbG9ycy5CcmlnaHRXaGl0ZTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSBDb2xvcnMuQmx1ZTtcbn1cblRleHQucHJvdG90eXBlID0gbmV3IFRoaW5nKCk7XG5UZXh0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHQ7XG5cbi8qKlxuICogU2VyaWFsaXplcyB0aGlzIFRleHQgaW50byBhIGRhdGEgb2JqZWN0LlxuICpcbiAqIEByZXR1cm4gQSBkYXRhIG9iamVjdCByZXByZXNlbnRpbmcgYSBzZXJpYWxpemVkIFRleHQuXG4gKi9cblRleHQucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gVGhpbmcucHJvdG90eXBlLnNlcmlhbGl6ZS5jYWxsKHRoaXMpO1xuICAgIHJlc3VsdC5pMThuID0gdGhpcy5pMThuO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHByb3ZpZGVkIGRhdGEgb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGlzIFRleHQgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIEEgZGF0YSBvYmplY3QgcmVwcmVzZW50aW5nIGEgc2VyaWFsaXplZCBUZXh0LlxuICovXG5UZXh0LnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICBUaGluZy5wcm90b3R5cGUuZGVzZXJpYWxpemUuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICB0aGlzLmkxOG4gPSBkYXRhLmkxOG47XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkJyaWdodFdoaXRlO1xuXG59O1xuXG5UZXh0LnByb3RvdHlwZS5nZXRTcHJpdGVJbmRleCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciByZXN1bHQ7XG5cbiAgICBpZiAodGhpcy5pMThuLmhhc093blByb3BlcnR5KGkxOG4uZ2V0TGFuZ3VhZ2UoKSkpIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5pMThuW2kxOG4uZ2V0TGFuZ3VhZ2UoKV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5pMThuW2kxOG4uRGVmYXVsdExhbmd1YWdlXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0IHx8IDA7XG5cbn07XG5cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFRocm93aW5nU3RhciBpcyBhbiBVcGRhdGVhYmxlVGhpbmcgcmVwcmVzZW50aW5nIGEgcHJvamVjdGlsZSB0aGF0IHNlZWtzIHRoZSBwbGF5ZXJcbiAqIGNvbnRpbnVhbGx5IHdpdGggYSBzcGlubmluZyBhbmltYXRpb24gdW50aWwgaXRzIHRpbWUgdG8gbGl2ZSBoYXMgZXhwaXJlZCBhbmQgaXRcbiAqIGlzIHJlbW92ZWQgZnJvbSBpdHMgb3duZXIgQm9hcmQuXG4gKlxuICogQHBhcmFtIGJvYXJkIEFuIG93bmVyIGJvYXJkIGZvciB0aGlzIFRocm93aW5nU3Rhci5cbiAqL1xuZnVuY3Rpb24gVGhyb3dpbmdTdGFyKGJvYXJkKSB7XG4gICAgVXBkYXRlYWJsZVRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMuc3BlZWQgPSAxO1xuICAgIHRoaXMuc3ByaXRlSW5kZXggPSAxNzk7XG4gICAgdGhpcy5hbmltYXRpb25JbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFRocm93aW5nU3Rhci5hbmltYXRpb25GcmFtZXMubGVuZ3RoIC0gMSk7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gQ29sb3JzLkN5Y2xlO1xuICAgIHRoaXMudGltZVRvTGl2ZSA9IDI1NTtcbiAgICB0aGlzLm5leHRNb3ZlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMik7XG59XG5UaHJvd2luZ1N0YXIucHJvdG90eXBlID0gbmV3IFVwZGF0ZWFibGVUaGluZygpO1xuVGhyb3dpbmdTdGFyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRocm93aW5nU3RhcjtcblRocm93aW5nU3Rhci5hbmltYXRpb25GcmFtZXMgPSBbMTc5LCA0NywgMTk2LCA5Ml07XG5cbi8qKlxuICogU2VyaWFsaXplcyB0aGlzIFRocm93aW5nU3RhciBpbnRvIGEgZGF0YSBvYmplY3QuXG4gKlxuICogQHJldHVybiBBIGRhdGEgb2JqZWN0IHJlcHJlc2VudGluZyBhIHNlcmlhbGl6ZWQgVGhyb3dpbmdTdGFyLlxuICovXG5UaHJvd2luZ1N0YXIucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5zZXJpYWxpemUuY2FsbCh0aGlzKTtcbiAgICBkZWxldGUgcmVzdWx0LmNvbG9yO1xuICAgIHJlc3VsdC50aW1lVG9MaXZlID0gdGhpcy50aW1lVG9MaXZlO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHByb3ZpZGVkIGRhdGEgb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGlzIFRocm93aW5nU3RhciBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0gQSBkYXRhIG9iamVjdCByZXByZXNlbnRpbmcgYSBzZXJpYWxpemVkIFRocm93aW5nU3Rhci5cbiAqL1xuVGhyb3dpbmdTdGFyLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgVXBkYXRlYWJsZVRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IENvbG9ycy5DeWNsZTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy50aW1lVG9MaXZlID0gZGF0YS50aW1lVG9MaXZlIHx8IDEwMDtcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwcm92aWRlZCBtZXNzYWdlIHRvIHRoaXMgVGhyb3dpbmdTdGFyIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlIEEgbWVzc2FnZSB0byBzZW5kIHRvIHRoaXMgVGhyb3dpbmdTdGFyLlxuICovXG5UaHJvd2luZ1N0YXIucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZSA9PT0gJ1RPVUNIJykge1xuICAgICAgICB0aGlzLmJvYXJkLnBsYXllci5zZW5kTWVzc2FnZSgnU0hPVCcpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBzaW5nbGUgdXBkYXRlIHRpY2sgb2YgdGhpcyBUaHJvd2luZ1N0YXIgaW5zdGFuY2UuXG4gKi9cblRocm93aW5nU3Rhci5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGRpcmVjdGlvbixcbiAgICAgICAgdGhpbmc7XG5cbiAgICB0aGlzLnRpbWVUb0xpdmUgLT0gMTtcbiAgICBpZiAodGhpcy50aW1lVG9MaXZlIDw9IDApIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYW5pbWF0aW9uSW5kZXggKz0gMTtcbiAgICBpZiAodGhpcy5hbmltYXRpb25JbmRleCA+PSBUaHJvd2luZ1N0YXIuYW5pbWF0aW9uRnJhbWVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkluZGV4ID0gMDtcbiAgICB9XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IFRocm93aW5nU3Rhci5hbmltYXRpb25GcmFtZXNbdGhpcy5hbmltYXRpb25JbmRleF07XG5cbiAgICB0aGlzLm5leHRNb3ZlIC09IDE7XG4gICAgaWYgKHRoaXMubmV4dE1vdmUgPD0gMCkge1xuXG4gICAgICAgIHRoaXMubmV4dE1vdmUgPSAyO1xuXG4gICAgICAgIGRpcmVjdGlvbiA9IHRoaXMuZ2V0UGxheWVyRGlyZWN0aW9uKCk7XG4gICAgICAgIHRoaW5nID0gdGhpcy5ib2FyZC5nZXRUaWxlKHRoaXMucG9pbnQuYWRkKGRpcmVjdGlvbikpO1xuICAgICAgICBpZiAodGhpbmcgJiYgKHRoaW5nLnR5cGUgPT09ICdCcmVha2FibGVXYWxsJyB8fCB0aGluZy50eXBlID09PSAnUGxheWVyJykpIHtcbiAgICAgICAgICAgIHRoaW5nLnNlbmRNZXNzYWdlKCdTSE9UJyk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92ZSh0aGlzLmdldFBsYXllckRpcmVjdGlvbigpKTtcbiAgICB9XG5cbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBUaWdlciBpcyBhbiBVcGRhdGVhYmxlVGhpbmcgcmVwcmVzZW50aW5nIGEgY3JlYXR1cmUgdGhhdCBtb3ZlcyBhbmQgc2hvb3RzXG4gKiBidWxsZXRzIGF0IGEgcGxheWVyLlxuICpcbiAqIEBwYXJhbSBib2FyZCBBbiBvd25lciBCb2FyZCBmb3IgdGhpcyBUaWdlci5cbiAqL1xuZnVuY3Rpb24gVGlnZXIoYm9hcmQpIHtcbiAgICBVcGRhdGVhYmxlVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IDIyNztcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQnJpZ2h0Q3lhbjtcbiAgICB0aGlzLmJhY2tncm91bmQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pbnRlbGxpZ2VuY2UgPSA1O1xuICAgIHRoaXMuZmlyaW5nUmF0ZSA9IDU7XG4gICAgdGhpcy5zcGVlZCA9IDI7XG4gICAgdGhpcy5jb252ZXlhYmxlID0gdHJ1ZTtcbn1cblRpZ2VyLnByb3RvdHlwZSA9IG5ldyBVcGRhdGVhYmxlVGhpbmcoKTtcblRpZ2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRpZ2VyO1xuXG4vKipcbiAqIFNlcmlhbGl6ZXMgdGhpcyBUaWdlciBpbnRvIGEgZGF0YSBvYmplY3QuXG4gKlxuICogQHJldHVybiBBIGRhdGEgb2JqZWN0IHJlcHJlc2VudGluZyBhIHNlcmlhbGl6ZWQgVGlnZXIuXG4gKi9cblRpZ2VyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuc2VyaWFsaXplLmNhbGwodGhpcyk7XG4gICAgZGVsZXRlIHJlc3VsdC5jb2xvcjtcbiAgICByZXN1bHQuaW50ZWxsaWdlbmNlID0gdGhpcy5pbnRlbGxpZ2VuY2U7XG4gICAgcmVzdWx0LmZpcmluZ1JhdGUgPSB0aGlzLmZpcmluZ1JhdGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRGVzZXJpYWxpemVzIGEgcHJvdmlkZWQgZGF0YSBvYmplY3QgdG8gY29uZmlndXJlIHRoaXMgVGlnZXIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIGRhdGEgQSBkYXRhIG9iamVjdCByZXByZXNlbnRpbmcgYSBzZXJpYWxpemVkIFRpZ2VyLlxuICovXG5UaWdlci5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIFVwZGF0ZWFibGVUaGluZy5wcm90b3R5cGUuZGVzZXJpYWxpemUodGhpcywgZGF0YSk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IENvbG9ycy5CcmlnaHRDeWFuO1xuICAgIHRoaXMuaW50ZWxsaWdlbmNlID0gZGF0YS5pbnRlbGxpZ2VuY2UgPT09IHVuZGVmaW5lZCA/IDUgOiBkYXRhLmludGVsbGlnZW5jZTtcbiAgICB0aGlzLmZpcmluZ1JhdGUgPSBkYXRhLmZpcmluZ1JhdGUgPT09IHVuZGVmaW5lZCA/IDUgOiBkYXRhLmZpcmluZ1JhdGU7XG59O1xuXG4vKipcbiAqIERlbGl2ZXJzIGEgcHJvdmlkZWQgbWVzc2FnZSB0byB0aGlzIFRoaW5nLiBJZiBhIFNIT1QgbWVzc2FnZSBpcyByZWNlaXZlZCxcbiAqIHRoZW4gdGhpcyBUaWdlciB3aWxsIGJlIGRlbGV0ZWQgZnJvbSB0aGUgYm9hcmQuIElmIGEgVE9VQ0ggbWVzc2FnZSBpc1xuICogcmVjZWl2ZWQsIHRoZW4gdGhlIHBsYXllciB3aWxsIGJlIHNlbnQgYSBTSE9UIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VOYW1lIGEgbmFtZSBvZiBhIG1lc3NhZ2UgdG8gZGVsaXZlci5cbiAqL1xuVGlnZXIucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblxuICAgIGlmIChtZXNzYWdlID09PSAnU0hPVCcgfHwgbWVzc2FnZSA9PT0gJ0JPTUJFRCcpIHtcbiAgICAgICAgdGhpcy5wbGF5KCd0K2MtLS1jKysrK2MtLWMnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5hZGp1c3RDb3VudGVyKCdTQ09SRScsIDEwKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgPT09ICdUT1VDSCcpIHtcbiAgICAgICAgdGhpcy5ib2FyZC5wbGF5ZXIuc2VuZE1lc3NhZ2UoJ1NIT1QnKTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9XG5cbn07XG5cbi8qKlxuICogUmVjZWl2ZXMgYSByZXF1ZXN0IHRvIGJlIHB1c2hlZCBpbiBhIGdpdmVuIGRpcmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0gZGlyZWN0aW9uIEEgZGlyZWN0aW9uIGluIHdoaWNoIHRoaXMgVGhpbmcgaXMgcmVxdWVzdGVkIHRvIG1vdmUuXG4gKi9cblRpZ2VyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRpcmVjdGlvbiwgcHVzaGVyKSB7XG5cbiAgICBpZiAocHVzaGVyICYmIHB1c2hlci50eXBlID09PSAnUml2ZXInKSB7XG4gICAgICAgIHRoaXMubW92ZShkaXJlY3Rpb24sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMubW92ZShkaXJlY3Rpb24pKSB7XG4gICAgICAgIHRoaXMucGxheSgndCtjLS0tYysrKytjLS1jJyk7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuXG59O1xuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhpcyBUaWdlciBzaG91bGQgc2VlayB0aGUgcGxheWVyIGR1cmluZyBpdHMgbmV4dCBtb3ZlLlxuICogVGhlIHByb2JhYmlsaXR5IG9mIGEgdHJ1ZSByZXN1bHQgZGVwZW5kcyBvbiB0aGlzIFRpZ2VyJ3MgaW50ZWxsaWdlbmNlXG4gKiBwcm9wZXJ0eS5cbiAqXG4gKiBAcmV0dXJuIHRydWUgaWYgdGhpcyBUaWdlciBzaG91bGQgc2VlayB0aGUgcGxheWVyLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cblRpZ2VyLnByb3RvdHlwZS5zZWVrUGxheWVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIHJhbmRvbVZhbHVlID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApO1xuICAgIHJldHVybiByYW5kb21WYWx1ZSA8PSB0aGlzLmludGVsbGlnZW5jZTtcblxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoaXMgVGlnZXIgc2hvdWxkIHNob290IHRoZSBwbGF5ZXIgZHVyaW5nIGl0cyBuZXh0XG4gKiBtb3ZlLiBUaGUgcHJvYmFiaWxpdHkgb2YgYSB0cnVlIHJlc3VsdCBkZXBlbmRzIG9uIHRoaXMgVGlnZXIncyBmaXJpbmcgcmF0ZVxuICogcHJvcGVydHkuXG4gKlxuICogQHJldHVybiB0cnVlIGlmIHRoaXMgVGlnZXIgc2hvdWxkIHNob290IHRoZSBwbGF5ZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuVGlnZXIucHJvdG90eXBlLnNob290UGxheWVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByYW5kb21WYWx1ZSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDIwKTtcbiAgICByZXR1cm4gcmFuZG9tVmFsdWUgPD0gdGhpcy5maXJpbmdSYXRlO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNpbmdsZSB1cGRhdGUgdGljayBvZiB0aGlzIFRpZ2VyLlxuICovXG5UaWdlci5wcm90b3R5cGUuZG9UaWNrID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuc2Vla1BsYXllcigpID8gdGhpcy5nZXRQbGF5ZXJEaXJlY3Rpb24oKSA6IERpcmVjdGlvbi5yYW5kb20oKSxcbiAgICAgICAgdGhpbmcgPSB0aGlzLmJvYXJkLmdldFRpbGUodGhpcy5wb2ludC5hZGQoZGlyZWN0aW9uKSksXG4gICAgICAgIHBsYXllckRpcmVjdGlvbjtcblxuICAgIGlmICh0aGluZyAmJiB0aGluZy50eXBlID09PSAnUGxheWVyJykge1xuICAgICAgICB0aGluZy5zZW5kTWVzc2FnZSgnU0hPVCcpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgYXR0ZW1wdCB0byBtb3ZlIGluIHRoZSBkaXJlY3Rpb24gb2YgYSByaXZlclxuICAgIGlmICghKHRoaW5nICYmIHRoaW5nLnR5cGUgPT09ICdSaXZlcicgJiYgdGhpbmcuZGlyZWN0aW9uID09PSBEaXJlY3Rpb24ub3Bwb3NpdGUoZGlyZWN0aW9uKSkpIHtcbiAgICAgICAgdGhpcy5tb3ZlKGRpcmVjdGlvbiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2hvb3RQbGF5ZXIoKSkge1xuICAgICAgICBwbGF5ZXJEaXJlY3Rpb24gPSB0aGlzLmdldFBsYXllckRpcmVjdGlvbigpO1xuICAgICAgICBUaGluZ0ZhY3Rvcnkuc2hvb3QodGhpcy5ib2FyZCwgdGhpcy5wb2ludC5hZGQocGxheWVyRGlyZWN0aW9uKSwgcGxheWVyRGlyZWN0aW9uKTtcbiAgICB9XG5cbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAqXG4gKi9cbmZ1bmN0aW9uIFRvcmNoKGJvYXJkKSB7XG4gICAgVGhpbmcuY2FsbCh0aGlzLCBib2FyZCk7XG4gICAgdGhpcy5zcHJpdGVJbmRleCA9IDE1NztcbiAgICB0aGlzLmdsb3cgPSB0cnVlO1xufVxuVG9yY2gucHJvdG90eXBlID0gbmV3IFRoaW5nKCk7XG5Ub3JjaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb3JjaDtcblxuVG9yY2gucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVzdWx0ID0gVGhpbmcucHJvdG90eXBlLnNlcmlhbGl6ZS5jYWxsKHRoaXMpO1xuICAgIGRlbGV0ZSByZXN1bHQuY29sb3I7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRvcmNoLnByb3RvdHlwZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgVGhpbmcucHJvdG90eXBlLmRlc2VyaWFsaXplLmNhbGwodGhpcywgZGF0YSk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZm9yZWdyb3VuZCA9IENvbG9ycy5Ccm93bjtcbn07XG5cbi8qKlxuICogUHVzaGVzIHRoaXMgVG9yY2ggaW4gYSBwcm92aWRlZCBkaXJlY3Rpb24gb24gaXRzIG93bmVyIEJvYXJkLlxuICpcbiAqIEBwYXJhbSBkaXJlY3Rpb24gQSBkaXJlY3Rpb24gaW4gd2hpY2ggdG8gcHVzaCB0aGlzIFRvcmNoXG4gKi9cblRvcmNoLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRpcmVjdGlvbikge1xuICAgIHRoaXMubW92ZShkaXJlY3Rpb24pO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHByb3ZpZGVkIG1lc3NhZ2UgdG8gdGhpcyBUb3JjaCBpbnN0YW5jZS4gSWYgYSBUT1VDSCBtZXNzYWdlIGlzIHJlY2VpdmVkXG4gKiB0aGVuIHRoaXMgVG9yY2ggaW5zdGFuY2Ugd2lsbCBiZSByZW1vdmVkIGFuZCBpbmNyZWFzZSB0aGUgR2FtZSdzICd0b3JjaGVzJyBjb3VudGVyXG4gKiBieSBmaXZlIHVuaXRzLlxuICovXG5Ub3JjaC5wcm90b3R5cGUuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlID09PSAnVE9VQ0gnKSB7XG4gICAgICAgIHRoaXMub25lVGltZU1lc3NhZ2UoJ3N0YXR1cy50b3JjaCcpO1xuICAgICAgICB0aGlzLnBsYXkoJ3RjYXNlJyk7XG4gICAgICAgIHRoaXMuYWRqdXN0Q291bnRlcignVE9SQ0hFUycsIDEpO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgIH1cbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLypcbiAqIFdhbGwgaXMgYSBUaGluZyByZXByZXNlbnRpbmcgYW4gaW1tb3ZlYWJsZSBvYnN0YWNsZS5cbiAqXG4gKiBAcGFyYW0gYm9hcmQgQW4gb3duZXIgYm9hcmQgZm9yIHRoaXMgV2FsbC5cbiAqL1xuZnVuY3Rpb24gV2FsbChib2FyZCkge1xuICAgIFRoaW5nLmNhbGwodGhpcywgYm9hcmQpO1xuICAgIHRoaXMuc3ByaXRlSW5kZXggPSAxNzg7XG59XG5XYWxsLnByb3RvdHlwZSA9IG5ldyBUaGluZygpO1xuV2FsbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXYWxsO1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qXG4gKiBXYXRlciBpcyBhIFRoaW5nIHJlcHJlc2VudGluZyBhbiBvYnN0YWNsZSB0byBtb3N0IFRoaW5ncywgZXhjZXB0IGZvclxuICogYnVsbGV0cyBhbmQgb3RoZXIgcG90ZW50aWFsbHkgZmx5aW5nIFRoaW5ncywgd2hpY2ggY2FuIHBhc3Mgb3ZlciBpdC5cbiAqL1xuZnVuY3Rpb24gV2F0ZXIoYm9hcmQpIHtcbiAgICBUaGluZy5jYWxsKHRoaXMsIGJvYXJkKTtcbiAgICB0aGlzLnNwcml0ZUluZGV4ID0gMTc2O1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IENvbG9ycy5CcmlnaHRXaGl0ZTtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQnJpZ2h0Qmx1ZTtcbn1cbldhdGVyLnByb3RvdHlwZSA9IG5ldyBUaGluZygpO1xuV2F0ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2F0ZXI7XG5cbldhdGVyLnByb3RvdHlwZS5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFRoaW5nLnByb3RvdHlwZS5zZXJpYWxpemUuY2FsbCh0aGlzKTtcbiAgICBkZWxldGUgcmVzdWx0LmNvbG9yO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5XYXRlci5wcm90b3R5cGUuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIFRoaW5nLnByb3RvdHlwZS5kZXNlcmlhbGl6ZS5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHRoaXMuYmFja2dyb3VuZCA9IENvbG9ycy5CcmlnaHRXaGl0ZTtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBDb2xvcnMuQnJpZ2h0Qmx1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGlzIFdhdGVyIGlzIHN1cnJlbmRlcmFibGUgdG8gYSBwcm92aWRlZFxuICogc2VuZGVyLiBXYXRlciB3aWxsIHJldHVybiB0cnVlIGlmIHRoZSBzZW5kZXIgaXMgYSBidWxsZXQgb3IgVGhyb3dpbmdTdGFyLFxuICogYnV0IGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuV2F0ZXIucHJvdG90eXBlLmlzU3VycmVuZGVyYWJsZSA9IGZ1bmN0aW9uIChzZW5kZXIpIHtcbiAgICBpZiAoc2VuZGVyICYmIChzZW5kZXIudHlwZSA9PT0gJ0J1bGxldCcgfHwgc2VuZGVyLnR5cGUgPT09ICdUaHJvd2luZ1N0YXInKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcHJvdmlkZWQgbWVzc2FnZSB0byB0aGlzIFdhdGVyLiBJZiBhIFRPVUNIIG1lc3NhZ2UgaXMgcmVjZWl2ZWQsIHRoZW5cbiAqIGEgc291bmQgZWZmZWN0IGlzIHBsYXllZCBhbmQgYSBtZXNzYWdlIGluZGljYXRpbmcgdGhhdCBwbGF5ZXJzIGNhbm5vdFxuICogbW92ZSB0aHJvdWdoIHdhdGVyIGlzIHNob3duLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlIEEgbWVzc2FnZSB0byBiZSBkZWxpdmVyZWQgdG8gdGhpcyBXYXRlci5cbiAqL1xuV2F0ZXIucHJvdG90eXBlLnNlbmRNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAobWVzc2FnZSA9PT0gJ1RPVUNIJykge1xuICAgICAgICB0aGlzLnBsYXkoJ3QrYytjJyk7XG4gICAgICAgIHRoaXMuYm9hcmQuc2V0RGlzcGxheU1lc3NhZ2UoaTE4bi5nZXRNZXNzYWdlKCdvYnN0YWNsZXMud2F0ZXInKSwgMSk7XG4gICAgfVxufTtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBUSElORyBGQUNUT1JZXG4gKj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBUaGluZyBiYXNlZCBvbiBwcm92aWRlZCBzZXJpYWxpemVkIGRhdGEsIGFuZCBhc3NpZ25zIGl0IHRvIGEgZ2l2ZW4gYm9hcmQuXG4gKlxuICogQHBhcmFtIGRhdGEgU2VyaWFsaXplZCBkYXRhIHRvIHR1cm4gaW50byBhIFRoaW5nXG4gKiBAcGFyYW0gYm9hcmQgQSBib2FyZCB3aGljaCBzaG91bGQgb3duIHRoZSBjcmVhdGVkIFRoaW5nLlxuICovXG5UaGluZ0ZhY3RvcnkuZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoZGF0YSwgYm9hcmQpIHtcblxuICAgIHZhciB0aGluZ01hcCxcbiAgICAgICAgVGhpbmdGdW5jdGlvbixcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGRhdGEgJiYgZGF0YS50eXBlKSB7XG5cbiAgICAgICAgdGhpbmdNYXAgPSBUaGluZ0ZhY3RvcnkuZ2V0VGhpbmdNYXAoKTtcbiAgICAgICAgVGhpbmdGdW5jdGlvbiA9IHRoaW5nTWFwW2RhdGEudHlwZS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoVGhpbmdGdW5jdGlvbikge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFRoaW5nRnVuY3Rpb24oYm9hcmQpO1xuICAgICAgICAgICAgcmVzdWx0LmRlc2VyaWFsaXplKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIGEgcHJvdmlkZWQgbmFtZSBjb3JyZXNwb25kcyB0byBhIGtub3duIHRoaW5nIHRoYXQgaXMgY2FwYWJsZSBvZiBiZWluZyBkZXNlcmlhbGl6ZWQuXG4gKlxuICogQHBhcmFtIHRoaW5nTmFtZSBBIG5hbWUgb2YgYSB0aGluZ1xuICogQHJldHVybiB0cnVlIGlmIGEgVGhpbmcgb2YgYSBnaXZlbiBuYW1lIGV4aXN0cywgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cblRoaW5nRmFjdG9yeS5pc0tub3duVGhpbmcgPSBmdW5jdGlvbiAodGhpbmdOYW1lKSB7XG5cbiAgICB2YXIgdGhpbmdNYXAgPSBUaGluZ0ZhY3RvcnkuZ2V0VGhpbmdNYXAoKTtcblxuICAgIHJldHVybiAodGhpbmdNYXBbdGhpbmdOYW1lLnRvVXBwZXJDYXNlKCldICE9PSB1bmRlZmluZWQpO1xuXG59O1xuXG4vKipcbiAqIExhemlseSBmZXRjaGVzIGEgbWFwIG9mIFRoaW5ncyB0aGF0IGhhdmUgZGVjbGFyZWQgdGhlbXNlbGYgYXMgc2VyaWFsaXplYWJsZSAuXG4gKlxuICogQHJldHVybiBBIG1hcCBvZiBUaGluZyBmdW5jdGlvbnMgaW5kZXhlZCBieSB0aGVpciBzeW1ib2xzIG9yIHNlcmlhbGl6YXRpb24gdHlwZXMuXG4gKi9cblRoaW5nRmFjdG9yeS5nZXRUaGluZ01hcCA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciB0aGluZztcblxuICAgIC8vIElmIHdlIGhhdmVuJ3QgeWV0IGNvbnN0cnVjdGVkIG91ciB0aGluZyBtYXAuLi5cbiAgICBpZiAoVGhpbmdGYWN0b3J5LnRoaW5nTWFwID09PSB1bmRlZmluZWQpIHtcblxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgdGhpbmcgbWFwXG4gICAgICAgIFRoaW5nRmFjdG9yeS50aGluZ01hcCA9IHt9O1xuXG4gICAgICAgIC8vIEZvciBlYWNoIHRoaW5nIGRlZmluZWQgaW4gdGhpcyBtb2R1bGUuLi5cbiAgICAgICAgZm9yICh0aGluZyBpbiBleHBvcnRzLnRoaW5ncykge1xuXG4gICAgICAgICAgICAvLyBJZiBpdCdzIGEgVGhpbmcgd2l0aCBhIGRlZmluZWQgdHlwZS4uLlxuICAgICAgICAgICAgaWYgKGV4cG9ydHMudGhpbmdzLmhhc093blByb3BlcnR5KHRoaW5nKSAmJiBleHBvcnRzLnRoaW5nc1t0aGluZ10udHlwZSkge1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGl0IHRvIG91ciB0aGluZyBtYXAgYnkgaXRzIHVwcGVyY2FzZSBuYW1lXG4gICAgICAgICAgICAgICAgVGhpbmdGYWN0b3J5LnRoaW5nTWFwW3RoaW5nLnRvVXBwZXJDYXNlKCldID0gZXhwb3J0cy50aGluZ3NbdGhpbmddO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gVGhpbmdGYWN0b3J5LnRoaW5nTWFwO1xuXG59O1xuXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBCdWxsZXQgVGhpbmcgb24gYSBwcm92aWRlZCBib2FyZCBhdCBhIGdpdmVuIHBvaW50LCBvcmllbnRlZCBpblxuICogYSBwcm92aWRlZCBkaXJlY3Rpb24uIElmIHRoZSBwcm92aWRlZCBwb2ludCBpcyBibG9ja2VkIGJ5IGFub3RoZXIgVXBkYXRlYWJsZVRoaW5nLFxuICogdGhlbiB0aGF0IFVwZGF0ZWFibGVUaGluZyB3aWxsIGJlIHNlbnQgYSAnU0hPVCcgbWVzc2FnZS5cbiAqL1xuVGhpbmdGYWN0b3J5LnNob290ID0gZnVuY3Rpb24gKGJvYXJkLCBwb2ludCwgZGlyZWN0aW9uLCBmcm9tUGxheWVyLCB0aHJvd2luZ1N0YXIpIHtcblxuICAgIC8vIEZpcnN0LCBnZXQgb3VyIGRlc3RpbmF0aW9uIHRpbGVcbiAgICB2YXIgdGlsZSA9IGJvYXJkLmdldFRpbGUocG9pbnQpLFxuICAgICAgICBidWxsZXQgPSB0aHJvd2luZ1N0YXIgPyBuZXcgVGhyb3dpbmdTdGFyKGJvYXJkKSA6IG5ldyBCdWxsZXQoYm9hcmQpO1xuXG4gICAgYnVsbGV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICBpZiAoZnJvbVBsYXllcikge1xuICAgICAgICBidWxsZXQuZnJvbVBsYXllciA9IGZyb21QbGF5ZXI7XG4gICAgfVxuXG5cbiAgICBpZiAodGlsZSA9PT0gdW5kZWZpbmVkIHx8IHRpbGUuaXNTdXJyZW5kZXJhYmxlKGJ1bGxldCkpIHtcblxuICAgICAgICAvLyBXZSdyZSBhbGxvd2VkIHRvIHNwYXduIGEgYnVsbGV0IGhlcmVcbiAgICAgICAgYm9hcmQuYWRkVGhpbmcocG9pbnQsIGJ1bGxldCwgdHJ1ZSk7XG4gICAgICAgIGlmIChmcm9tUGxheWVyKSB7XG4gICAgICAgICAgICBib2FyZC5nYW1lLnJlc291cmNlcy5hdWRpby5wbGF5KCd0K2MtYy1jJyk7XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAoZnJvbVBsYXllciAmJiB0aWxlICYmIHRpbGUudHlwZSA9PT0gJ1JpY29jaGV0Jykge1xuXG4gICAgICAgIC8vIFRoZSBidWxsZXQgaXMgZnJvbSB0aGUgcGxheWVyIGFuZCB0aGUgdGlsZSBpcyBhIFJpY29jaGV0LFxuICAgICAgICAvLyBzbyBzaG9vdCB0aGUgbWVzc2VuZ2VyXG4gICAgICAgIGJvYXJkLnBsYXllci5zZW5kTWVzc2FnZSgnU0hPVCcpO1xuXG4gICAgfSBlbHNlIGlmIChmcm9tUGxheWVyIHx8ICh0aWxlICYmICh0aWxlLnR5cGUgPT09ICdQbGF5ZXInIHx8IHRpbGUudHlwZSA9PT0gJ1NjcmlwdGFibGUnIHx8IHRpbGUudHlwZSA9PT0gJ0JyZWFrYWJsZVdhbGwnKSkpIHtcblxuICAgICAgICAvLyBUaGUgYnVsbGV0IGlzIGZyb20gdGhlIHBsYXllciwgb3IgdGhlIHRpbGUgaXMgYSBQbGF5ZXIgb3IgU2NyaXB0YWJsZVxuICAgICAgICBpZiAoZnJvbVBsYXllcikge1xuICAgICAgICAgICAgYm9hcmQuZ2FtZS5yZXNvdXJjZXMuYXVkaW8ucGxheSgndCtjLWMtYycpO1xuICAgICAgICB9XG4gICAgICAgIHRpbGUuc2VuZE1lc3NhZ2UoJ1NIT1QnKTtcblxuICAgIH1cblxufTtcblxuZXhwb3J0cy5UaGluZyA9IFRoaW5nO1xuZXhwb3J0cy5VcGRhdGVhYmxlVGhpbmcgPSBVcGRhdGVhYmxlVGhpbmc7XG5cbmRlZmluZVRoaW5nKCdTY3JpcHRhYmxlJywgU2NyaXB0YWJsZSk7XG5kZWZpbmVUaGluZygnQWN0aXZlQm9tYicsIEFjdGl2ZUJvbWIpO1xuZGVmaW5lVGhpbmcoJ0FtbW8nLCBBbW1vKTtcbmRlZmluZVRoaW5nKCdCZWFyJywgQmVhcik7XG5kZWZpbmVUaGluZygnQmxpbmtlcicsIEJsaW5rZXIpO1xuZGVmaW5lVGhpbmcoJ0JsaW5rV2FsbCcsIEJsaW5rV2FsbCk7XG5kZWZpbmVUaGluZygnQm9tYicsIEJvbWIpO1xuZGVmaW5lVGhpbmcoJ0JvdWxkZXInLCBCb3VsZGVyKTtcbmRlZmluZVRoaW5nKCdCcmVha2FibGVXYWxsJywgQnJlYWthYmxlV2FsbCk7XG5kZWZpbmVUaGluZygnQnVsbGV0JywgQnVsbGV0KTtcbmRlZmluZVRoaW5nKCdDZW50aXBlZGUnLCBDZW50aXBlZGUpO1xuZGVmaW5lVGhpbmcoJ0NvbnZleW9yJywgQ29udmV5b3IpO1xuZGVmaW5lVGhpbmcoJ0Rvb3InLCBEb29yKTtcbmRlZmluZVRoaW5nKCdEdXBsaWNhdG9yJywgRHVwbGljYXRvcik7XG5kZWZpbmVUaGluZygnRXhwbG9zaW9uJywgRXhwbG9zaW9uKTtcbmRlZmluZVRoaW5nKCdGYWtlV2FsbCcsIEZha2VXYWxsKTtcbmRlZmluZVRoaW5nKCdGb3Jlc3QnLCBGb3Jlc3QpO1xuZGVmaW5lVGhpbmcoJ0dlbScsIEdlbSk7XG5kZWZpbmVUaGluZygnSGVhcnQnLCBIZWFydCk7XG5kZWZpbmVUaGluZygnSW52aXNpYmxlV2FsbCcsIEludmlzaWJsZVdhbGwpO1xuZGVmaW5lVGhpbmcoJ0tleScsIEtleSk7XG5kZWZpbmVUaGluZygnTGF2YScsIExhdmEpO1xuZGVmaW5lVGhpbmcoJ0xpbmVXYWxsJywgTGluZVdhbGwpO1xuZGVmaW5lVGhpbmcoJ0xpb24nLCBMaW9uKTtcbmRlZmluZVRoaW5nKCdQYXNzYWdlJywgUGFzc2FnZSk7XG5kZWZpbmVUaGluZygnUGxheWVyJywgUGxheWVyKTtcbmRlZmluZVRoaW5nKCdQdXNoZXInLCBQdXNoZXIpO1xuZGVmaW5lVGhpbmcoJ1JpY29jaGV0JywgUmljb2NoZXQpO1xuZGVmaW5lVGhpbmcoJ1JpdmVyJywgUml2ZXIpO1xuZGVmaW5lVGhpbmcoJ1J1ZmZpYW4nLCBSdWZmaWFuKTtcbmRlZmluZVRoaW5nKCdTaWducG9zdCcsIFNpZ25wb3N0KTtcbmRlZmluZVRoaW5nKCdTbGlkZXJFdycsIFNsaWRlckV3KTtcbmRlZmluZVRoaW5nKCdTbGlkZXJOcycsIFNsaWRlck5zKTtcbmRlZmluZVRoaW5nKCdTbmFrZScsIFNuYWtlKTtcbmRlZmluZVRoaW5nKCdTb2xpZFdhbGwnLCBTb2xpZFdhbGwpO1xuZGVmaW5lVGhpbmcoJ1NwaWRlcicsIFNwaWRlcik7XG5kZWZpbmVUaGluZygnU3BpZGVyV2ViJywgU3BpZGVyV2ViKTtcbmRlZmluZVRoaW5nKCdTcGlubmluZ0d1bicsIFNwaW5uaW5nR3VuKTtcbmRlZmluZVRoaW5nKCdUZWxlcG9ydGVyJywgVGVsZXBvcnRlcik7XG5kZWZpbmVUaGluZygnVGV4dCcsIFRleHQpO1xuZGVmaW5lVGhpbmcoJ1Rocm93aW5nU3RhcicsIFRocm93aW5nU3Rhcik7XG5kZWZpbmVUaGluZygnVGlnZXInLCBUaWdlcik7XG5kZWZpbmVUaGluZygnVG9yY2gnLCBUb3JjaCk7XG5kZWZpbmVUaGluZygnV2FsbCcsIFdhbGwpO1xuZGVmaW5lVGhpbmcoJ1dhdGVyJywgV2F0ZXIpO1xuXG5leHBvcnRzLlRoaW5nRmFjdG9yeSA9IFRoaW5nRmFjdG9yeTtcbiIsIi8qanNsaW50IG5vZGU6IHRydWUsIGJyb3dzZXI6dHJ1ZSAqL1xuLypnbG9iYWwgTFpTdHJpbmcsIEJhc2U2NCwgRmlsZVJlYWRlciwgYWxlcnQsIENvZGVNaXJyb3IsIGpRdWVyeSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBKenRTY3JpcHQgPSByZXF1aXJlKCcuLi9qenQtc2NyaXB0JykuSnp0U2NyaXB0LFxuICAgIEp6dFNjcmlwdFBhcnNlciA9IHJlcXVpcmUoJy4uL2p6dC1zY3JpcHQtcGFyc2VyJykuSnp0U2NyaXB0UGFyc2VyLFxuICAgIFNwaWRlcldlYiA9IHJlcXVpcmUoJy4uL3RoaW5ncycpLlNwaWRlV2ViLFxuICAgIEVkaXRvciA9IHJlcXVpcmUoJy4uL2VkaXRvcicpLkVkaXRvcixcbiAgICBib2FyZFNlbGVjdG9yLFxuICAgIG5vcnRoU2VsZWN0b3IsXG4gICAgZWFzdFNlbGVjdG9yLFxuICAgIHNvdXRoU2VsZWN0b3IsXG4gICAgd2VzdFNlbGVjdG9yLFxuICAgIG5vcnRoT2Zmc2V0U2VsZWN0b3IsXG4gICAgZWFzdE9mZnNldFNlbGVjdG9yLFxuICAgIHNvdXRoT2Zmc2V0U2VsZWN0b3IsXG4gICAgd2VzdE9mZnNldFNlbGVjdG9yLFxuICAgIGRhcmtTZWxlY3RvcixcbiAgICBtYXhQbGF5ZXJCdWxsZXRTZWxlY3RvcixcbiAgICByZWVudGVyU2VsZWN0b3IsXG4gICAgdGVtcGxhdGVFZGl0b3IsXG4gICAgc2NyaXB0U2VsZWN0b3IsXG4gICAgc2NyaXB0RWRpdG9yLFxuICAgIGVkaXRBcmVhLFxuICAgIGl0ZW1TZWxlY3RvcixcbiAgICBnYW1lTmFtZSxcbiAgICBhdXRob3JOYW1lLFxuICAgIHN0YXJ0aW5nQm9hcmRTZWxlY3RvcixcbiAgICB0aXRsZUJvYXJkU2VsZWN0b3IsXG4gICAgdmljdG9yeUJvYXJkU2VsZWN0b3IsXG4gICAgc2NyaXB0V2FybmluZyxcbiAgICBtb2RlU2VsZWN0b3IsXG4gICAgcGxheUJ1dHRvbixcbiAgICBlZGl0b3IsXG4gICAgb2xkTGluZSA9IDEsXG4gICAgdGVtcGxhdGVzLFxuICAgIHNjcmlwdFRhYixcbiAgICBuZXdCb2FyZERpYWxvZyxcbiAgICBtYWluTmF2aWdhdGlvbixcbiAgICBwYXJzZXI7XG5cbi8qKlxuICogVmFsaWRhdGVzIGEgY3VycmVudCBzY3JpcHQgYW5kIGRpc3BsYXlzIG9yIGhpZGVzIGEgd2FybmluZyBhcyBhcHByb3ByaWF0ZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTY3JpcHQoKSB7XG5cbiAgICB0cnkge1xuICAgICAgICBwYXJzZXIucGFyc2Uoc2NyaXB0RWRpdG9yLmdldFZhbHVlKCkpO1xuICAgICAgICBzY3JpcHRXYXJuaW5nLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBzY3JpcHRXYXJuaW5nLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgIHNjcmlwdFdhcm5pbmcuaW5uZXJIVE1MID0gJzxzcGFuIGNsYXNzPVwid2FybmluZy1pY29uXCI+4pqgPC9zcGFuPiAnICsgZXhjZXB0aW9uO1xuICAgICAgICBzY3JpcHRXYXJuaW5nLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cblxuICAgIHJldHVybiBDb2RlTWlycm9yLlBhc3M7XG5cbn1cblxuLyoqXG4gKiBTZWxlY3RzIGEgc2NyaXB0IHdpdGggYSBwcm92aWRlZCBuYW1lXG4gKlxuICogQHBhcmFtIHNjcmlwdE5hbWUge3N0cmluZ30gLSBBIHNjcmlwdCBuYW1lIHRvIGJlIHNlbGVjdGVkXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdFNjcmlwdChzY3JpcHROYW1lKSB7XG5cbiAgICB2YXIgc2NyaXB0ID0gZWRpdG9yLmN1cnJlbnRCb2FyZC5nZXRTY3JpcHQoc2NyaXB0TmFtZSk7XG5cbiAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgIHNjcmlwdFRhYi5jbGFzc0xpc3QucmVtb3ZlKCdub3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHRFZGl0b3Iuc2V0VmFsdWUoc2NyaXB0LnJhd1NjcmlwdCB8fCBzY3JpcHQuc2NyaXB0IHx8ICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzY3JpcHRFZGl0b3Iuc2V0VmFsdWUoJycpO1xuICAgICAgICBzY3JpcHRUYWIuY2xhc3NMaXN0LmFkZCgnbm9zY3JpcHQnKTtcbiAgICB9XG5cbiAgICB2YWxpZGF0ZVNjcmlwdCgpO1xuXG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBib2FyZCBvcHRpb25zIGRpYWxvZ1xuICpcbiAqIEBwYXJhbSBkaWFsb2cge29iamVjdH0gLSBBIGRpYWxvZyBET00gZWxlbWVudFxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplQm9hcmRPcHRpb25zRGlhbG9nKGRpYWxvZykge1xuXG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgaGFuZGxlciB0byBiZSBpbnZva2VkIHdoZW4gYm9hcmQgb3B0aW9ucyBoYXZlIGNoYW5nZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgICAgZWRpdG9yLnNldEJvYXJkT3B0aW9ucyh7XG4gICAgICAgICAgICBub3J0aDogbm9ydGhTZWxlY3Rvci52YWx1ZSxcbiAgICAgICAgICAgIGVhc3Q6IGVhc3RTZWxlY3Rvci52YWx1ZSxcbiAgICAgICAgICAgIHNvdXRoOiBzb3V0aFNlbGVjdG9yLnZhbHVlLFxuICAgICAgICAgICAgd2VzdDogd2VzdFNlbGVjdG9yLnZhbHVlLFxuICAgICAgICAgICAgbm9ydGhPZmZzZXQ6IG5vcnRoT2Zmc2V0U2VsZWN0b3IudmFsdWUsXG4gICAgICAgICAgICBlYXN0T2Zmc2V0OiBlYXN0T2Zmc2V0U2VsZWN0b3IudmFsdWUsXG4gICAgICAgICAgICBzb3V0aE9mZnNldDogc291dGhPZmZzZXRTZWxlY3Rvci52YWx1ZSxcbiAgICAgICAgICAgIHdlc3RPZmZzZXQ6IHdlc3RPZmZzZXRTZWxlY3Rvci52YWx1ZSxcbiAgICAgICAgICAgIGRhcms6IGRhcmtTZWxlY3Rvci5jaGVja2VkLFxuICAgICAgICAgICAgbWF4UGxheWVyQnVsbGV0czogcGFyc2VJbnQobWF4UGxheWVyQnVsbGV0U2VsZWN0b3IudmFsdWUsIDEwKSxcbiAgICAgICAgICAgIHJlZW50ZXI6IHJlZW50ZXJTZWxlY3Rvci5jaGVja2VkXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5vcnRoU2VsZWN0b3IgPSBkaWFsb2cucXVlcnlTZWxlY3RvcignW2RhdGEtaWQ9XCJub3J0aFwiXScpO1xuICAgIGVhc3RTZWxlY3RvciA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cImVhc3RcIl0nKTtcbiAgICBzb3V0aFNlbGVjdG9yID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWlkPVwic291dGhcIl0nKTtcbiAgICB3ZXN0U2VsZWN0b3IgPSBkaWFsb2cucXVlcnlTZWxlY3RvcignW2RhdGEtaWQ9XCJ3ZXN0XCJdJyk7XG4gICAgbm9ydGhPZmZzZXRTZWxlY3RvciA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cIm5vcnRoLW9mZnNldFwiXScpO1xuICAgIGVhc3RPZmZzZXRTZWxlY3RvciA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cImVhc3Qtb2Zmc2V0XCJdJyk7XG4gICAgc291dGhPZmZzZXRTZWxlY3RvciA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cInNvdXRoLW9mZnNldFwiXScpO1xuICAgIHdlc3RPZmZzZXRTZWxlY3RvciA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cIndlc3Qtb2Zmc2V0XCJdJyk7XG4gICAgZGFya1NlbGVjdG9yID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWlkPVwiZGFya1wiXScpO1xuICAgIHJlZW50ZXJTZWxlY3RvciA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cInJlZW50ZXJcIl0nKTtcbiAgICBtYXhQbGF5ZXJCdWxsZXRTZWxlY3RvciA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cIm1heC1wbGF5ZXItYnVsbGV0c1wiXScpO1xuXG4gICAgbm9ydGhTZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSwgZmFsc2UpO1xuICAgIGVhc3RTZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSwgZmFsc2UpO1xuICAgIHNvdXRoU2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UsIGZhbHNlKTtcbiAgICB3ZXN0U2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UsIGZhbHNlKTtcbiAgICBub3J0aE9mZnNldFNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgZWFzdE9mZnNldFNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgc291dGhPZmZzZXRTZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSwgZmFsc2UpO1xuICAgIHdlc3RPZmZzZXRTZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSwgZmFsc2UpO1xuICAgIGRhcmtTZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgcmVlbnRlclNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DaGFuZ2UsIGZhbHNlKTtcbiAgICBtYXhQbGF5ZXJCdWxsZXRTZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSwgZmFsc2UpO1xuXG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSB3b3JsZCBvcHRpb25zIGRpYWxvZ1xuICpcbiAqIEBwYXJhbSBkaWFsb2cge29iamVjdH0gLSBBIGRpYWxvZyBET00gZWxlbWVudFxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplV29ybGRPcHRpb25zRGlhbG9nKGRpYWxvZykge1xuXG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgaGFuZGxlciB0byBiZSBpbnZva2VkIHdoZW4gYm9hcmQgb3B0aW9ucyBoYXZlIGNoYW5nZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpIHtcbiAgICAgICAgZWRpdG9yLnNldEdhbWVPcHRpb25zKHtcbiAgICAgICAgICAgIG5hbWU6IGdhbWVOYW1lLnZhbHVlLFxuICAgICAgICAgICAgYXV0aG9yOiBhdXRob3JOYW1lLnZhbHVlLFxuICAgICAgICAgICAgdGl0bGVCb2FyZDogdGl0bGVCb2FyZFNlbGVjdG9yLnZhbHVlLFxuICAgICAgICAgICAgc3RhcnRpbmdCb2FyZDogc3RhcnRpbmdCb2FyZFNlbGVjdG9yLnZhbHVlLFxuICAgICAgICAgICAgdmljdG9yeUJvYXJkOiB2aWN0b3J5Qm9hcmRTZWxlY3Rvci52YWx1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnYW1lTmFtZSA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cInRpdGxlXCJdJyk7XG4gICAgYXV0aG9yTmFtZSA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cImF1dGhvclwiXScpO1xuICAgIHRpdGxlQm9hcmRTZWxlY3RvciA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cInRpdGxlLWJvYXJkXCJdJyk7XG4gICAgc3RhcnRpbmdCb2FyZFNlbGVjdG9yID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWlkPVwic3RhcnRpbmctYm9hcmRcIl0nKTtcbiAgICB2aWN0b3J5Qm9hcmRTZWxlY3RvciA9IGRpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cInZpY3RvcnktYm9hcmRcIl0nKTtcblxuICAgIGdhbWVOYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlLCBmYWxzZSk7XG4gICAgYXV0aG9yTmFtZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSwgZmFsc2UpO1xuICAgIHRpdGxlQm9hcmRTZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSwgZmFsc2UpO1xuICAgIHN0YXJ0aW5nQm9hcmRTZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSwgZmFsc2UpO1xuICAgIHZpY3RvcnlCb2FyZFNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ2hhbmdlLCBmYWxzZSk7XG5cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvcGVuIGRpYWxvZ1xuICpcbiAqIEBwYXJhbSBkaWFsb2cge29iamVjdH0gLSBBIGRpYWxvZyBET00gZWxlbWVudFxuICovXG5mdW5jdGlvbiBpbml0aWFsaXplT3BlbkRpYWxvZyhkaWFsb2cpIHtcblxuICAgIC8vIExvYWQgR2FtZVxuICAgIGRpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cIm9wZW5cIl0nKS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIGZpbGVSZWFkZXIsXG4gICAgICAgICAgICBmaWxlO1xuXG4gICAgICAgIGlmIChldmVudC50YXJnZXQuZmlsZXMgJiYgZXZlbnQudGFyZ2V0LmZpbGVzWzBdKSB7XG5cbiAgICAgICAgICAgIGZpbGUgPSBldmVudC50YXJnZXQuZmlsZXNbMF07XG4gICAgICAgICAgICBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIganNvbjtcblxuICAgICAgICAgICAgICAgIGlmIChmaWxlLnR5cGUgPT09ICdhcHBsaWNhdGlvbi9qc29uJykge1xuICAgICAgICAgICAgICAgICAgICBqc29uID0gZmlsZVJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAganNvbiA9IGZpbGVSZWFkZXIucmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICAgICAgICAgICAgICAgIGpzb24gPSBMWlN0cmluZy5kZWNvbXByZXNzRnJvbUJhc2U2NChqc29uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuZGVzZXJpYWxpemUoSlNPTi5wYXJzZShqc29uKSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KGV4Y2VwdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAoZmlsZS50eXBlID09PSAnYXBwbGljYXRpb24vanNvbicpIHtcbiAgICAgICAgICAgICAgICBmaWxlUmVhZGVyLnJlYWRBc1RleHQoZmlsZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgalF1ZXJ5KGRpYWxvZy5xdWVyeVNlbGVjdG9yKCcuY2xvc2UtcmV2ZWFsLW1vZGFsJykpLnRyaWdnZXIoJ2NsaWNrJyk7XG5cbiAgICB9LCBmYWxzZSk7XG5cblxufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGEgc2NyaXB0IG9wdGlvbnMgZGlhbG9nXG4gKlxuICogQHBhcmFtIGRpYWxvZyB7b2JqZWN0fSAtIEEgZGlhbG9nIERPTSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVTY3JpcHREaWFsb2coZGlhbG9nKSB7XG5cbiAgICBzY3JpcHRUYWIgPSBkaWFsb2c7XG4gICAgc2NyaXB0U2VsZWN0b3IgPSBkaWFsb2cucXVlcnlTZWxlY3RvcignW2RhdGEtaWQ9XCJzZWxlY3RvclwiXScpO1xuXG4gICAgc2NyaXB0RWRpdG9yID0gQ29kZU1pcnJvci5mcm9tVGV4dEFyZWEoZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWlkPVwiZWRpdG9yXCJdJyksIHtcbiAgICAgICAgbW9kZTogJ2p6dHNjcmlwdCcsXG4gICAgICAgIHRoZW1lOiAnanp0JyxcbiAgICAgICAgbGluZU51bWJlcnM6IHRydWUsXG4gICAgICAgIGxpbmVXcmFwcGluZzogZmFsc2VcbiAgICB9KTtcblxuICAgIHNjcmlwdFdhcm5pbmcgPSBkaWFsb2cucXVlcnlTZWxlY3RvcignW2RhdGEtaWQ9XCJ3YXJuaW5nXCJdJyk7XG5cbiAgICAvLyBOZXcgU2NyaXB0IEJ1dHRvblxuICAgIGRpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cIm5ld1wiXScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBzY3JpcHQsXG4gICAgICAgICAgICBuZXdOYW1lID0gd2luZG93LnByb21wdCgnUGxlYXNlIGVudGVyIGEgc2NyaXB0IG5hbWUuJywgJ1VudGl0bGVkJyk7XG5cbiAgICAgICAgaWYgKG5ld05hbWUpIHtcbiAgICAgICAgICAgIG5ld05hbWUgPSBlZGl0b3IuZ2V0VW5pcXVlU2NyaXB0TmFtZShuZXdOYW1lKTtcbiAgICAgICAgICAgIHNjcmlwdCA9IG5ldyBKenRTY3JpcHQobmV3TmFtZSk7XG4gICAgICAgICAgICBlZGl0b3IuY3VycmVudEJvYXJkLnNjcmlwdHMucHVzaChzY3JpcHQpO1xuICAgICAgICAgICAgc2NyaXB0U2VsZWN0b3Iub3B0aW9uc1tzY3JpcHRTZWxlY3Rvci5vcHRpb25zLmxlbmd0aF0gPSBuZXcgT3B0aW9uKG5ld05hbWUpO1xuICAgICAgICAgICAgc2NyaXB0U2VsZWN0b3IudmFsdWUgPSBuZXdOYW1lO1xuICAgICAgICAgICAgc2VsZWN0U2NyaXB0KG5ld05hbWUpO1xuICAgICAgICB9XG5cbiAgICB9LCBmYWxzZSk7XG5cbiAgICAvLyBEZWxldGUgU2NyaXB0IEJ1dHRvblxuICAgIGRpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cImRlbGV0ZVwiXScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBpbmRleCxcbiAgICAgICAgICAgIHNjcmlwdE5hbWUgPSBzY3JpcHRTZWxlY3Rvci52YWx1ZTtcblxuICAgICAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBlZGl0b3IuY3VycmVudEJvYXJkLnNjcmlwdHMubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgICBpZiAoZWRpdG9yLmN1cnJlbnRCb2FyZC5zY3JpcHRzW2luZGV4XS5uYW1lID09PSBzY3JpcHROYW1lKSB7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmN1cnJlbnRCb2FyZC5zY3JpcHRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzY3JpcHRTZWxlY3Rvci5yZW1vdmUoc2NyaXB0U2VsZWN0b3Iuc2VsZWN0ZWRJbmRleCk7XG5cbiAgICAgICAgc2VsZWN0U2NyaXB0KHNjcmlwdFNlbGVjdG9yLnZhbHVlKTtcblxuICAgIH0sIGZhbHNlKTtcblxuICAgIC8vIFNjcmlwdCBFZGl0b3JcbiAgICBzY3JpcHRFZGl0b3Iub24oJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIHNjcmlwdCA9IGVkaXRvci5jdXJyZW50Qm9hcmQuZ2V0U2NyaXB0KHNjcmlwdFNlbGVjdG9yLnZhbHVlKSxcbiAgICAgICAgICAgIHJhd1NjcmlwdCA9IHNjcmlwdEVkaXRvci5nZXRWYWx1ZSgpLnRyaW0oKTtcblxuICAgICAgICB2YWxpZGF0ZVNjcmlwdCgpO1xuICAgICAgICBzY3JpcHQucmF3U2NyaXB0ID0gcmF3U2NyaXB0ID09PSAnJyA/IHVuZGVmaW5lZCA6IHJhd1NjcmlwdDtcblxuICAgIH0pO1xuXG4gICAgc2NyaXB0RWRpdG9yLm9uKCdjdXJzb3JBY3Rpdml0eScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHNjcmlwdEVkaXRvci5nZXRDdXJzb3IoKS5saW5lICE9PSBvbGRMaW5lKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZVNjcmlwdCgpO1xuICAgICAgICB9XG4gICAgICAgIG9sZExpbmUgPSBzY3JpcHRFZGl0b3IuZ2V0Q3Vyc29yKCkubGluZTtcbiAgICB9KTtcblxuICAgIHNjcmlwdFNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzZWxlY3RTY3JpcHQoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICAgICAgdmFsaWRhdGVTY3JpcHQoKTtcbiAgICB9LCBmYWxzZSk7XG5cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgbmV3IGJvYXJkIGRpYWxvZ1xuICpcbiAqIEBwYXJhbSBkaWFsb2cge29iamVjdH0gLSBBIGRpYWxvZyB0aGF0IGFsbG93cyB0aGUgY3JlYXRpb24gb2YgYSBuZXcgYm9hcmRcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZU5ld0JvYXJkRGlhbG9nKGRpYWxvZykge1xuXG4gICAgbmV3Qm9hcmREaWFsb2cgPSBkaWFsb2c7XG5cbiAgICBkaWFsb2cucXVlcnlTZWxlY3RvcignW2RhdGEtaWQ9XCJva1wiXScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuXG4gICAgICAgIHZhciBuYW1lID0gZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLWlkPVwibmFtZVwiXScpLnZhbHVlLFxuICAgICAgICAgICAgd2lkdGggPSBwYXJzZUludChkaWFsb2cucXVlcnlTZWxlY3RvcignW2RhdGEtaWQ9XCJ3aWR0aFwiXScpLnZhbHVlLCAxMCksXG4gICAgICAgICAgICBoZWlnaHQgPSBwYXJzZUludChkaWFsb2cucXVlcnlTZWxlY3RvcignW2RhdGEtaWQ9XCJoZWlnaHRcIl0nKS52YWx1ZSwgMTApO1xuXG4gICAgICAgIGlmIChuYW1lICYmIHdpZHRoICYmIGhlaWdodCkge1xuICAgICAgICAgICAgbmFtZSA9IGVkaXRvci5nZXRVbmlxdWVCb2FyZE5hbWUobmFtZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGVkaXRvci5hZGRCb2FyZChuYW1lLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgalF1ZXJ5KGRpYWxvZy5xdWVyeVNlbGVjdG9yKCcuY2xvc2UtcmV2ZWFsLW1vZGFsJykpLnRyaWdnZXIoJ2NsaWNrJyk7XG5cbiAgICB9KTtcblxufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBwcmltYXJ5IFVJIG9wdGlvbnNcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7b2JqZWN0fSAtIERPTSBlbGVtZW50cyB1c2VkIGZvciB1c2VyIGludGVyYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVQcmltYXJ5VWkob3B0aW9ucykge1xuXG4gICAgdmFyIGluZGV4LFxuICAgICAgICBtYWluTWVudSxcbiAgICAgICAgY2hpbGRyZW47XG5cbiAgICBmdW5jdGlvbiBvblRvb2xDaGFuZ2UoZXZlbnQpIHtcblxuICAgICAgICB2YXIgdG9vbFR5cGUgPSBldmVudC50YXJnZXQudmFsdWUsXG4gICAgICAgICAgICBhY3RpdmVUZW1wbGF0ZTtcblxuICAgICAgICBpZiAodG9vbFR5cGUpIHtcblxuICAgICAgICAgICAgaWYgKHRlbXBsYXRlcy5oYXNPd25Qcm9wZXJ0eSh0b29sVHlwZSkpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVUZW1wbGF0ZSA9IHRlbXBsYXRlc1t0b29sVHlwZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFjdGl2ZVRlbXBsYXRlID0ge3R5cGU6IHRvb2xUeXBlfTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRvb2xUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnUGFzc2FnZSc6XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRlbXBsYXRlLnBhc3NhZ2VJZCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZVRlbXBsYXRlLnRhcmdldEJvYXJkID0gJ1VudGl0bGVkJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnU3BpZGVyJzpcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlVGVtcGxhdGUudW5kZXIgPSBuZXcgU3BpZGVyV2ViKCkuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NjcmlwdGFibGUnOlxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUZW1wbGF0ZS5zY3JpcHQgPSAnVW50aXRsZWQgU2NyaXB0JztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnUml2ZXInOlxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUZW1wbGF0ZS5kaXJlY3Rpb24gPSAnTic7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZXNbdG9vbFR5cGVdID0gYWN0aXZlVGVtcGxhdGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVkaXRvci5zZXRBY3RpdmVUZW1wbGF0ZShhY3RpdmVUZW1wbGF0ZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVkaXRvci5zZXRBY3RpdmVUZW1wbGF0ZSh1bmRlZmluZWQpO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk1vZGVDaGFuZ2UoZXZlbnQpIHtcblxuICAgICAgICB2YXIgbW9kZSA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kZScpO1xuXG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlICdkcmF3JzpcbiAgICAgICAgICAgIGVkaXRvci5zZXRNb2RlKEVkaXRvci5Nb2RlLkRSQVcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgICAgICBlZGl0b3Iuc2V0TW9kZShFZGl0b3IuTW9kZS5TRUxFQ1QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZpbGwnOlxuICAgICAgICAgICAgZWRpdG9yLnNldE1vZGUoRWRpdG9yLk1vZGUuRklMTCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbk5vQWN0aW9uQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBtYWluTmF2aWdhdGlvbiA9IG9wdGlvbnMubWFpbk5hdmlnYXRpb247XG4gICAgbWFpbk1lbnUgPSBtYWluTmF2aWdhdGlvbi5xdWVyeVNlbGVjdG9yKCdzZWN0aW9uLnRvcC1iYXItc2VjdGlvbicpO1xuICAgIG1vZGVTZWxlY3RvciA9IG9wdGlvbnMubW9kZVNlbGVjdG9yO1xuICAgIHBsYXlCdXR0b24gPSBvcHRpb25zLnBsYXlCdXR0b247XG4gICAgYm9hcmRTZWxlY3RvciA9IG9wdGlvbnMuYm9hcmRTZWxlY3RvcjtcbiAgICB0ZW1wbGF0ZUVkaXRvciA9IG9wdGlvbnMudGVtcGxhdGVFZGl0b3I7XG4gICAgaXRlbVNlbGVjdG9yID0gb3B0aW9ucy5pdGVtU2VsZWN0b3I7XG5cbiAgICAvLyBCb2FyZCBTZWxlY3RvclxuICAgIGJvYXJkU2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBlZGl0b3Iuc3dpdGNoQm9hcmQoZXZlbnQudGFyZ2V0LnZhbHVlKTtcbiAgICB9LCBmYWxzZSk7XG5cbiAgICBjaGlsZHJlbiA9IG1vZGVTZWxlY3Rvci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1tb2RlXScpO1xuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGNoaWxkcmVuLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICBjaGlsZHJlbltpbmRleF0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbk1vZGVDaGFuZ2UsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvLyBUZW1wbGF0ZSBFZGl0b3JcbiAgICB0ZW1wbGF0ZUVkaXRvci5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGVtcGxhdGVFZGl0b3IudmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0QWN0aXZlVGVtcGxhdGUoSlNPTi5wYXJzZSh0ZW1wbGF0ZUVkaXRvci52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgLy8gTmV3XG4gICAgbWFpbk1lbnUucXVlcnlTZWxlY3RvcignW2RhdGEtbWVudS1pdGVtPVwibmV3XCJdJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh3aW5kb3cuY29uZmlybSgnQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIHN0YXJ0IGEgbmV3IGdhbWUgd29ybGQ/JykpIHtcbiAgICAgICAgICAgIGVkaXRvci5uZXdHYW1lKCk7XG4gICAgICAgIH1cbiAgICB9LCBmYWxzZSk7XG5cbiAgICAvLyBEb3dubG9hZFxuICAgIG1haW5NZW51LnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW1lbnUtaXRlbT1cImRvd25sb2FkXCJdJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgLypqc2xpbnQgcmVnZXhwOiB0cnVlICovXG5cbiAgICAgICAgdmFyIGdhbWUgPSBlZGl0b3Iuc2VyaWFsaXplKCksXG4gICAgICAgICAgICBsaW5rO1xuXG4gICAgICAgIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIGxpbmsuZG93bmxvYWQgPSBnYW1lLm5hbWUucmVwbGFjZSgvW15hLXowLTlfXFwtXS9naSwgJy0nKS50b0xvd2VyQ2FzZSgpICsgJy5qenQnO1xuICAgICAgICBsaW5rLmhyZWYgPSAnZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07Y2hhcnNldD11dGYtODtiYXNlNjQsJyArICAgICBMWlN0cmluZy5jb21wcmVzc1RvQmFzZTY0KEpTT04uc3RyaW5naWZ5KGdhbWUpKTtcbiAgICAgICAgbGluay5jbGljaygpO1xuXG4gICAgfSwgZmFsc2UpO1xuXG4gICAgLy8gTmV3IEJvYXJkXG4gICAgbWFpbk1lbnUucXVlcnlTZWxlY3RvcignW2RhdGEtbWVudS1pdGVtPVwibmV3LWJvYXJkXCJdJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgbmV3Qm9hcmREaWFsb2cucXVlcnlTZWxlY3RvcignW2RhdGEtaWQ9XCJuYW1lXCJdJykudmFsdWUgPSAnVW50aXRsZWQgQm9hcmQnO1xuICAgICAgICBuZXdCb2FyZERpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cIndpZHRoXCJdJykudmFsdWUgPSAnNTAnO1xuICAgICAgICBuZXdCb2FyZERpYWxvZy5xdWVyeVNlbGVjdG9yKCdbZGF0YS1pZD1cImhlaWdodFwiXScpLnZhbHVlID0gJzIwJztcblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgfSwgZmFsc2UpO1xuXG4gICAgLy8gRGVsZXRlIEJvYXJkXG4gICAgbWFpbk1lbnUucXVlcnlTZWxlY3RvcignW2RhdGEtbWVudS1pdGVtPVwiZGVsZXRlLWJvYXJkXCJdJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgZWRpdG9yLnJlbW92ZUJvYXJkKGVkaXRvci5jdXJyZW50Qm9hcmQubmFtZSk7XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIH0sIGZhbHNlKTtcblxuXG4gICAgaXRlbVNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uVG9vbENoYW5nZSwgZmFsc2UpO1xuXG4gICAgY2hpbGRyZW4gPSBtYWluTmF2aWdhdGlvbi5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1ub2FjdGlvbl0nKTtcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBjaGlsZHJlbi5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgY2hpbGRyZW5baW5kZXhdLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25Ob0FjdGlvbkNsaWNrLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgb3B0aW9ucy5zaWRlYmFyVGFicy5vbigndG9nZ2xlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NyaXB0RWRpdG9yLnJlZnJlc2goKTtcbiAgICB9KTtcblxuICAgIHBsYXlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcblxuICAgICAgICB3aW5kb3cub3BlbihldmVudC50YXJnZXQuaHJlZiwgJ2p6dC1wbGF5LXRlc3QnKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIH0sIGZhbHNlKTtcblxufVxuXG4vKipcbiAqIEFuIGV2ZW50IGhhbmRsZXIgd2hlbiBnYW1lIG9wdGlvbnMgaGF2ZSBjaGFuZ2VkXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge29iamVjdH0gLSBHYW1lIG9wdGlvbnMgdGhhdCBoYXZlIGNoYW5nZWRcbiAqL1xuZnVuY3Rpb24gb25HYW1lT3B0aW9uc0NoYW5nZWQob3B0aW9ucykge1xuXG4gICAgZ2FtZU5hbWUudmFsdWUgPSBvcHRpb25zLm5hbWU7XG4gICAgYXV0aG9yTmFtZS52YWx1ZSA9IG9wdGlvbnMuYXV0aG9yO1xuICAgIHRpdGxlQm9hcmRTZWxlY3Rvci52YWx1ZSA9IG9wdGlvbnMudGl0bGVCb2FyZCB8fCAnJztcbiAgICBzdGFydGluZ0JvYXJkU2VsZWN0b3IudmFsdWUgPSBvcHRpb25zLnN0YXJ0aW5nQm9hcmQ7XG4gICAgdmljdG9yeUJvYXJkU2VsZWN0b3IudmFsdWUgPSBvcHRpb25zLnZpY3RvcnlCb2FyZCB8fCAnJztcblxufVxuXG4vKipcbiAqIEFuIGV2ZW50IGhhbmRsZXIgdG8gYmUgaW52b2tlZCB3aGVuIGEgYm9hcmQgaGFzIGJlZW4gYWRkZWQuXG4gKlxuICogQHBhcmFtIGJvYXJkTmFtZSB7c3RyaW5nfSAtIEEgbmFtZSBvZiBhIGJvYXJkIHRoYXQncyBiZWVuIGFkZGVkLlxuICovXG5mdW5jdGlvbiBvbkJvYXJkQWRkZWQoYm9hcmROYW1lKSB7XG4gICAgYm9hcmRTZWxlY3Rvci5vcHRpb25zW2JvYXJkU2VsZWN0b3Iub3B0aW9ucy5sZW5ndGhdID0gbmV3IE9wdGlvbihib2FyZE5hbWUsIGJvYXJkTmFtZSk7XG4gICAgbm9ydGhTZWxlY3Rvci5vcHRpb25zW25vcnRoU2VsZWN0b3Iub3B0aW9ucy5sZW5ndGhdID0gbmV3IE9wdGlvbihib2FyZE5hbWUsIGJvYXJkTmFtZSk7XG4gICAgc291dGhTZWxlY3Rvci5vcHRpb25zW3NvdXRoU2VsZWN0b3Iub3B0aW9ucy5sZW5ndGhdID0gbmV3IE9wdGlvbihib2FyZE5hbWUsIGJvYXJkTmFtZSk7XG4gICAgZWFzdFNlbGVjdG9yLm9wdGlvbnNbZWFzdFNlbGVjdG9yLm9wdGlvbnMubGVuZ3RoXSA9IG5ldyBPcHRpb24oYm9hcmROYW1lLCBib2FyZE5hbWUpO1xuICAgIHdlc3RTZWxlY3Rvci5vcHRpb25zW3dlc3RTZWxlY3Rvci5vcHRpb25zLmxlbmd0aF0gPSBuZXcgT3B0aW9uKGJvYXJkTmFtZSwgYm9hcmROYW1lKTtcbiAgICB0aXRsZUJvYXJkU2VsZWN0b3Iub3B0aW9uc1t0aXRsZUJvYXJkU2VsZWN0b3Iub3B0aW9ucy5sZW5ndGhdID0gbmV3IE9wdGlvbihib2FyZE5hbWUsIGJvYXJkTmFtZSk7XG4gICAgc3RhcnRpbmdCb2FyZFNlbGVjdG9yLm9wdGlvbnNbc3RhcnRpbmdCb2FyZFNlbGVjdG9yLm9wdGlvbnMubGVuZ3RoXSA9IG5ldyBPcHRpb24oYm9hcmROYW1lLCBib2FyZE5hbWUpO1xuICAgIHZpY3RvcnlCb2FyZFNlbGVjdG9yLm9wdGlvbnNbdmljdG9yeUJvYXJkU2VsZWN0b3Iub3B0aW9ucy5sZW5ndGhdID0gbmV3IE9wdGlvbihib2FyZE5hbWUsIGJvYXJkTmFtZSk7XG59XG5cbi8qKlxuICogQW4gZXZlbnQgaGFuZGxlciB0byBiZSBpbnZva2VkIHdoZW4gYSBib2FyZCBoYXMgYmVlbiByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSBib2FyZE5hbWUge3N0cmluZ30gPSBBIG5hbWUgb2YgYSBib2FyZCB0aGF0J3MgYmVlbiByZW1vdmVkLlxuICovXG5mdW5jdGlvbiBvbkJvYXJkUmVtb3ZlZChib2FyZE5hbWUpIHtcblxuICAgIGZ1bmN0aW9uIGZpbmRJbmRleChlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgZWxlbWVudC5sZW5ndGg7IGluZGV4ICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm9wdGlvbnNbaW5kZXhdLnZhbHVlID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYm9hcmRTZWxlY3Rvci5yZW1vdmUoZmluZEluZGV4KGJvYXJkU2VsZWN0b3IsIGJvYXJkTmFtZSkpO1xuICAgIG5vcnRoU2VsZWN0b3IucmVtb3ZlKGZpbmRJbmRleChub3J0aFNlbGVjdG9yLCBib2FyZE5hbWUpKTtcbiAgICBlYXN0U2VsZWN0b3IucmVtb3ZlKGZpbmRJbmRleChlYXN0U2VsZWN0b3IsIGJvYXJkTmFtZSkpO1xuICAgIHNvdXRoU2VsZWN0b3IucmVtb3ZlKGZpbmRJbmRleChzb3V0aFNlbGVjdG9yLCBib2FyZE5hbWUpKTtcbiAgICB3ZXN0U2VsZWN0b3IucmVtb3ZlKGZpbmRJbmRleCh3ZXN0U2VsZWN0b3IsIGJvYXJkTmFtZSkpO1xuICAgIHRpdGxlQm9hcmRTZWxlY3Rvci5yZW1vdmUoZmluZEluZGV4KHRpdGxlQm9hcmRTZWxlY3RvciwgYm9hcmROYW1lKSk7XG4gICAgc3RhcnRpbmdCb2FyZFNlbGVjdG9yLnJlbW92ZShmaW5kSW5kZXgoc3RhcnRpbmdCb2FyZFNlbGVjdG9yLCBib2FyZE5hbWUpKTtcbiAgICB2aWN0b3J5Qm9hcmRTZWxlY3Rvci5yZW1vdmUoZmluZEluZGV4KHZpY3RvcnlCb2FyZFNlbGVjdG9yLCBib2FyZE5hbWUpKTtcblxufVxuXG4vKipcbiAqIEFuIGV2ZW50IGhhbmRsZXIgdG8gYmUgaW52b2tlZCB3aGVuIGEgYm9hcmQgaGFzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIGJvYXJkTmFtZSB7c3RyaW5nfSAtIEEgbmFtZSBvZiBhIGJvYXJkIHRoYXQncyBiZWVuIGNoYW5nZWQuXG4gKi9cbmZ1bmN0aW9uIG9uQm9hcmRDaGFuZ2VkKGJvYXJkTmFtZSkge1xuXG4gICAgdmFyIGluZGV4O1xuXG4gICAgYm9hcmRTZWxlY3Rvci52YWx1ZSA9IGJvYXJkTmFtZTtcbiAgICBzY3JpcHRTZWxlY3Rvci5vcHRpb25zLmxlbmd0aCA9IDA7XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBlZGl0b3IuY3VycmVudEJvYXJkLnNjcmlwdHMubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgIHNjcmlwdFNlbGVjdG9yLm9wdGlvbnNbaW5kZXhdID0gbmV3IE9wdGlvbihlZGl0b3IuY3VycmVudEJvYXJkLnNjcmlwdHNbaW5kZXhdLm5hbWUpO1xuICAgIH1cblxuICAgIHNlbGVjdFNjcmlwdChzY3JpcHRTZWxlY3Rvci52YWx1ZSk7XG5cbn1cblxuLyoqXG4gKiBBbiBldmVudCBoYW5kbGVyIHRvIGJlIGludm9rZWQgd2hlbiBib2FyZCBvcHRpb25zIGhhdmUgYmVlbiBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9IC0gQm9hcmQgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBvbkJvYXJkT3B0aW9uc0NoYW5nZWQob3B0aW9ucykge1xuXG4gICAgbm9ydGhTZWxlY3Rvci52YWx1ZSA9IG9wdGlvbnMubm9ydGggfHwgJyc7XG4gICAgZWFzdFNlbGVjdG9yLnZhbHVlID0gb3B0aW9ucy5lYXN0IHx8ICcnO1xuICAgIHNvdXRoU2VsZWN0b3IudmFsdWUgPSBvcHRpb25zLnNvdXRoIHx8ICcnO1xuICAgIHdlc3RTZWxlY3Rvci52YWx1ZSA9IG9wdGlvbnMud2VzdCB8fCAnJztcbiAgICBub3J0aE9mZnNldFNlbGVjdG9yLnZhbHVlID0gb3B0aW9ucy5ub3J0aE9mZnNldCB8fCAnJztcbiAgICBlYXN0T2Zmc2V0U2VsZWN0b3IudmFsdWUgPSBvcHRpb25zLmVhc3RPZmZzZXQgfHwgJyc7XG4gICAgc291dGhPZmZzZXRTZWxlY3Rvci52YWx1ZSA9IG9wdGlvbnMuc291dGhPZmZzZXQgfHwgJyc7XG4gICAgd2VzdE9mZnNldFNlbGVjdG9yLnZhbHVlID0gb3B0aW9ucy53ZXN0T2Zmc2V0IHx8ICcnO1xuICAgIGRhcmtTZWxlY3Rvci5jaGVja2VkID0gb3B0aW9ucy5kYXJrO1xuICAgIHJlZW50ZXJTZWxlY3Rvci5jaGVja2VkID0gb3B0aW9ucy5yZWVudGVyO1xuICAgIG1heFBsYXllckJ1bGxldFNlbGVjdG9yLnZhbHVlID0gb3B0aW9ucy5tYXhQbGF5ZXJCdWxsZXRzID09PSB1bmRlZmluZWQgPyAtMSA6IG9wdGlvbnMubWF4UGxheWVyQnVsbGV0cztcblxufVxuXG4vKipcbiAqIEFuIGV2ZW50IGhhbmRsZXIgdG8gYmUgaW52b2tlZCB3aGVuIGFuIGFjdGl2ZSB0ZW1wbGF0ZSBoYXMgY2hhbmdlZFxuICpcbiAqIEBwYXJhbSBuZXdUZW1wbGF0ZSB7b2JqZWN0fSAtIEEgdGVtcGxhdGVcbiAqL1xuZnVuY3Rpb24gb25UZW1wbGF0ZUNoYW5nZWQobmV3VGVtcGxhdGUpIHtcblxuICAgIGlmIChuZXdUZW1wbGF0ZSkge1xuICAgICAgICB0ZW1wbGF0ZUVkaXRvci52YWx1ZSA9IEpTT04uc3RyaW5naWZ5KG5ld1RlbXBsYXRlLCB1bmRlZmluZWQsIDQpO1xuXG4gICAgICAgIGlmIChuZXdUZW1wbGF0ZS50eXBlKSB7XG4gICAgICAgICAgICBpdGVtU2VsZWN0b3IudmFsdWUgPSBuZXdUZW1wbGF0ZS50eXBlO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtU2VsZWN0b3IudmFsdWUgPSAnJztcbiAgICAgICAgdGVtcGxhdGVFZGl0b3IudmFsdWUgPSAnKE5vbmUpJztcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBBbiBldmVudCBoYW5kbGVyIHRvIGJlIGludm9rZWQgd2hlbiBhbiBlZGl0IG1vZGUgaGFzIGNoYW5nZWRcbiAqXG4gKiBAcGFyYW0gbmV3TW9kZSB7aW50fSAtIEEgbmV3IG1vZGVcbiAqL1xuZnVuY3Rpb24gb25Nb2RlQ2hhbmdlZChuZXdNb2RlKSB7XG5cbiAgICBmdW5jdGlvbiBzZWxlY3RNb2RlKG1vZGUpIHtcblxuICAgICAgICB2YXIgZWxlbWVudHMgPSBtb2RlU2VsZWN0b3IucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbW9kZV0nKSxcbiAgICAgICAgICAgIGluZGV4O1xuXG4gICAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGVsZW1lbnRzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnRzW2luZGV4XS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbW9kZScpID09PSBtb2RlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHNbaW5kZXhdLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50c1tpbmRleF0uY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgfVxuXG4gICAgc3dpdGNoIChuZXdNb2RlKSB7XG4gICAgY2FzZSBFZGl0b3IuTW9kZS5EUkFXOlxuICAgICAgICBzZWxlY3RNb2RlKCdkcmF3Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgRWRpdG9yLk1vZGUuRklMTDpcbiAgICAgICAgc2VsZWN0TW9kZSgnZmlsbCcpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlIEVkaXRvci5Nb2RlLlNFTEVDVDpcbiAgICAgICAgc2VsZWN0TW9kZSgnc2VsZWN0Jyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhIHVzZXIgaW50ZXJmYWNlIGZvciBhIEpaVCBnYW1lIGVkaXRvci5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7b2JqZWN0fSAtIEluaXRpYWwgb2JqZWN0IGVsZW1lbnRzXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVFZGl0b3JVeChvcHRpb25zKSB7XG5cbiAgICAvKmpzbGludCByZWdleHA6IHRydWUgKi9cblxuICAgIENvZGVNaXJyb3IuZGVmaW5lU2ltcGxlTW9kZShcImp6dHNjcmlwdFwiLCB7XG4gICAgICAgIC8vIFRoZSBzdGFydCBzdGF0ZSBjb250YWlucyB0aGUgcnVsZXMgdGhhdCBhcmUgaW50aWFsbHkgdXNlZFxuICAgICAgICBzdGFydDogW1xuICAgICAgICAgICAgLy8gVGhlIHJlZ2V4IG1hdGNoZXMgdGhlIHRva2VuLCB0aGUgdG9rZW4gcHJvcGVydHkgY29udGFpbnMgdGhlIHR5cGVcbiAgICAgICAgICAgIHtyZWdleDogL1wiKD86W15cXFxcXXxcXFxcLikqP1wiLywgdG9rZW46IFwic3RyaW5nXCJ9LFxuICAgICAgICAgICAge3JlZ2V4OiAvXFxiKGJlY29tZXxjaGFuZ2V8Y2hhcnxkaWV8ZW5kfGdpdmV8aWZ8bG9ja3xtb3ZlfHBsYXl8cHV0fHNjcm9sbHxzZW5kfHNldHx0YWtlfHRocm93c3Rhcnx0b3JjaHxyZXN0b3JlfHNheXxzaG9vdHxzdGFuZHx1bmxvY2t8dmljdG9yeXx3YWl0fHdhbGt8emFwKVxcYi8sIHRva2VuOiBcImNvbW1hbmRcIn0sXG4gICAgICAgICAgICB7cmVnZXg6IC8oPzpub3R8YWRqYWNlbnR8YmxvY2tlZHxhbGlnbmVkfHBlZXB8ZXhpc3RzKVxcYi8sIHRva2VuOiBcImV4cHJlc3Npb25cIn0sXG4gICAgICAgICAgICB7cmVnZXg6IC9cXGQvaSwgdG9rZW46IFwibnVtYmVyXCJ9LFxuICAgICAgICAgICAge3JlZ2V4OiAvOi4qLywgdG9rZW46IFwibGFiZWxcIn0sXG4gICAgICAgICAgICB7cmVnZXg6IC9cXC9cXC8uKi8sIHRva2VuOiBcImNvbW1lbnRcIn1cbiAgICAgICAgXSxcbiAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgbGluZUNvbW1lbnQ6IFwiLy9cIlxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBlZGl0QXJlYSA9IG9wdGlvbnMuZWRpdEFyZWE7XG4gICAgdGVtcGxhdGVzID0ge307XG4gICAgZWRpdG9yID0gbmV3IEVkaXRvcihlZGl0QXJlYSwge1xuICAgICAgICBhZGRCb2FyZDogb25Cb2FyZEFkZGVkLFxuICAgICAgICByZW1vdmVCb2FyZDogb25Cb2FyZFJlbW92ZWQsXG4gICAgICAgIGNoYW5nZUJvYXJkOiBvbkJvYXJkQ2hhbmdlZCxcbiAgICAgICAgY2hhbmdlTW9kZTogb25Nb2RlQ2hhbmdlZCxcbiAgICAgICAgY2hhbmdlVGVtcGxhdGU6IG9uVGVtcGxhdGVDaGFuZ2VkLFxuICAgICAgICBjaGFuZ2VCb2FyZE9wdGlvbnM6IG9uQm9hcmRPcHRpb25zQ2hhbmdlZCxcbiAgICAgICAgY2hhbmdlR2FtZU9wdGlvbnM6IG9uR2FtZU9wdGlvbnNDaGFuZ2VkXG4gICAgfSk7XG4gICAgcGFyc2VyID0gbmV3IEp6dFNjcmlwdFBhcnNlcih0cnVlKTtcblxuICAgIGluaXRpYWxpemVCb2FyZE9wdGlvbnNEaWFsb2cob3B0aW9ucy5ib2FyZE9wdGlvbnNEaWFsb2cpO1xuICAgIGluaXRpYWxpemVXb3JsZE9wdGlvbnNEaWFsb2cob3B0aW9ucy53b3JsZE9wdGlvbnNEaWFsb2cpO1xuICAgIGluaXRpYWxpemVPcGVuRGlhbG9nKG9wdGlvbnMub3BlbkRpYWxvZyk7XG4gICAgaW5pdGlhbGl6ZVNjcmlwdERpYWxvZyhvcHRpb25zLnNjcmlwdERpYWxvZyk7XG4gICAgaW5pdGlhbGl6ZU5ld0JvYXJkRGlhbG9nKG9wdGlvbnMubmV3Qm9hcmREaWFsb2cpO1xuICAgIGluaXRpYWxpemVQcmltYXJ5VWkob3B0aW9ucyk7XG5cbn1cblxuLyoqXG4gKiBBbiBldmVudCBoYW5kbGVyIHRvIGJlIHRyaWdnZXJlZCB3aGVuIGEgQ3Jvc3MtRG9jdW1lbnQgbWVzc2FnZSBpcyByZWNlaXZlZC5cbiAqL1xuZnVuY3Rpb24gb25NZXNzYWdlKGV2ZW50KSB7XG5cbiAgICB2YXIgb3JpZ2luID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbiB8fCB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyAnLy8nICsgd2luZG93LmxvY2F0aW9uLmhvc3Q7XG5cbiAgICBpZiAoZXZlbnQub3JpZ2luICE9PSBvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5kYXRhID09PSAnc2VuZC1nYW1lJykge1xuXG4gICAgICAgIC8vIEEgZ2FtZSB3YXMgcmVxdWVzdGVkXG4gICAgICAgIGV2ZW50LnNvdXJjZS5wb3N0TWVzc2FnZSgncGxheS1nYW1lOicgKyBKU09OLnN0cmluZ2lmeShlZGl0b3Iuc2VyaWFsaXplKHRydWUpKSwgZXZlbnQub3JpZ2luKTtcblxuICAgIH1cblxufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG9uTWVzc2FnZSwgZmFsc2UpO1xud2luZG93Lm9uYmVmb3JldW5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnQSBmcmllbmRseSBoZWFkcyB1cDogSWYgeW91IGxlYXZlIHRoaXMgcGFnZSBiZWZvcmUgZG93bmxvYWRpbmcgeW91ciB3b3JrLCBpdCB3aWxsIGJlIGxvc3QgZm9yZXZlci4nO1xufTtcblxuLy8gUHJlc3NpbmcgQUxUK0EgdG9nZ2xlcyBBZHZhbmNlZCBNb2RlXG53aW5kb3cub25rZXlkb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmtleUNvZGUgPT09IDY1ICYmIGV2ZW50LmFsdEtleSkge1xuICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC50b2dnbGUoJ2FkdmFuY2VkLW1vZGUnKTtcbiAgICB9XG59O1xuXG5leHBvcnRzLmluaXRpYWxpemVFZGl0b3JVeCA9IGluaXRpYWxpemVFZGl0b3JVeDtcbiJdfQ==
(14)
});
